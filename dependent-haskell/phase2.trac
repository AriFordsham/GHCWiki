= Implementing Dependent Haskell, Phase 2

This page is to track design ideas and questions in the second phase of implementing Dependent Haskell, which is the development of a dependently typed Core. Phase 3 will include modifying surface Haskell and implementing type inference.

== Phase 2a: Homogeneous equality

The "System FC with Explicit Kind Equality" paper (ICFP'13) describes a ''heterogeneous'' equality: that is, we can form `a ~# b` even when `a :: k1` and `b :: k2`. A proof of `a ~# b` implies both that `k1` equals `k2` and that `a` equals `b`. This choice was necessitated by, among other things, the unusual binding structure in that paper's coercion between forall-types.

During the implementation of `TypeInType` (directly based on that paper), we realized several simplifications:

1. We do not need to make the binding structure of forall-coercions so strange. Instead, we can use an asymmetrical rule:

{{{
G |- g1 : t1 ~ t3
G,a:k1 |- g2 : t2 ~ t4
------------------------------------------------------------------------
G |- forall a:g1.g2 : (forall a:t1.t2) ~ (forall b:t3.t4[b |> sym g1/a])
}}}

    Though it's asymmetrical, it's far simpler than the rule in the ICFP'13 paper. This is the rule implemented in GHC 8.x.

2. The ICFP'13 paper allows the binding of coercion variables in types. That is, we can have `forall c:phi.t` as a type. However, the need for this in practice was slight, and so it was removed from the implementation.

With the simpler (asymmetrical) forall-coercion rule above, one of the primary motivations for heterogeneous equality was removed. And so, in "A Specification for Dependent Types in Haskell" (ICFP'17), we use more of a mixed economy of heterogeneity: a coercion can still related two types of different kinds, but coercion ''variables'' must be homogeneous. That is, if `c :: t1 ~# t2`, then `t1` and `t2` have equal (that is, alpha-equivalent) kinds. But if a coercion `g` relates `t1` and `t2`, then `t1` and `t2` might have different kinds `k1` and `k2`. However, we can always extract a proof that `k1 ~# k2` from `g`.

Homogeneous equality is simpler than heterogeneous equality so, all else being equal, it's better to have homogeneous equality. However, even beyond simplicity, we are able to prove congruence only with the homogeneous variant. Richard's thesis uses heterogeneous equality, and he was unable to prove congruence there. The ICFP'17 paper, with homogeneous equality, proves congruence. (It's called substitutivity there.) So this seems like a nice step forward. Congruence means that if a type `t` has a free variable `a`, and we have a coercion `co` proving `s1` equals `s2` (and `s1` and `s2` have the same kind), then we can always find a proof that `t[s1/a]` equals `t[s2/a]`. The lack of congruence has no effect in the current (GHC 8.6) implementation because it bites only in the presence of coercion quantification in types. See Section 5.8.5.4 of Richard's thesis. Given that we will need coercion quantification in types in order to have full dependent types [example needed], we will want congruence, too.

How should this homogeneous equality take form? It's simple: make `~#`, the type of primitive equality, homogeneous. That is, we want

{{{#!hs
(~#) :: forall k. k -> k -> TYPE (TupleRep '[])
}}}

(The return kind says that equality proofs take up 0 bits at runtime.) All coercion variables must have a kind headed by `~#`. With the new kind of `~#`, then we effectively make all assumptions homogeneous. (Axioms were already, and have always been, homogeneous.) Coercions themselves can remain heterogeneous, but we can write definitions like this:

{{{#!hs
coercionKind :: Coercion -> Pair Type   -- the two types might have different kinds

-- if Pair t1 t2 = coercionKind co, k1 = typeKind t1, and k2 = typeKind t2, then
-- Pair k1 k2 = corcionKind (promoteCoercion co)
promoteCoercion :: Coercion -> Coercion 
}}}

=== A small wrinkle: we need coercion quantification back

If `~#` is homogeneous in Core, then how do we support heterogeneous equality in Haskell? Easy: just use an equality between the kinds and then one between the types. But it's not so easy in practice. Examine the definition of `~~`, written as a Core datatype, even though it's really a class:

{{{#!hs
-- this version is wrong!
data (~~) :: forall k1 k2. k1 -> k2 -> Constraint where
  MkHEq :: forall k1 k2 (a :: k1) (b :: k2). (k1 ~# k2) -> (a ~# b) -> a ~~ b
}}}

Sadly, this is ill-kinded: we're using `a ~# b` even though `a` and `b` have different kinds. Of course, we know that `k1` and `k2` are the same, but that doesn't quite help us here. Instead, we need to ''name'' the coercion between `k1` and `k2`, thus:

{{{#!hs
data (~~) :: forall k1 k2. k1 -> k2 -> Constraint where
  MkHEq :: forall k1 k2 (a :: k1) (b :: k2). forall (co :: k1 ~# k2) -> ((a |> co) ~# b) -> a ~~ b
}}}

This version names the kind coercion `co` so it can be used in the type proposition. All is well again. Sadly, the implementation does not support coercion quantification in types like this. So it's time to implement it.

=== Coercions are quantified both relevantly and dependently

Up until now, GHC has kept two ideas separate: relevance and dependence. A variable quantified relevantly is preserved until runtime, while a variable quantified dependently is available for use in a type. Term variables are relevantly quantified (with `FunTy`), while type variables are dependently quantified (with `ForAllTy`) and are irrelevant. Coercion variables now, though, need to be both dependent ''and'' relevant. (Even though they have 0 bits, a coercion variable is treated very much like a normal term-level variable.) We thus have a problem:

{{{#!hs
typeKind (\ (x :: Nat). ...) = FunTy Nat ...
typeKind (\ (a :: Type). ...) = ForAllTy (a::Type) ...
typeKind (\ (c :: a ~# b). ...) = ????????
}}}

Here is the design Simon and Richard (with Ningning's input) have come up with:

* The type of a coercion-lambda shall be a `ForAllTy` iff the coercion variable is mentioned in the result type. It shall be a `FunTy` iff the coercion variable is not mentioned in the result type.

Equivalently:

* INVARIANT: If a `ForAllTy` quantifies over a coercion variable, that variable ''must'' be mentioned later in the type.

With these choices, we never have to equate `ForAllTy`s with `FunTy`s in, say, `eqType`. The downside to this design is that it is non-performant: we must do a free-variable check when building `ForAllTy`s to maintain the invariant. However, the key observation here is that we need to do this check only when building a `ForAllTy` with a coercion variable -- ''something we never do today''. So it will be rare in the near future. And, we should be able to easily distinguish when we're about to quantify over a coercion, so the normal `mkForAllTy` can just `ASSERT` that its variable is a tyvar. We'll have a new `mkCoVarForAllTy` that quantifies over coercions and does the free-variable check.

We believe that, in the future, `FunTy` and `ForAllTy` may merge into `PiTy`. That future is not yet here, and there's no need to rush it. 

=== Coercion holes

As the constraint solver solves constraints, it generates ''evidence''. For class constraints, this evidence takes the form of dictionaries that package the implementations of class methods. For equality constraints, this evidence takes the form of coercions. Because sometimes the solver has no place to bind evidence (like when we are kind-checking types, so there is no `let` or `case`), it stores coercion evidence in ''coercion holes''. A coercion hole is a mutable cell, of type `IORef (Maybe Coercion)`. The cell starts out empty (`Nothing`) and then is filled in when the solver know how to build the coercion. These holes are used in coercions during type inference. When we're done type checking, coercion holes are zonked to be replaced by the coercion in the hole. All holes will be filled by the end -- otherwise, the program has a type error that we will have reported to the user. (There is special allowance for deferred type errors, which I won't describe here.)

None of the above changes. However, currently, coercion holes are implemented with this definition, in !TyCoRep:

{{{#!hs
data CoercionHole
  = CoercionHole { ch_co_var :: CoVar
                 , ch_ref    :: IORef (Maybe Coercion)
                 }
}}}

By pairing the mutable cell with a `CoVar`, we get several benefits:

* The `CoVar` has a name and unique, so we can print it during debugging to track the coercion holes.
* The `CoVar` has a kind, so we know the two types that the coercion hole relates. This is necessary to be able to write `coercionKind`.
* The `CoVar` has a role (buried in its kind), necessary to implement `coercionRole`.
* The `CoVar` can be included in sets of free variables in a coercion. This is necessary so that we do not float a coercion with a hole out from an implication invalidly. See `Note [CoercionHoles and coercion free variables]` in !TyConRep.

In our new world with homogeneous equality, we have a problem, though: a `CoVar` must be homogeneous. Yet, the solver will sometimes have to work with heterogeneous equality (more on that later). We thus have to remove the `CoVar`. Thus, `CoercionHole` becomes

{{{#!hs
data CoercionHole
  = CoercionHole { ch_types :: Pair Type
                 , ch_role  :: Role
                 , ch_name  :: Name      -- for debugging only
                 , ch_level :: TcLevel   -- more on this below
                 , ch_ref   :: IORef (Maybe Coercion)
                 }
}}}

These new coercion holes are ''not'' returned as free variables.

=== Preventing floating

If coercion holes are no longer returned as free variables, how do we prevent bad floating? (Here, "floating" refers to the process by which a constraint inside an implication is floated out of that implication -- that is, the constraint is attempted absent any of the assumptions of the implication. This can be done only when the constraint mentions no variables bound by the implication.)  By tracking levels. The type checker manages a `TcLevel`, a natural number that starts at 0 and is incremented as the type checker enters scopes. Essentially, the `TcLevel` is the count of how many local scopes the type checker has entered. All type variables are assigned a `TcLevel` saying what scope they belong to. Note that there are no global type variables, so these levels start at 1. To prevent floating, all we have to do is to make sure that the maximum level of any variable in a type is not equal to (or greater than) the level of the implication. (All implications have levels, too, because implication constraints correspond to local scopes. The level in the implication is the level of the variables in the implication.) If the maximum level of any variable in a type is less than the level of the implication, floating is fine.

We already have the maximum-level checker: `TcType.tcTypeLevel`. All we need to do is add levels to coercion holes (we can use the level from `getTcLevel :: TcM TcLevel`) in the `ch_level` field and then incorporate that into `tcTypeLevel`. Then, we modify the floating-out mechanism to do a level-check instead of a free-variable check. This is done in `TcSimplify.floatEqualities`.

'''RAE Question:''' Currently, `floatEqualities` does a free-variable check and then ''promotes'' levels (reducing level numbers) of some variables. If we use the level numbers to decide what to float, when will we ever promote? This seems like it might not work. '''End RAE'''

=== Heterogeneity in the solver

While we'd like to remove heterogeneous coercion variables from Core, they are useful in the solver.
Specifically, when we're analyzing an equality like `ty1 ~ (ty2 |> co)`, it[['s helpful to strip off the `co` and look at `ty1 ~ ty2`. This might discover similarities between `ty1` and `ty2` that can move solving forward. One of `ty1 ~ (ty2 |> co)` or `ty1 ~ ty2` is heterogeneous.

Currently, all constraints in the solver have types. For example, a constraint might have a type of `Eq [a]`. Equality constraints have types, too. Currently, these types use `~#`. But if we have a homogeneous `~#`, then we won't be able to express a heterogeneous equality constraint using `~#`. The types in the solver are useful because we make evidence bindings with those types. However, all equality wanted constraints use coercion holes for their evidence (more on givens later), so no binding is needed. We can thus store a heterogeneous equality constraint simply by storing a pair of types.

Note that the `TcEvDest` type stores either an evidence binding or a coercion hole. The new form of constraint (the pair of types) will always go hand-in-hand with the `HoleDest` constructor of `TcEvDest`.

=== Heterogeneous given equalities

Even though we do not use evidence bindings for equality wanteds, we still do use bindings for equality givens. These are often inlined (where?), but they start life as ordinary bindings, with types. To have heterogeneous givens but homogeneous `~#`, this will have to change. We thus need a dual of `TcEvDest`:

{{{#!hs
data TcEvSource
  = EvVarSource EvVar
  | CoercionSource Coercion
}}}

Just as a wanted constraint carries with it a `TcEvDest`, a given constraint will have to carry a `TcEvSource`. Unlike wanteds, though, ''sometimes'' an equality given will be an `EvVarSource`, if that equality given arises from, say, a superclass selector or GADT pattern match or some such. When a `CoercionSource` given is used, we just substitute the given into the coercion we are building (in a `CoercionHole` value). This will happen in `TcRnTypes.ctEvCoercion`, and possibly elsewhere.

=== Some other details

* The three primitive equality tycons (`eqPrimTyCon`, `eqReprPrimTyCon`, and `eqPhantPrimTyCon`) all get a homogeneous kind.

* `coercionKind` does not need to change.

* Remove the now-redundant `KindCo` constructor for coercions.

* `coercionType` now works only over homogeneous coercions. We will have to audit usages of this function to make sure it doesn't get called on something heterogeneous.

* The core-spec will have to be updated.

* `~~` will have to be updated to use two `~#`s, as demonstrated above.

* Simon suggests that it is easier to have `~` refer directly to `~#`, instead of the current setup where it is defined in terms of `~~`. This is an unnecessary refactoring, but it might lead to a small performance win as there is one fewer indirection.

=== Open questions

* What is the concrete design (type definitions) for the types in the solver to deal with heterogeneous equality constraints without using `~#`?

* At some point, GHC must assume that `ForAllTy`s are irrelevant. Now, however, a `ForAllTy` over a coercion variable is relevant, and must make a proper runtime function. Where is the code that has to change?