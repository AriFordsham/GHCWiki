= Status of DWARF work slated for GHC 8.0 =

== Current Status ==

While DWARF support will be much improved in 8.0.1, it is unfortunately still rather unsafe. This is due to prevalence of foreign calls in GHC/Haskell code, which can currently result in incorrect stack unwinding information (#11353, #11338, #11337). This means that requesting a stack trace may result in a segmentation fault of the program. Unfortunately, fixing this was beyond the scope of my time budget for 8.0, although hopefully can be done for 8.2.

If you are prepared to accept the potential for segfaults, GHC 8.0.1 now provides a good amount of new functionality,

 * the DWARF output is more correct, meaning that external tools should have less trouble working with GHC's output
 * GHC's runtime system has support for DWARF stack unwinding on Linux, x86_64 and i386 via `libdw`. This is exposed in two ways,
    * A stack trace will be provided on stderr when runtime system panics
    * A stack trace will be dumped to stderr when the program receives the `SIGUSR2` signal
    * A stack trace can be requested from Haskell code with the `GHC.ExecutionStack` module

All of this requires that the program is compiled with GHC's `-g` flag. To get reliable output, the program's dependencies must also be compiled with `-g`.


== Notation ==

These are in various states of completion which I (Ben Gamari) will encode with the
following designations,

 MERGED:: Already merged to `master`, listed here for completeness

 READY::  Believed to be finished with no expectation of major rework
          being necessary. Should be in merge-worthy condition, pending
          code review.

 RFC::    Code done, builds, and tested to some extent; needs design
          review.

 EXPLOR:: Exploratory work, may not even build but included to document
          the expected future direction of the work.

 IDEA::   Just an idea, no implementation yet.

I'll list the commits in the order of their logical progression,

== The Patches ==

=== Basic DWARF support ===

These preparatory commits address a few bugs and deficiencies in the
current DWARF production implementation,

 * [MERGED]  Phab:D1172 Dwarf: Fix DW_AT_use_UTF8 attribute
 * [MERGED]  Phab:D1173 Dwarf: Produce {low,high}_pc attributes for compilation units
 * [MERGED]  Phab:D1174 Dwarf: Produce .dwarf_aranges section
 * [MERGED]  Phab:D1220 Dwarf: Ensure block length is encoded correctly

These introduce DWARF parsing and stack unwinding to the RTS by
introducing an optional dependency on `libdw`. This is the same library
used by `perf`.

 * [MERGED]  Phab:D1196: Libdw: Add libdw-based stack unwinding
 * [MERGED]  Phab:D1197: Signals: Print backtrace on SIGUSR2
 * [MERGED]  Phab:D1418: Produce a stacktrace when the RTS barfs

With the RTS groundwork in place we can plumb things in for use by user
programs,

 * [MERGED]  Phab:D1198: Provide DWARF-based backtraces to Haskell-land

Unfortunately up until this point we have no ability to unwind out of
Haskell code back to the C stack. These commits introduce the ability to
unwind all the way back to `_start`,

 * [MERGED]  Phab:D1224: Dwarf: Preserve stack pointer register
 * [MERGED]  Phab:D1225: cmm: Expose machine's stack pointer and return address registers
 * [MERGED]  Phab:D1223: StgStartup: Add DWARF unwinding annotations for stg_stop_thread
 * [READY]   Phab:D1532: Dwarf: Assume first block in a proc has an info table

This should be enough to get reasonable backtraces for error-handling
and reporting.

=== Further stabilization ===

While the DWARF annotations produced by GHC 8.0.1 were a significant improvement over
previous releases, they still broke in a number of important cases (largely
due to foreign calls; see #11137, #11138). GHC 8.2 will hopefully fix up these remaining cases,

 * [RFC]     Phab:D1732: Improve accuracy of unwinding in presence of foreign calls
 * [RFC]     Phab:D2738: Cmm: Add support for undefined unwinding statements

=== Statistical Profiling ===

However, we also want profiling. For this, however, DWARF annotations
alone aren't sufficient. The plan here is to incorporate a more details
from the source notes produced by GHC into the DWARF vendor extension
DIEs.

The RTS then takes these DIEs during program initialization and
emits a representation of them to the eventlog for later use by analysis
code,

 * [MERGED] Phab:D1279: Output source notes in extended DWARF DIEs
 * [RFC]    Phab:D1280: rts: Emit debug information about program to event log
 * [MERGED] Phab:D1281: Support multiple debug output levels
 * [MERGED] Phab:D1387: Preserve tick parentage

Now we have everything necessary to add some basic statistical
profiling. Here we collect samples from heap checks and black hole block
events and emit them to the event log,

 * [RFC]    Phab:D1215: A simple statistical profiler
 * [RFC]    Phab:D1216: StatProfile: Heap and black-hole sampling

This all appears to work and I have some rather crude analysis tools
which I should really clean up a bit. Ideally someone would dust off
Peter's Threadscope integration as this would make for an extremely
compelling performance analysis story.

I also have yet to examine the impact of profiling on performance when
not enabled. In principle it should be cheap enough to compile in
unconditionally (although event log support is needed) but this needs to
be measured.

It would also be nice to support time- or cycle-based sampling.
 * [IDEA]   Support basic timer-based sampling
 * [RFC]    Phab:D1517: Support sampling with Linux `perf_events` interface
 * [IDEA]   Support for kernel-mode Haskell stack sampling on Linux via eBPF

In addition, we may want to support some form of call-graph collection.
This, however, will be left for future work.

In his prototype implementation Peter also had the lovely ability to
preserve simplified Core for later examination. This would be a nice
thing to have but probably won't happen for 8.0. The challenge here is
recording the Core fragments without introducing enormous amounts of
redundancy.

 * [IDEA]   Record tree of Core fragments into DWARF DIEs (Core Notes)

Finally, it would be great if we could provide stack traces alongside exceptions.
There are some ideas for how to do this in [[Exceptions/StackTraces]].

 * [IDEA]   Record stack traces with synchronous and asynchronous exceptions

Also, currently we only provide debug information with the native code generator.
Doing the same in the LLVM code generator shouldn't be so hard,

 * [RFC]    Phab:D2343: Add debug information output to LLVM code generator

=== Documentation ===

Now since we have all of these features, we need to make sure the user knows what they do.

 * [MERGED] Phab:D1369   Add debugging information chapter to the GHC users guide