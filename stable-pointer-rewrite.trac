== Goals

1. Collect the stable pointer table by generation (resolving #7670). At present, every minor collection needs to inspect every cell in the stable pointer table. Adding insult to injury, that even includes cells that haven't been occupied since the last major collection or ever.

2. Avoid the indirection and pauses inherent in the current array-doubling mechanism (see #15665), turning a stable pointer into a pointer directly to the relevant cell.

3. Keep the stable pointer table approximately as compact as it is today. When the table is large (and has not shrunk from its maximum historical size), we should ensure that (approximately) half the space used is devoted to actual live pointers.

4. Reduce the synchronization overhead inherent to the current array-doubling mechanism (again see #15665).

5. To the extent that we can do so efficiently, make the system lock-free. Two potential advantages:
   a. Non-Haskell threads can delete stable pointers during garbage collection.
   b. If a non-Haskell thread is killed while it is deleting a stable pointer, the Haskell runtime will survive.

== Overview of proposed system

There are several different areas and levels of organization we need to handle. The stable pointer table needs to be broken into pieces, and there are things that have to be handled per-capability and per-generation. I'll try to explain things in a comprehensible order, but some things may not make sense in any one linear reading.

I will assume the stable pointer table is broken into "blocks" (which may be smaller than those provided by the block allocator) consisting of one or more "segments". The segment is the most important unit; blocks let us reduce the amount of extra space we need for GC.

=== The segment

Each segment contains:

1. No more than `WORDSIZE` entries (probably a few less than that for alignment reasons).
2. A "free list" bitmap indicating which entries in the segment are currently free. This bitmap is a fundamental source of truth and is always considered up to date.
3. A "next-free-enough" pointer (see below).
4. For each generation, a bitmap of entries in that generation. To align segments nicely, I believe we need to limit the number of per-generation bitmaps to somewhere between 3 and 8 (depending on the number of segments per block and other trade-offs). Assuming there are N per-generation bitmaps, all stable pointer table entries in generations N-1 and older will be inspected when collecting generation N-1. A generation bitmap ''may'' be out of date:
    a. An entry may be allocated (removed from the free list bitmap) but not yet added to its generation bitmap.
    b. An entry may be deleted but still present in a generation bitmap.
    
    However,
    a. All allocations will be complete (added to their generation bitmaps) before the garbage collector runs.
    b. No entry will ever be in more than one generation bitmap at a time.

=== The block

Each block contains:

1. One or (most likely) more segments.
2. For each GC generation, a pointer to the next block in that generation (or null if this block is not in the generation).

A block is considered to be in a generation if at least one of its segments contains at least one (non-free) entry pointing to an object in that generation.

=== Per-capability pieces

1. The active segment. Each capability allocates stable pointers into one segment (its active segment) at a time. Any given segment can be the active segment for at most one capability at a time. When a capability's active segment is sufficiently full, the capability "relinquishes" the segment by setting its next-free-enough pointer to null (this will make more sense later).

2. A private copy of the free list bitmap for its active segment that lags behind the true free list. The capability steps through this private copy when allocating entries. When it runs out of entries in the private copy, it makes a fresh private copy and uses that to update the generation lists; this maintains the invariant that an entry is never in more than one generation.

3. A list of blocks in each generation. 