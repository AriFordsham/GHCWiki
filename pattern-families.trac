This is a proposal for allowing '''families of patterns''' indexed by expressions.

It is similar to a pattern synonym (PatternSynonyms) and desugars directly into a view pattern (ViewPatterns) so familiarity with those two extensions is recommended.

The arguments to pattern families effectively fall into two categories: expressions used to index the pattern family (information flowing ''into'' the pattern) and the arguments that can be pattern matched against (information flowing ''out of'' the pattern).

The simplest useful example of this might be a `Between` pattern that only matches a particular range, a feature of [http://doc.rust-lang.org/master/tutorial.html#pattern-matching Rust's pattern matching] facility:

{{{
between (from, to) n = from <= n && n <= to

pattern Between from to <- (between (from, to) -> True)

-- A teenager is between thirteen and nineteen, would be:
--     13..19 => true,
--     _      => false
-- in Rust.
isTeen :: Age -> Bool
isTeen (Between 13 19) = True
isTeen _               = False
}}}

that gets transformed into:

{{{
isTeen :: Age -> Bool
isTeen (between (13, 19) -> True) = True
isTeen _                          = False
}}}

`Between` will work on any orderable type:

{{{
generalCategory' :: Char -> GeneralCategory 
generalCategory' (Between '\x00' '\x16') = Control
generalCategory' (Between 'a'    'z'   ) = LowercaseLetter
generalCategory' (Between 'A'    'Z'   ) = UppercaseLetter
generalCategory' (Between '0'    '9'   ) = DecimalNumber
}}}

== Syntax ==
The syntax from PatternSynonyms can be reused for simplicity:

{{{
    pattern Take n xs <- (take n -> xs)
}}}

here `xs` is a normal variable as in PatternSynonyms but `n` must be a concrete expression that the pattern is indexed by: this can be inferred from it appearing in the ViewPatterns expression (`take n`) rather than in the pattern.

The function `fn`:

{{{
    fn :: [a] -> [a]
    fn (Take 2 xs) = xs

    ghci> fn "hello"
    "he"
}}}

is thus the same as writing `fn (take 2 -> xs) = xs` using view patterns.

For the case of `Take 2` it can be rewritten using simple pattern synonyms:

{{{
    pattern Take2 xs <- (take 2 -> xs)
}}}

but this would need to be defined for each `Int`. In this sense pattern families are a bit like polymorphic functions, just like `length` can be used rather than defining many specialized functions:

{{{
    lengthInt    :: [Int]    -> Int
    lengthBool   :: [Bool]   -> Int
    lengthDouble :: [Double] -> Int
    …
}}}

we can use `Take` with arguments (`Take 0`, `Take 1`, `Take 2`, …) to have the same meaning as the following pattern synonyms:

{{{
    pattern Take0 xs <- (take 0 -> xs)
    pattern Take1 xs <- (take 1 -> xs)
    pattern Take2 xs <- (take 2 -> xs)
    …
}}}

=== Grammar ===
A simple grammar would then be

    `pattern` ''conid'' ''varid,,1,,'' .. ''varid,,n,,'' `<-` (''expr'' `->` ''pat'')

where each ''varid,,i,,'' must be free in either ''expr'' or ''pat''.

== Dynamic semantics (Desugaring) ==
More concretely, a pattern definition has the form:

    `pattern` ''conid'' [''evarid,,i,,'', ''pvarid,,j,,''] `<-` (''expr'' `->` ''pat'')

where [''evarid,,i,,'', ''pvarid,,j,,''] denotes some interleaving of variables that appear in ''expr'' or ''pat''. When matched against, all ''evarid,,i,,'' must be instantiated with expresions ''expr,,i,,'':

    `fn` (''conid'' [''expr,,i,,'', ''pvarid,,j,,'']) = `result`

where ''pvarid,,j,,'' may appear in `result` as in usual patterns. This then gets translated into the following view pattern:

    `fn` (''expr''[''evarid,,i,,'' := ''expr,,i,,''] `->` `pat`) = `result`

For the simple example of the pattern family `Take` this (where 3 is ''expr,,1,,'' and `xs` is ''pval,,1,,''):

{{{
    foo (Take 3 xs) = xs ++ xs
}}}

would get translated to:

{{{
.    foo (take 3 -> xs) = xs ++ xs
}}}

which is the same as:

{{{
    foo ys = case take 3 ys of
      xs -> xs ++ xs
}}}

== Static semantics (Typing) ==
If ''expr'' in the view pattern is an expression of type ''t'' with free variables ''evarid,,i,,'' of type ''t,,i,,'' then an ''expr,,i,,'' used to instantiate the corresponding ''evarid,,i,,'' must have a type ''u,,i,,'' that unifies with ''t,,i,,'', the final expression ''expr'' will have type ''t''. Otherwise same typing and scoping rules as [https://ghc.haskell.org/trac/ghc/wiki/ViewPatterns#Semantics ViewPatterns].

== Motivating examples ==

=== Sets ===
Example from ViewPatternsAlternative:

{{{
module Set(Set, empty, insert, delete, has) where

    newtype Set a = S [a]
  
    has :: Eq a => a -> Set a -> Maybe (Set a)
    has x (S xs) | x `elem` xs = Just (S (xs \\ [x]))
                 | otherwise   = Nothing
}}}

Using patterns indexed by an element of `Set a`:

{{{
    pattern Has    x set <- (has x        -> Just set)
    pattern HasNot x set <- (has x &&& id -> (Nothing, set))
}}}

One can write:

{{{
    delete :: Eq a => a -> Set a -> Set a
    delete x (Has x set) = set
    delete x set         = set

    insert :: Eq a => a -> Set a -> Set a
    insert x (HasNot x (S xs)) = S (x:xs)
    insert x set               = set
}}}

Compare that to the the ViewPatternsAlternative proposal:
{{{
    delete :: Eq a => a -> Set a -> Set a
    delete x (r | Just s <- has r) = set
    delete x set                   = set
  
    insert :: Eq a => a -> Set a -> Set a
    insert x (s | Just _ <- has x s) = set
    insert x (S xs)                  = S (x:xs)
}}}

Where the user has to worry about matching on `Just`s. 

Using operators `:∈ = Has` and `:∉ = HasNot`:

{{{
    delete x (x :∈ set)  = set
    insert x (x :∉ S xs) = S (x:xs)
}}}

if one were so inclined.

=== Erlang-style parsing ===
Another example stolen from ViewPatternsAlternative where the benefits are more apparent. Given a parsing function:

{{{
    bits :: Int -> ByteString -> Maybe (Word, ByteString)
    -- (bits n bs) parses n bits from the front of bs, returning
    -- the n-bit Word, and the remainder of bs
}}}

and using the following pattern family:

{{{
    pattern Bits n val bs <- (bits n -> Just (val, bs))
}}}

one can write a pattern like this:

{{{
    parsePacket :: ByteString -> _
    parsePacket (Bits 3 n (Bits n val bs)) = _
}}}

Note that this is our first example of nesting a pattern family. More examples follow in the more advanced examples below.

Compare that to the ViewPatternsAlternative version:

{{{
    parsePacket :: ByteString -> _
    parsePacket (p1 |  Just (n, (p2 | Just (val, bs) <- bits n p2)) <- bits 3 p1) = _
}}}

=== N+k patterns ===
Another one from ViewPatternsAlternative using the following view and pattern family:

{{{
    np :: Num a => a -> a -> Maybe a
    np k n | k <= n    = Just (n-k)
           | otherwise = Nothing

    pattern NP k n <- (np k -> Just n)
}}}

Used as follows:

{{{
    fib :: Num a -> a -> a
    fib 0        = 1
    fib 1        = 1
    fib (NP 2 n) = fib (n + 1) + fib n
}}}

Compare ViewPatternsAlternative version:

{{{
    fib :: Num a -> a -> a
    fib 0 = 1
    fib 1 = 1
    fib (n2 | let n = n2-2, n >= 0) = fib (n + 1) + fib n
}}}

=== Type checking ===
From [http://itu.dk/people/drc/tutorials/bidirectional.pdf Bidirectional Typing Rules: A Tutorial]:

{{{
    inferType ctx (If t1 t2 t3) = case (inferType ctx t1, inferType ctx t2, inferType ctx t3) of
      (Just BoolT, Just ty2, Just ty3) -> 
        if ty2 = ty3 
        then Just ty2
        else Nothing
      _ -> Nothing
}}}

could be rewritten using pattern families as:

{{{
    -- Here ‘Inf’ is a family indexed by ‘ctx’
    pattern Inf ctx ty <- (inferType ctx -> Just ty)

    inferType ctx (If (Inf ctx BoolT) (Inf ctx ty1) (Inf ctx ty2))
       | ty1 == ty2 = Just ty1
    inferType ctx If{} = Nothing
}}} 

allowing the user to pattern match ''directly'' on the inferable types without manually checking for `Just`s — note the use of the previous argument `ctx` to index later. This could currently be written somewhat awkwardly using view patterns:

{{{
    inferType ctx (If (inferType ctx -> Just BoolT) (inferType ctx -> Just ty1) (inferType ctx -> Just ty2))
       | ty1 == ty2 = Just ty1
    inferType ctx If{} = Nothing
}}}

which is longer and clunkier, especially since the user is forced to deal with `Just`s again.

Again one could use operators (`:⇒ = Inf`) in which case it the examples follow notation in type theory more closely:

{{{
    inferType γ (If (γ :⇒ BoolT) (γ :⇒ τ₁) (γ :⇒ τ₂)) = ...
}}}

=== More advanced examples: Regular expressions ===
Given a regular expression operator `(~=) :: String -> String -> Maybe [String]` we can define a pattern:

{{{
    pattern Match x regexp <- ((~= regexp) -> Just x)
}}}

where `regexp` is indexes the `Match` pattern family:

{{{
    firstWord (Match words "[a-zA-Z]+") = words
    firstWord _                         = error "No words found"
}}}

or

{{{
    vowels (Match vwls "[aeiou]") = length vwls
}}}

As an operator:

{{{
    pattern x :~= regexp <- ((~= regexp) -> Just x)
}}}

=== More advanced examples: Prism patterns === 

==== Matching a simple prism ====
Indexing patterns with prisms from [http://hackage.haskell.org/package/lens-4.2/docs/Control-Lens-Prism.html Control.Lens.Prism]:

{{{
    import Control.Lens.Prism

    pattern Match prism a <- (preview prism -> Just a)
}}}

one can write

{{{
    bar :: Either c (Either a b) -> a
    bar (Match (_Right._Left) a) = a
    bar _                        = error "..."
}}}

==== More complicated prisms ====
Pattern families can be used to match nested data like JSON, ASTs or XML, here is an example of using it to match on [http://hackage.haskell.org/package/lens-4.2/docs/Data-Aeson-Lens.html Data.Aeson.Lens]:

{{{
    jsonBlob = "[{\"someObject\": {\"version\": [1,0,3]}}]"
    
    -- val = Number 0.0
    val = jsonBlob ^?! nth 0 . key "someObject" . key "version" . nth 1
}}}

Pattern families allow us to say we want to fetch the same value as `val` using patterns:

{{{
    foo (Match (nth 0) (Match (key "someObject") (Match (key "version") (Match (nth 1) a)))) = a
}}} 

Which is terribly verbose, but can be improved by introducing:

{{{
    pattern Get i   a <- (preview (nth i)   -> Just a)
    pattern Key str a <- (preview (key str) -> Just a)

    baz (Get 0 (Key "someObject" (Key "version" (Get 1 a)))) = a
}}}

or  by writing it infix:

{{{
    baz (0 `Get` "someObject" `Key` "version" `Key` 1 `Get` a) = a
}}}

or by defining operators `:→ = Get i a` and `:⇒ = Key`:

{{{
    baz (a :→ "someObject" :⇒ "version" :⇒ 1 :→ a) = a
}}}