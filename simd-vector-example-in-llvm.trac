It is useful to see the vector instructions "in action" in LLVM human readable form (a ".ll" file) prior to implementing the Cmm -> LLVM backend (within the ./compiler/llvmGen section of the code).  LLVM code is somewhere between Java byte code authoring and direct assembly language authoring.  Here is the process:

 - Generate or Create a human readable file (a ".ll" file), for example, create "add_floats.ll"
 - Compile this file to byte code using the LLVM compiler:  llvm-as add_floats.ll.  This generates a ".bc" file, in this case, add_floats.bc.  The byte code is unreadable.
 - Now there are a few options once byte code is available
   - Generate native machine code:  llc add_floats.bc will create a native assembler instruction set in a ".s" file (add_floats.s)
   - Run the byte codes on the JIT compiler:  lli add_floats.bc should run the instructions and produce the result

To demonstrate the vector instructions, we can start with a basic C program (just to illustrate ... remember, LLVM is not functional so starting in an imperative language makes a lot of sense):
{{{
#include <stdio.h>
#include <stdlib.h>

int main() {
 float x1, x2, x3, x4, result;
 x1 = 1.0;
 x2 = 2.0;
 x3 = 3.0;
 x4 = 4.0;
 result = x1 + x2 + x3 + x4;
 printf("result = %f\n", result);
}
}}}

Compiling and running this in C is easy and left to the user.

This converts easily to LLVM human readable format (use the [http://llvm.org/demo/index.cgi online generator] if you'd like):
{{{
; ModuleID = '/tmp/webcompile/_14760_0.bc'
target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64"
target triple = "x86_64-unknown-linux-gnu"

@.str = private unnamed_addr constant [13 x i8] c"result = %f\0A\00"

define i32 @main() nounwind {
  %1 = alloca i32, align 4
  %x1 = alloca float, align 4
  %x2 = alloca float, align 4
  %x3 = alloca float, align 4
  %x4 = alloca float, align 4
  %result = alloca float, align 4
  store i32 0, i32* %1
  store float 1.000000e+00, float* %x1, align 4
  store float 2.000000e+00, float* %x2, align 4
  store float 3.000000e+00, float* %x3, align 4
  store float 4.000000e+00, float* %x4, align 4
  %2 = load float* %x1, align 4
  %3 = load float* %x2, align 4
  %4 = fadd float %2, %3
  %5 = load float* %x3, align 4
  %6 = fadd float %4, %5
  %7 = load float* %x4, align 4
  %8 = fadd float %6, %7
  store float %8, float* %result, align 4
  %9 = load float* %result, align 4
  %10 = fpext float %9 to double
  %11 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([13 x i8]* @.str, i32 0, i32 0), double %10)
  %12 = load i32* %1
  ret i32 %12
}

declare i32 @printf(i8*, ...)
}}}

This is easy enough to run using the JIT compiler:  lli add_floats.ll

The core of the instructions can be replaced with vectorization (obviously, optimizing this program will result in very little code and vectorization is not necessary, but this is an exercise.

Here is the .ll code rewritten with vectorization:
{{{


}}}

