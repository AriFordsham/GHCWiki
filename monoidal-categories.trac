
[https://ghc.haskell.org/trac/ghc/ticket/9596 Trac ticket]

[https://phabricator.haskell.org/D212 Phabricator differential]
== Design of the monoidal category classes and the new Arrow/proc desugaring story ==
=== What are monoidal categories and why are they useful? ===
Monoidal (and related) categories capture the basic notion of //process//. This is most easily noticed by recognising a tool for using monoidal categories called [http://ncatlab.org/nlab/show/string+diagram string diagrams]. Examples of string diagrams include circuit diagrams, flow charts, signal flow diagrams, Feynman diagrams, proof nets, etc. In that way, monoidal categories are like Arrows (indeed, every Arrow is a monoidal category with an additional structure which allows reification of functions, and application of one input to another) - except much more general. For example, Megacz's work on Generalized Arrows can be entirely subsumed by monoidal categories (indeed, I even based the initial design off of parts of his thesis)

=== Overview ===
The new class hierarchy is based on monoidal categories, and monoidal categories with additional structure. What is a monoidal category? [http://ncatlab.org/nlab/show/monoidal+category From ncatlab:]

||=Definition=||=Explaination=||
||⊗:M×M→M||Bifunctor called the tensor product||
||1::M||An object called the unit||
||a,,x,y,z,,:(x⊗y)⊗z→x⊗(y⊗z)||The tensor product is associative both ways (isomorphism)||
||λ,,x,,:1⊗x→x||An elimination and introduction rule for removing the left unit from a tensor (isomorphism)||
||ρ,,x,,:x⊗1→x||An elimination and introduction rule for removing the right unit from a tensor (isomorphism)||

It also obeys two laws known as the Pentagon equation and the Triangle equation.

== Plan ==
1. Write monoidal category class heirarchy in GHC.Arrows.Experimental and provide instances for Arrow and several other basic types
2. Convert or write a small FRP library to be based on the new classes to test the design
3. Provide optimisation RULES pragmas as much as possible; for example, the work on Causal Commutative Arrows can be converted relatively straightforwardly to plain monoidal categories
4. Convert the proc/arrow desugarer in GHC to emit instances of the new classes; since all Arrows are monoidal categories, this change will be backwards compatible with user code
5. Change GHC.Arrows.Experimental to GHC.MonoidalCats before the milestone it is merged for


I will be updating this page to document/brainstorm the design as I go along.

== Current challenges ==
How to implement the unit/counit morphisms from compact closed categories? That is, how to implement a morphism unit :: I -> A*⊗A and A⊗A* -> I?