= Type Functions and Associated Types in GHC - The Master Plan =

This page serves as a collection of notes concerning the implementation of type functions and associated types, especially about the implications for type checking, interface files, and F,,C,, intermediate code generation.

== Aims ==

New features:
 * Open type-indexed data types and type functions
 * Associated data types and type synonyms, which are type-indexed data types and type functions associated with a class - i.e., associated types are syntactic sugar for type-indexed types and type functions.

Revised features
 * We may want to re-implement functional dependencies using associated type synonyms.

We keep track of the current [wiki:TypeFunctionsStatus implementation status].


== Specification and Restrictions ==

Refinement of the specification in the ''Beyond Associated Types'' paper.  (I'll actually link this paper here once it is a bit more coherent.)  Some [wiki:TypeFunctionsExamples examples are on an extra page].
 * Kind signatures of indexed data type families have the form
 {{{
data family T a1 .. an [:: <kind>]
}}}
 and introduce a type family whose kind is determined by the kinds of the `ai` (which can have kind annotations) and the optional signature `<kind>` (which defaulys to `*`).  Newtypes families have the same form, except for the initial keyword.
 * Kind signatures of type function have the form
 {{{
type family T a1 .. an [:: <kind>]
}}}
 and introduce `n`-ary type functions (with `n` >= 1), which may be of higher-kind.  Again, the type variables can have kind signatures and the result kind signature is optional, with `*` being the default.  Equations for an `n`-ary type function must specify exactly `n` arguments, which serve as indexes. 
 * Applications of type functions need to supply all indexes after unfolding of all ordinary type synonyms.  (This is the same saturation requirement that we already have on ordinary type synonyms.)
 * Instances of indexed data types/newtypes and equations of type functions have the keyword `instance` after the first keyword.  They otherwise have the same form as ordinary data type/newtype and type synonym declarations, respectively, but can have non-variable type indexes as arguments.  Type indexes can include applications of indexed data types and newtypes, but no type functions.
 * Instances of indexed types are only valid if a kind signature for the type constructor is in scope.  The kind of an indexed type is solely determined from the kind signature.  Instances must conform to this kind.  In particular, the argument count of data and newtype instances must match the arity indicated by the kind.  The number of arguments of a type equation must be equal to the number of type indexes (i.e., type variables in the head) of the family declaration.
 * Associated types are type families declared as part of a type class.  The syntax of family declarations in class declarations and of type instance declarations in instance declarations is as for toplevel declarations, but without the `family` and `instance` keywords and with the kind signature being compulsory.
 * Instances of an assoicated type can only be defined in instances of its class.  However, it is admissible to omit the type definition in instances of the class (similar to how methods may be omitted).  Then, the only inhabitant of the corresponding type is `undefined`.
 * All argument variables of an associated type family declaration need to be class parameters.  There may not be any repetitions, but the order of the variables can differ from that in the class head and the type family can be defined over a subset of the class parameters.
 * In instances, the type indexes of a type declaration must be identical to the corresponding class parameters (i.e., those that share the same variable name in the class declaration).  And all arguments that where not connected to a class parameter in the family declaration must be variables; i.e., cannot be used as type indexes.
 * In an export and import list we currently cannot explicitly list ATs in brackets after the class name (as all upper case names in such brackets are read as data constructors, not type constructors).
 * Instances of indexed data and new types may not overlap (as such instances correspond to indeterminate type functions).  Type equations may only overlap if the equations coincide at critical pairs.  (Rational: We cannot be more lazy about checking overlap, as we otherwise cannot guarantee that we generate an F,,C,, program that fulfils the formal consistency criterion.)
 * To enable indexed type families, the switch `-findexed-types` needs to be used (which is implied by `-fglasgow-exts`).

Restrictions:
 * We currently don't allow indexed GADTs. I cannot see any fundamental problem in supporting them, but I want to keep it simple for the moment. (When allowing this, a constructor signature in an associated GADT can of course only refine the instantiation of the type arguments specific to the instance in which the constructor is defined.)


== Terminology ==

'''Parametric type constructors''': Type constructors in vanilla Haskell.

'''Indexed type constructors''': Type constructors that are defined via one or more type declarations that have non-variable parameters.  We often call them sloppily just ''indexed types''.  We informally call constructors that are not indexed ''vanilla'' constructors.

'''Kind signature''': Declaration of the name, kind, and arity of an indexed type constructor.  The ''arity'' is the number of type indexes - ''not'' the overall number of parameters - of an indexed type constructor.

'''Type function''': An indexed type synonym.

'''Indexed data type''': An indexed type constructor declared with `data` or `newtype`.

'''Associated type''': An indexed type that is declared in a type class.

'''Type family''': Indexed types can be regarded as families of types; especially in the case of indexed data types, we call each declaration at a particular type index as ''member'' or ''element'' of that family.

'''Definitions vs. declarations''': We sometimes call the kind signature of an indexed constructor its ''declaration'' and the subsequent population of the type family by type equations or indexed data/newtype declarations the constructor's ''definition''.


== How It Works ==

The details of the implementation are split over a couple of subpages, due to the amount of the material:
 * [wiki:TypeFunctionsSyntax syntax and representation,]
 * [wiki:TypeFunctionsRenaming renaming,]
 * [wiki:TypeFunctionsTypeChecking type checking,]
 * [wiki:TypeFunctionsCore desugaring,] and
 * [wiki:TypeFunctionsIface interfaces.]
 

== Possible Extensions ==

 * Our type-indexed data types are open.  However, we currently don't allow case expressions mixing constructors from different indexes.  We could do that if we had a story for open function definitions outside of classes.