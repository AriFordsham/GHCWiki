This page discusses the interaction of Trees That Grow with derived for `Data`.  (But it might apply to manual instances for, say, `Outputable` too.)

Here's our example:
{{{
  type family XOverLit p
  data HsOverLit p = OverLit (XOverLit p) (HsExpr p)

  data GhcPass (c :: Pass)
  data Pass = Parsed | Renamed | Typechecked

}}}
We want a `Data` instance for this type.

=== PLAN A ===

I propose
{{{
  deriving instance (Data (XOverLit (GhcPass p)))
                 => Data (OverLit (GhcPass p)) where…
}}}
But that gives rise to big constraint sets; for each data constructor
we get another `X` field, and another constraint in the `Data` instance.


=== PLAN B ===

Alan proposes propose three instances:
{{{
  deriving instance Data (OverLit (GhcPass Parsed)) where…
  deriving instance Data (OverLit (GhcPass Renamed)) where…
  deriving instance Data (OverLit (GhcPass Typechecked)) where…
}}}
That is: instead of one `Data` instance for the `HsSyn` traversals,
make three.

But Alan discovered that you need a totally weird (constant!) constraint to “make it compile”
{{{
   deriving instance Data (GhcPass Parsed)
                  => Data (Experiment (GhcPass Parsed))
}}}
That's bizarre. The argument `p` to `HsOverLit` is a type index: there are no ''values'' of that type. So why should you need `Data (GhcPass Parsed)`?

(Moreover, you should never need a ''constant'' constraint in an instance context! Instead of adding it to thei nstance declartion, just add `deriving( Data )` to the definition of `GhcPass`.)

The error message actually comes from (the derived code for) the method for `dataCast1`
{{{
 instance Data (Experiment (GhcPass Parsed)) where
     ...
     dataCast1 f = gcast1 f

-- Reminder:
--   gcast1 :: forall c t t' a. (Typeable t, Typeable t')
--       => c (t a) -> Maybe (c (t' a))
--
--   class Data a where
--       dataCast1 :: Typeable t
--            => (forall d. Data d => c (t d))
--            -> Maybe (c a)
}}}
The `Data (GhcPass Parsed)` constraint arises from the call of `f` in the method for
`dataCast1`.

Now I have totally forgotten how `dataCast1` is supposed to work (see Section 7.3 of [https://www.microsoft.com/en-us/research/publication/scrap-more-boilerplate-reflection-zips-and-generalised-casts the paper]).  But it does seem to be to do with polymoprhic function extension, and we would not expect to do that on a type-indexed data type (rather than a container).  So we should really have
{{{
 instance Data (Experiment (GhcPass Parsed)) where
     ...
     dataCast1 f = Nothing
}}}
and then I think all will be well.  Sadly `deriving` doesn't generate that.

=== PLAN C ===

It is still painful generating three virtually identical chunks of traversal code.
So suppose we went back to
{{{
  deriving instance (...)
                 => Data (OverLit (GhcPass p)) where…
}}}
We'd get unresolved constraints like `Data (XOverLit (GhcPass p))`.  Perhaps we
could resolve them like this
{{{
  instance Data (XOverLIt (GhcPass p)) where
     gmapM f x = x
     ...etc...
}}}
That is: a no-op `Data` instances.  Traversals would not traverse extension fields.
That might not be so bad, for now!

=== PLAN D ===

If there were cases when we really did want to look at those extension fields,
we still could, by doing a runtime test, like this:
{{{
  instance IsGhcPass p => Data (XOverLIt (GhcPass p)) where
     gmapM = case ghcPass @p of
                IsParsed -> gmapM
                IsRenamed -> gmapM
                IsTypechecked -> gmapM
     ...etc...
}}}
Here I'm positing a new class and GADT:
{{{
class IsGhcPass p where
  ghcPass :: IsGhcPassT p

data IsGhcPassT p where
  IsParsed      :: IsGhcPass Parsed
  IsRenamed     :: IsGhcPass Renamed
  IsTypechecked :: IsGhcPass Typechecked

instance IsGhcPass Parsed where
  ghcPass = IsParsed
...etc...
}}}
Now, instead of passing lots of functions, we just pass a single GADT value
which we can dispatch on.

We can mix Plan C and D.

