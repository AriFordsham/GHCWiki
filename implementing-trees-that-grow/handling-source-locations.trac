= Handling of Source Locations in Trees that Grow =

== Problem ==

The current design of [https://ghc.haskell.org/trac/ghc/wiki/ImplementingTreesThatGrow/TreesThatGrowGuidance TTG HsSyn AST] in GHC stores source locations for terms of a datatype `Exp` in a separate wrapper datatype `LExp` which is mutually recursive with `Exp` such that every recursive reference to `Exp` is done **indirectly**, via a reference to the wrapper datatype `LExp` (see the example code below). We refer to this style of storing source locations as the ping-pong style.

Besides the indirection and the resulting complications of the ping-pong style, there are two key problems with it: 

a. It bakes-in the source locations in the base TTG AST, forcing all instances to store source locations, even if they don't need them.
   For example, TH AST does not carry source locations. 

b. It results in a form of conceptual redundancy: source locations are tree decorations and they belong in the extension points.
   (see [https://ghc.haskell.org/trac/ghc/wiki/ImplementingTreesThatGrow/TreesThatGrowGuidance TTG Guidance])

=== Example ===
For example, here is a simple [https://ghc.haskell.org/trac/ghc/wiki/ImplementingTreesThatGrow/TreesThatGrowGuidance TTG] representation of lambda expressions in the ping-pong style.
{{{#!hs
{-# OPTIONS_GHC -Wall
                -fno-warn-unticked-promoted-constructors
#-}
{-# LANGUAGE TypeFamilies
           , DataKinds
#-}
module Original where

import Data.Void

data RdrName
-- = the definition of RdrName
data Name
-- = the definition of Name
data Id
-- = the definition of Id
data SrcSpan
-- = the definition of SrcSpan
data Type
-- = the definition of SrcSpan
data UnboundVar
-- = the definition of UnboundVar
noLoc :: SrcSpan
noLoc = undefined -- or be an empty SrcSpan

-- ----------------------------------------------
-- AST Base
-- ----------------------------------------------
data Located a = L SrcSpan a

type LExp x = Located (Exp x)

data Exp x
  = Var (XVar x) (XId x)
  | Abs (XAbs x) (XId x) (LExp x)
  | App (XApp x) (LExp x) (LExp x)
  | Par (XPar x) (LExp x)
  | New (XNew x)

type family XVar x
type family XAbs x
type family XApp x
type family XPar x
type family XNew x

type family XId  x

-- ----------------------------------------------
-- GHC-Specific Decorations
-- ----------------------------------------------
data Phase = Ps | Rn | Tc
data GHC (p :: Phase)

type instance XVar (GHC _)  = ()

type instance XAbs (GHC _)  = ()

type instance XApp (GHC Ps) = ()
type instance XApp (GHC Rn) = ()
type instance XApp (GHC Tc) = Type

type instance XPar (GHC _)  = ()

type instance XNew (GHC Ps) = Void
type instance XNew (GHC Rn) = UnboundVar
type instance XNew (GHC Tc) = UnboundVar

type instance XId  (GHC Ps) = RdrName
type instance XId  (GHC Rn) = Name
type instance XId  (GHC Tc) = Id

type ExpPs  = Exp  (GHC Ps)
type ExpRn  = Exp  (GHC Rn)
type ExpTc  = Exp  (GHC Tc)

type LExpPs = LExp (GHC Ps)
type LExpRn = LExp (GHC Rn)
type LExpTc = LExp (GHC Tc)

-- ----------------------------------------------
-- Example Function
-- ----------------------------------------------
par :: LExp (GHC x) -> LExp (GHC x)
par l@(L sp (App{})) = L sp (Par () l)
par l                = l
}}}

== Solutions ==

The key solution is to move source locations to the extension points, remove the indirection (e.g., the wrapper datatype `LExp`) altogether, and update the related code (e.g., functions over `Exp`) accordingly. 
There are a couple of ways to implement such a solution:

a. Using a typeclass to set/get source locations
   '''SLPJ''': Explain `ForallX`.  I hate it because it implies that we'll pass massive dictionaries around; and what happens if we have lots of different data types, not just one?
 

b. We can nest extension typefamilies to be able to say that all constructors have the same uniform decorations (e.g., `SrcSpan`) beside their specific ones. This is just for convenience as `ForallX*` constraint quantifications can simulate the same (see the code for solution A).

  '''SLPJ''' It's more than just convenience; it's much more elegant than passing these huge dictionaries.  Show the code; something like
  {{{#!hs
  type instance XVar (Ghc p) = Located (XVarGhc p)
  type family XVarGhc p where
    XVarGhc Ps = ()
    XVarGhc Rn = ...
    XVarGhc Tc = ..
  }}}
  It's quite nice that we get a ''closed'' type family for the GHC extensions. Now a typical function might look like
  {{{#!hs
  getLoc :: Located x -> SrcSpan   -- As now

  rnExpr (Var exts id) = setSrcSpan (getLoc exts) $
                         do { ... }
  }}}
  ...etc...

c. We can extend (using TTG) each datatype to add a wrapper *constructor*, similar in spirit to the current `Located`.

d. The API Annotations are similar to the `SrcSpan`, in that they are additional decorations, and also currently appear wherever there is a `SrcSpan`.

e. We also currently have sections of AST without source locations, such as those generated when converting TH AST to hsSyn AST, or for GHC derived code.

   We can perhaps deal with these by either defining an additional pass, so

   {{{#!hs
   data Pass = Parsed | Renamed | Typechecked | Generated
      deriving (Data)
   }}}

   or by making the extra information status dependent on an additional parameter, so

   {{{#!hs
   data GhcPass (l :: Location) (c :: Pass)
   deriving instance Eq (GhcPass c)
   deriving instance (Typeable l,Typeable c) => Data (GhcPass l c)

   data Pass = Parsed | Renamed | Typechecked
     deriving (Data)

   data Location = Located | UnLocated
   }}}

   Thanks to Zubin Duggal for bringing the unlocated problem up on IRC.

f. TODO (add your suggestions)

=== Solution A - Example Code ===
In the code below, as compared to the original one above, we have the following key changes:

* `LExp` is replaced with `Exp`
* field extensions are set to have a `SrcSpan` (instead of `()`)
* a setter/getter typeclass `HasSpan` (and instances) is introduced
* a pattern synonym for `L` is introduced using the typeclass

{{{#!hs
{-# OPTIONS_GHC -Wall
                -fno-warn-unticked-promoted-constructors
#-}
{-# LANGUAGE TypeFamilies
           , DataKinds
           , ConstraintKinds
           , FlexibleInstances
           , FlexibleContexts
           , UndecidableInstances
           , PatternSynonyms
           , ViewPatterns
#-}
module SolutionA where

import GHC.Exts (Constraint)
import Data.Void

data RdrName
-- = the definition of RdrName
data Name
-- = the definition of Name
data Id
-- = the definition of Id
data SrcSpan
-- = the definition of SrcSpan
data Type
-- = the definition of SrcSpan
data UnboundVar
-- = the definition of UnboundVar
noLoc :: SrcSpan
noLoc = undefined -- or be an empty SrcSpan

-- ----------------------------------------------
-- AST Base
-- ----------------------------------------------
data Exp x
  = Var (XVar x) (XId x)
  | Abs (XAbs x) (XId x) (Exp x)
  | App (XApp x) (Exp x) (Exp x)
  | Par (XPar x) (Exp x)
  | New (XNew x)

type family XVar x
type family XAbs x
type family XApp x
type family XPar x
type family XNew x

type family XId  x

-- ----------------------------------------------
-- GHC-Specific Decorations
-- ----------------------------------------------
data Phase = Ps | Rn | Tc
data GHC (p :: Phase)

type instance XVar (GHC _)  = SrcSpan

type instance XAbs (GHC _)  = SrcSpan

type instance XApp (GHC Ps) = SrcSpan
type instance XApp (GHC Rn) = SrcSpan
type instance XApp (GHC Tc) = (SrcSpan , Type)

type instance XPar (GHC _)  = SrcSpan

type instance XNew (GHC Ps) = Void
type instance XNew (GHC Rn) = (SrcSpan , UnboundVar)
type instance XNew (GHC Tc) = (SrcSpan , UnboundVar)

type instance XId  (GHC Ps) = RdrName
type instance XId  (GHC Rn) = Name
type instance XId  (GHC Tc) = Id

type ExpPs  = Exp  (GHC Ps)
type ExpRn  = Exp  (GHC Rn)
type ExpTc  = Exp  (GHC Tc)

-- ----------------------------------------------
-- HasSpan Typeclass and L Pattern Synonym
-- ----------------------------------------------
class HasSpan a where
  getSpan :: a -> SrcSpan
  setSpan :: a -> SrcSpan -> a

instance HasSpan SrcSpan where
  getSpan   = id
  setSpan _ = id

instance HasSpan Void where
  getSpan x   = absurd x
  setSpan x _ = absurd x

type ForallX (p :: * -> Constraint) x
  = ( p (XVar x)
    , p (XAbs x)
    , p (XApp x)
    , p (XPar x)
    , p (XNew x)
    )

instance ForallX HasSpan x => HasSpan (Exp x) where
  getSpan (Var ex _)      = getSpan ex
  getSpan (Abs ex _ _)    = getSpan ex
  getSpan (App ex _ _)    = getSpan ex
  getSpan (Par ex _)      = getSpan ex
  getSpan (New ex)        = getSpan ex

  setSpan (Var ex x)   sp = Var (setSpan ex sp) x
  setSpan (Abs ex x n) sp = Abs (setSpan ex sp) x n
  setSpan (App ex l m) sp = App (setSpan ex sp) l m
  setSpan (Par ex m)   sp = Par (setSpan ex sp) m
  setSpan (New ex)     sp = New (setSpan ex sp)

getSpan' :: HasSpan a => a -> (SrcSpan , a)
getSpan' m = (getSpan m , m)

pattern L :: HasSpan a => SrcSpan -> a -> a
pattern L s m <- (getSpan' -> (s , m))
  where
        L s m =  setSpan m s

-- ----------------------------------------------
-- Example Function
-- ----------------------------------------------
par :: ForallX HasSpan (GHC p) => Exp (GHC p) -> Exp (GHC p)
par l@(L sp (App{})) = L sp (Par noLoc l)
par l                = l
}}}

=== Solution B - Example Code ===
In the code below, as compared to the original one above, we have the following key changes:

* `LExp` is replaced with `Exp`
* field extensions are set to have a `SrcSpan` paired with a closed type family specialised for GHC phases
* a setter/getter function pair is introduced
* a pattern synonym for `L` is introduced using the setter/getter function


{{{#!hs
{-# OPTIONS_GHC -Wall
                -fno-warn-unticked-promoted-constructors
#-}
{-# LANGUAGE TypeFamilies
           , ConstraintKinds
           , ViewPatterns
           , PatternSynonyms
           , DataKinds
           , FlexibleInstances
#-}
module SolutionB where

import Data.Void

data RdrName
-- = the definition of RdrName
data Name
-- = the definition of Name
data Id
-- = the definition of Id
data SrcSpan
-- = the definition of SrcSpan
data Type
-- = the definition of SrcSpan
data UnboundVar
-- = the definition of UnboundVar
noLoc :: SrcSpan
noLoc = undefined -- or be an empty SrcSpan

-- ----------------------------------------------
-- AST Base
-- ----------------------------------------------
data Exp x
  = Var (XVar x) (XId x)
  | Abs (XAbs x) (XId x) (Exp x)
  | App (XApp x) (Exp x) (Exp x)
  | Par (XPar x) (Exp x)
  | New (XNew x)

type family XVar x
type family XAbs x
type family XApp x
type family XPar x
type family XNew x

type family XId  x

-- ----------------------------------------------
-- GHC-Specific Decorations
-- ----------------------------------------------
data Phase = Ps | Rn | Tc
data GHC (p :: Phase)

type instance XVar (GHC p) = (SrcSpan , XVarGHC p)
type instance XAbs (GHC p) = (SrcSpan , XAbsGHC p)
type instance XApp (GHC p) = (SrcSpan , XAppGHC p)
type instance XPar (GHC p) = (SrcSpan , XParGHC p)
type instance XNew (GHC p) = (SrcSpan , XNewGHC p)

type instance XId  (GHC p) = XIdGHC p


type family XVarGHC (p :: Phase) where
  XVarGHC _  = ()

type family XAbsGHC (p :: Phase) where
  XAbsGHC _  = ()

type family XAppGHC (p :: Phase) where
  XAppGHC Ps = ()
  XAppGHC Rn = ()
  XAppGHC Tc = Type

type family XParGHC (p :: Phase) where
  XParGHC _  = ()

type family XNewGHC (p :: Phase) where
  XNewGHC Ps = Void
  XNewGHC _  = UnboundVar

type family XIdGHC (p :: Phase) where
  XIdGHC Ps = RdrName
  XIdGHC Rn = Name
  XIdGHC Tc = Id

type ExpPs = Exp (GHC Ps)
type ExpRn = Exp (GHC Rn)
type ExpTc = Exp (GHC Tc)

-- ----------------------------------------------
-- getter/setter of Span
--  (similar to methods of HasSpan)
-- ----------------------------------------------
class HasSpan a where
  getSpan :: a -> SrcSpan
  setSpan :: a -> SrcSpan -> a

instance HasSpan SrcSpan where
  getSpan   = id
  setSpan _ = id

instance HasSpan Void where
  getSpan x   = absurd x
  setSpan x _ = absurd x

instance HasSpan (Exp (GHC p)) where
  getSpan (Var ex _)      = fst ex
  getSpan (Abs ex _ _)    = fst ex
  getSpan (App ex _ _)    = fst ex
  getSpan (Par ex _)      = fst ex
  getSpan (New ex)        = fst ex

  setSpan (Var ex x)   sp = Var (setFst ex sp) x
  setSpan (Abs ex x n) sp = Abs (setFst ex sp) x n
  setSpan (App ex l m) sp = App (setFst ex sp) l m
  setSpan (Par ex m)   sp = Par (setFst ex sp) m
  setSpan (New ex)     sp = New (setFst ex sp)

setFst :: (a , b) -> a -> (a , b)
setFst (_ , b) a' = (a' , b)

getSpan' :: HasSpan a => a -> (SrcSpan , a)
getSpan' m = (getSpan m , m)

pattern L :: HasSpan a => SrcSpan -> a -> a
pattern L s m <- (getSpan' -> (s , m))
  where
        L s m =  setSpan m s

-- ----------------------------------------------
-- Example Function
-- ----------------------------------------------
par :: Exp (GHC p) -> Exp (GHC p)
par l@(L sp (App{})) = L sp (Par (noLoc, ()) l)
par l                = l
}}}


=== Solution C - Example Code ===
In the code below, as compared to the original one above, we have the following key changes:

* `LExp` is replaced with `Exp`
* a new constructor extension is introduced to wrap `ExpPs` with a `SrcSpan` 
* a pattern synonym for `L` is introduced

{{{#!hs
{-# OPTIONS_GHC -Wall
                -fno-warn-unticked-promoted-constructors
#-}
{-# LANGUAGE TypeFamilies
           , DataKinds
           , ConstraintKinds
           , PatternSynonyms
#-}
module SolutionC where

import Data.Void

data RdrName
-- = the definition of RdrName
data Name
-- = the definition of Name
data Id
-- = the definition of Id
data SrcSpan
-- = the definition of SrcSpan
data Type
-- = the definition of SrcSpan
data UnboundVar
-- = the definition of UnboundVar
noLoc :: SrcSpan
noLoc = undefined -- or be an empty SrcSpan

-- ----------------------------------------------
-- AST Base
-- ----------------------------------------------
data Exp x
  = Var (XVar x) (XId x)
  | Abs (XAbs x) (XId x) (Exp x)
  | App (XApp x) (Exp x) (Exp x)
  | Par (XPar x) (Exp x)
  | New (XNew x)

type family XVar x
type family XAbs x
type family XApp x
type family XPar x
type family XNew x

type family XId  x

-- ----------------------------------------------
-- GHC-Specific Decorations
-- ----------------------------------------------
data Phase = Ps | Rn | Tc
data GHC (p :: Phase)

type instance XVar (GHC _)  = ()

type instance XAbs (GHC _)  = ()

type instance XApp (GHC Ps) = ()
type instance XApp (GHC Rn) = ()
type instance XApp (GHC Tc) = Type

type instance XPar (GHC _)  = ()

type instance XNew (GHC p)  = Either (SrcSpan , Exp (GHC p))
                                     (XNewGHC p)

type family XNewGHC (p :: Phase) where
  XNewGHC Ps = Void
  XNewGHC Rn = UnboundVar
  XNewGHC Tc = UnboundVar

type instance XId  (GHC Ps) = RdrName
type instance XId  (GHC Rn) = Name
type instance XId  (GHC Tc) = Id

type ExpPs  = Exp  (GHC Ps)
type ExpRn  = Exp  (GHC Rn)
type ExpTc  = Exp  (GHC Tc)

-- ----------------------------------------------
-- L Pattern Synonym
-- ----------------------------------------------
pattern L :: SrcSpan -> Exp (GHC p) -> Exp (GHC p)
pattern L sp m = New (Left (sp , m))

-- ----------------------------------------------
-- Example Function
-- ----------------------------------------------
par :: Exp (GHC p) -> Exp (GHC p)
par l@(L sp (App{})) = L sp (Par () l)
par l                = l
}}}

