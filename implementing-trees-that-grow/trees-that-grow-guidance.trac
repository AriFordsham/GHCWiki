= Trees that Grow Guidance =
[http://www.jucs.org/jucs_23_1/trees_that_grow/jucs_23_01_0042_0062_najd.pdf The Trees that Grow (TTG) idiom] can be used to provide different forms of extensions and variations on an AST. Since April 2018, the HsSyn AST inside GHC supports the TTG idiom. This page provides a set of guiding principles for GHC developers on how to understand and use the TTG idiom in HsSyn.

== Context and Scope == 
The new HsSyn AST supporting the TTG idiom (from now on referred to as TTG HsSyn) is engineered to subsume five different representations of Haskell syntax: 

* AST GhcPs: the AST used in GHC's parsing phase
* AST GhcRn: the AST used in GHC's renaming phase
* AST GhcTc: the AST used in GHC's typechecking phase
* AST TH:    the AST used in Template Haskell
* AST HSE:   the AST used in an external tool such as Haskell-Src-Exts

The subsumption of above five ASTs is done by providing instances for the extension type families.
For instance, the AST for GHC's parsing, renaming, and typechecking are defined by providing instances of the extension type families using accordingly the indices `GhcPs`, `GhcRn`, and `GhcTc`.
[https://github.com/ghc/ghc/blob/master/compiler/hsSyn/HsExpr.hs#L737-L835 Here] is the actual code providing such instances for the `HsExpr` datatype of expressions in the TTG HsSyn.
 

Subsuming above five trees fixes the scope of the design space. For example, TTG HsSyn is not intended to subsume the AST in the GHC's backend (i.e., GHC Core), but it can indeed be used for other purposes like prettyprinting and IDEs.

  
== Guiding Principles == 

a. The instantiation of TTG HsSyn should result in a tree that does not have extra fields and constructors. 
   
   For example, the `HsExpr GhsPs` expressions of AST GhcPs should not have the constructor `HsUnboundVar` of the post-renaming phases, or its `HsMultiIf` constructor should also not have an unused field (of the type `Type`) to store the related type produced in the typechecking phase.

   As a result, the instantiated TTG HsSyn should not depend on the code from the other phases. Hence, the base (uninstantiated) TTG HsSyn should not depend on any GHC/TH/HSE-specific code.

   For example, if `HsExpr GhsPs` expressions of AST GhcPs had the constructor `HsUnboundVar` then it had to depend on the code defining `UnboundVar` (a field of `HsUnboundVar`) in the renaming phase, or if its constructor `MultiIf` had a field of type `Type` then it had to depend on the code defining `Type` in the typechecking phase.
    
   
b. The base TTG HsSyn should have all the constructors common across all five ASTs, and these constructors should have all the fields common across all five ASTs (even if the type of some fields vary from an AST to another).
   
   SPJ refers to these common fields as "payload fields" (as opposed to extension fields). 

c. The constructors that are not common are introduced using TTG's new constructor extensions.

d. For common constructors, their fields that are not common are grouped together and introduced using TTG's new field extensions.

e. For common constructors, their common fields with a varying type, are given a type using a new type family that extracts from the phase descriptor the type specific to each AST.

   For example, the type of the common (payload) field of the common constructor `HsVar`of `HsExpr x` is `IdP x` where `IdP` is a type family and `x` the phase descriptor. 



