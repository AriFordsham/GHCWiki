= Kind inference examples

This page is intended to collect examples of tricky cases for kind inference. Any proposed algorithm should be applied to each of these cases to see how it would behave.

More discussion is at GhcKinds/KindInference.

== Associated types

{{{#!hs
class C1 (a :: k) where
  type F a
}}}

Question: What should the visibilities on `F` be?

Ryan and Richard think `F :: forall k. k -> Type`. That is, `k` is Specified, because we can always order implicit kind variables using the same ordering that appears in the class header (after kind inference).

{{{#!hs
class C2 (a :: k) (b :: k2) where
  type T a
}}}

Proposed: `T :: forall k. k -> Type`, with no mention of `b` or `k2`.

{{{#!hs
class C3 (a :: k) (b :: k2) hwere
  type T (z :: k3) a
}}}

Proposed: `T :: forall k k3. k3 -> k -> Type`. This puts `k` ''before'' `k3`, because class variables come before other ones (unless the user explicitly puts them later, as has been done with `a`). This rule always works because class variables cannot depend on local ones.

{{{#!hs
class C4 a (b :: a) where
  type T b a
}}}

This must be rejected, as `b` depends on `a`.

{{{#!hs
class C5 (a :: k) where
  type T (a :: k2)
}}}

Reject: `k` and `k2` are distinct skolems.

{{{#!hs
class C6 a (b :: a) (c :: Proxy b) where
  type T (x :: Proxy '(a, c))
}}}

Proposed: `T :: forall (a :: Type) (b :: a) (c :: Proxy b). Proxy '(a, c) -> Type`. Note that `b` is included here as a Specified variable. It could also be an Inferred, if we prefer.

{{{#!hs
class C7 a (b :: a) (c :: Proxy b) where
  type T a c
}}}

Proposed: `T :: forall (a :: Type) -> forall (b :: a). Proxy b -> Type`. We've inserted `b` between `a` and `c`, but `b` is Specified, not Required. Other possibilities: make `b` Inferred, or reject altogether.