= This page collects tickets that Simon PJ is interested in, so that he remembers them =

== Urgent or in-flight ==
 * #7262, #10333, #7672, #10083: hs-boot niggles
 * #10114: `AnyK` and kind generalisation in type synonyms
 * #10285: a small bug in `Coercible` (Richard)
 * #10087: typechecking generic default methods (Pedro)
 * #10068: runtime reflection API for modules, names.
 * #10045: partial type sig bug (Thomas W is working on this)
 * #9960, #9805: `TrieMap` stuff
 * #10016: UNPACK support for existentials
 * #9260: type lits (Iavor owns)
 * #9793, #8761, #8581, #8779, #8761, #8583, #9911, #7736, #8582, #10339: pattern synonyms (Gergo)
 * #8634, #9267, #9227: relaxing functional dependency rules `-XDysFunctionalDependencies`
 * #9123: higher order roles
 * #9352: allow `State#` in FFI types.
 * #9637: type-level "error" function
 * #9725: kind equalities (Richard)
 * #9717, #9729: orphan modules

== Performance (compile time or runtime) ==
 * #8852, #8980, #8941 (possibly), #9803, #8960, #7898, #7068, #7944, #5550, #8836: `SpecConstr` blowup
 * #10108: 3600x slowdown with -O2
 * #10289: 2.5k static `HashSet` takes too much memory to compile
 * #9669: slow compilation with lots of `deriving` clauses
 * #9583, #9630: code blowup in Generics/Binary
 * #10293: too much time in `CallArity` (Joachim) * #10228: regression from 7.8.4 to 7.10.1
 * #7450, #7258: deriving `Read` generates gigantic code. Better now, but still not linear.
 * #7428: Non-linear compile time: `addFingerprint`??
 * #2346: desugaring let-bindings
 * Use wildcards for dead variables in interface files.

== Front end ==

 * #10321: normalising a type in `:type` in GHCi
 * #10318: recursive superclasses
 * #10183: warning for redundant constraints, and pattern-match overlap warnings
 * #10179: displaying kinds
 * #10089: better warnings for unused data types (involves instances)
 * #8581: bidirectional pattern synonyms (with different constraints)
 * #10027: export behaviour for data families
 * #9223: error message mentioning untouchables
 * #9198: slow typechecker (big types!)
 * #9210, #9103: functional dependencies and overlapping instances
 * #8673: more generous GADT record selectors
 * #8550: Don't build recursive type-function dictionaries
 * #8281: `UnliftedFFITypes` etc
 * #8441: family instances in hs-boot files
 * #9450: need more eager checking of compatibility with hs-boot files
 * #8095: very slow constraint solving
 * #8171: extended default rules
 * #7259: Eta-expansion of products in System FC
 * #5642: slow constraint solving
 * #7828, #5267, #5777, #5333, #344: bugs in arrows
 * #7204: a class to controll FFI marshalling; and newtype deriving for classes with ATs
 * #7862: overlap beween givens and instances
 * #7842: polymorphism in recursive do-blocks

== Type families, roles, `Coercible`, `Typeable`, kind polymorphism ==
 
 * #9858, #10343: `Typeable` and kind polymorphism
 * #10347: wrong "unused data constructor" warning for a newtype (using `Coercible`)
 * #10184,#10185: incompleteness in `Coercible` solver
 * #8165: GND for classes with associated types
 * #10075: `Constraint` vs `*`
 * #10056: more systematic treatment of `(~)` in parser and renamer 
 * #9918: closed type families, apartness, and overlapping instances (inconsistency)
 * #9118: Eta reduction for `Coercible` (not expressible in Core, yet)
 * #6018, #10227: injective type families
 * #8161: associated type more specific than class decl
 * #8177: role signature for type families

== Template Haskell ==
See also [wiki:TemplateHaskell]

 * #10279: `reifyPackage`
 * #10330: better TH error locations
 * #6089: nested declaration splices
 * #10271: difficulty resolving overloading in typed TH
 * #9113: pattern match overlap/exhaustiveness checked in Typed TH
 * [wiki:TemplateHaskell/Annotations] Gergely's work on annotations in TH
 * #1475: allow splicing of import declarations (5 in cc list)


== Demand analysis and CSE == 
 * #7782: late demand analysis
 * #10069: bad reboxing in data types with many fields
 * #8655: analysis for quick-to-evaluate thunks
 * #6070, #5949, #5775, #4267, #5302, #6087: Demand analysis
 * #5075, #3138: CPR for sum types (mostly done, needs finishing)
 * #2289, #2387, #1600, #1885: nested CPR analysis
 * #7596, #5996, #149, #2940, #947, #701, #5344, #9441: CSE opportunities; see [wiki:MoreCSE]
 * #6040, #5945, #3458, #1216: lambda-lift functions with a few args, just before code gen
 * #1171: strictness and exceptions (long, open ticket)

=== Arity ===
 * #9388: narrow the state hack
 * #10260, #9020, #10319: not enough eta expansion
 * #7542: optimisation of eta expansion/reduction
 * #5809: arity analysis could be better
 * #3924: weak arity leads to weak strictness
 * #3698: arity analysis again
 * #3697: class method selectors
 * #3034: divInt and arity
 * #2915: arity too small
 * #2823: another arity expansion bug (related to dictionaries)
 * #2440: bad code with type families; I believe this is also arity-related
 * #1547: profiling and arity
 * #5587, #7364: eta-expansion can imcrease termination.  These tickets are closed because we don't know how to fix them properly, not becuase they are really fixed.

=== Inlining ===
 * #4833: finding the right loop breaker
 * #3781, #3755: inlining for local functions: discount for scrutinising free vars
 * #3765: CONLIKE things and case expressions (need two unfoldings)
 * #3073 and [wiki:Commentary/Compiler/DesugaringInstances]: better desugaring for instances
 * #3123: feature request: recursive inlining and peeling
 * #4960: better inlining tests

== Optimisation ==
 * #9370: respecting mixed `-O` and `-O0` in `ghc --make`, especially concerning cross-module inlining
 * #9279: local wrapper remains in final program
 * #9246: Too much case-of-case leads to bad code
 * #8613, #9070, #8319: simplifier ticks exhausted (there are others)
 * #9136: better constant folding
 * #9041: bad code from native code generator (NCG)
 * #6056: conflict between the w/w unfolding and the one from INLINEABLE
 * #8472: top level unlifted string literals
 * #8335: more gc entry points
 * #8336: sinking pass does not sink
 * #8327: dead code (in heap checks) not eliminated by C--
 * #8317, #8326, #9661: don't push heapchecks into case branches too aggressively.  This is closely related to work Jan Stolarek did on unboxed booleans #6135; and perhaps also to #10124, #10137
 * #8308: resurrect ticky histograms
 * #8321: branch prediction for stack/heap checks for LLVM
 * #8279: alignment and its effect on performance
 * #1498: heap checks in recursive functions
 * #7367: float-out causes extra allocation
 * #7378: (a) identical-alts when the RHSs are bigger; (b) nested comparisions (cf #2132)
 * #7511: inlining can make programs allocate MORE!!
 * #7307: low hanging fruit for shrinking code size for string constants and top-level indirections
 * #7206, #7309: avoid excessive sharing of enumerations
 * #8833, #3872, #5400, #5448, #5722, #7057, #7369, #9235: contravariant data type loop in simplifier inliner
 * #5954: performance regression. Duplication of primops?
 * #6047: GHC retains unnecessary binding
 * #2439: Strict dictionaries; see also map/coerce rule #9792
 * #5916: `runST` isn't free
 * #5522, #6092: liberate-case runs out of memory
 * #3990, #7647: UNPACK for data families, and with phantom types, needs data con wrapper refactoring; see also #9655 if you are in this area.
 * #5928: running Specialise more than once

== Numerics, floating point, and primops ==
 * #9407: 64-bit floating point behaves differently with and without -O
 * #5780: aggressive-primop attempt that didn't quite work
 * #9328, #10215: negative zero and case expressions
 * #9304: floating point woes: 32 vs 64 bit
 * #5615: poor code for div with powers of 2
 * #4101: constant folding for `(**)`
 * #3676: `realToFrac` conversions
 * #3744: comparisons against `minBound` and `maxBound` are not optimised away
 * #2269: Word type to Double or Float conversions 
 * #3070: !NaNs and divide-by-zero
 * #9251: branchless max/min
 * #9276: auditing for IEEE compliance


== Features ==
 * #9049: explicit call stack, abstractable call site information
 * #5972: option to suppress record selectors

----------------------


== Cmm and code generation ==
 * #10012: Cheap-to-compute values aren't pushed into case branches
 * #9718: avoiding `TidyPgm` having to predict arity and CAF-ref-ness
 * #9159: jump tables for dense cases
 * #9157: common block elimination
 * #8905: spilling around an eval
 * #8903: dead stores
 * #8887: double assignment
 * #8871: Cmm optimisation opportunity
 * #8585: loopification
 * Summary ticket: #4258, and [wiki:Commentary/Compiler/NewCodeGen wiki page]
 * #3462: allocate large objects with `allocateLocal()`
 * #2289: cheap check at start of case alternatives
 * #2731: avoiding unnecessary evaluation when unpacking constructors
 * #4121: arity and CAF info computation is horribly fragile

=== Optimiser ===
 * #10346, #2255, #3767, #2642, #3831, #4941, #2598: Improve '''`SpecConstr`''' in various ways, including for free variables, and for join points. * #5059: specialise on value arguments
 * #5974: casts, RULES, and parametricity
 * #5262: seq magic
 * #605: strict/unboxed enumerations
 * #2607: space leak: inlining defeats selector thunk optimisation
 * #4470: merge identical counters
 * #2988: better float-in
 * #2374: SAT and `MutableByteArray`	Max?
 * #7080: inconsistent treatment of RULES and SPECIALISE
 * #876: make `length` into a good consumer. Perhaps using `foldl`?

== GHCi ==
 * #9394: Display type/data family instance information in `:info`
 * #4017: unhelpful GHCi message
 
------------------------
== Outright bugs ==

 * #1241: Lifting the Coverage Condition for functional dependencies isn’t the Right Thing	Manuel

------------------------
== Types and type inference ==

 * [wiki:TypeFunctionsStatus]
 * #10338: delicacy in generalisation: `MonoLocalBinds` isn't enough
 * #9637: type level error messages
 * #9587, #9607: `-XAllowAmbiguousTypes` debate
 * #9334: instance chains
 * #9427: SCC analysis for type and class decls
 * #9422: Glomming all instances in EPT is too crude for `--make`
 * #7503: Kind polymorphism and mutual recursion
 * #6018, #4259: Injective type families and type family overlap
 * #4296: !SkolemOccurs
 * #816. #3108: extreme delicacy in solve order, involving fundeps
 * #8109: as-patterns in type-family declarations
 * #6065: GHC suggests a type signature that it then rejects
 * #5320, #7296: overlap delicacy
 * #4281, #4295, #4347, #7264, #8808, #9420, #9730: impredicativity
 * #1965: make existentials have a really cheap implementation
 * #5224: make it cheaper to check for inconsistent type family instances
 * #4466, #5296, #8631: explicit type application
 * #4259: overlapping type family instances
 * #3490: superclasses and ambiguity
 * #3632: better update for records with existentials
 * #2641: revise what `-XExtendedDefaultRules` does

=== Better error messages ===
 * #9901: `f is applied to two arguments, but its type has only two`
 * #9479: more info in "hole" error messages
 * #9456: more info in "relevant bindings" message
 * #9244: suggest scoped type variables
 * #9173: inferred/expected error messages
 * #1330: another bad error message (Church2)
 * #2648: Report out of date interface files robustly	
 * #1928: Confusing type error message (Claus makes suggestions)	

------------------------
== Template Haskell == 
 * Blog post: [http://hackage.haskell.org/trac/ghc/blog/Template%20Haskell%20Proposal]
 * #1012: mutually recursive modules and TH
 * #5959: top level splices and renaming
 * #5416: local modules
 * #4372: better quasiquotation support
 * #2041: Splicing in concrete syntax
 * #1475: Allow TH to generate import declarations	
 * #2340: Better TH error recovery.  Easy to do; change to signature of qRecover.
 * #4222: design of reification for TH

== Features == 
 * #6024: allow defining a ''kind'' without also getting the corresponding ''type''
 * #5927: Constraints with universal quantification
 * #5429: docase and joinads
 * #5073: `blockST` and friends
 * #2895: Class aliases 
 * #2595: record updates
 * #4823: strength reduction for array indexing
 * #4479: type directed name resolution (TDNR)
 * #4426: simpler rule for implicit quantification
 * #10116, #9951, #595, #5728, #3927, #5724, #5762, #4139, #6124, #7669, #322, #8016, #8494, #8853, #8970, #9113, #2204: '''pattern-match overlap checking''', including with GADTs
 * #3701: Implicitly declared existentials: a class as a type
 * #3217: better flag handling for GHCi
 * #2600, #2110: '''Bind type variables and constraints in RULES'''
 * #960: Generate local info for ‘undefined’.  Implicit location parameters in general	
 * #2135: Warn when exporting a function whose type mentions a type constructor defined locally but not itself exported	
 * #2119: Explicitly importing deprecated symbols should generate deprecation warnings	
 * #2207: Load interfaces for GHC.* even without -O	
 * #1231: Better deprecations	

--------------------------
== Not sure what to do about these ==
 * #7897: make the fingerprint in a `TypeRep` be a proper fingerprint, including the type definition all the way down (see [http://hackage.haskell.org/trac/ghc/wiki/DependencyTracking Recompilation avoidance])
 * #2284, #1168, #7561, #9349: the state-hack "optimisation" causes much re-computation
 * #4005: generational GC pathalogical case
 * #1349: strict function argument types
