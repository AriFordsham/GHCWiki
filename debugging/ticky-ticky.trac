

= Ticky-ticky profiling =

Ticky-ticky profiling adds counters to every STG function.  It's very low-level, but it really tells you what is going on:

 * Add the `-ticky` flag when compiling a Haskell module to enable "ticky-ticky" profiling of that module.  This makes GHC emit performance-counting instructions in every STG function.  

 * Add `-ticky` to the command line when linking, so that you link against a version of the runtime system that allows you to display the results.  In fact, in the link phase `-ticky` implies `-debug`, so you get the debug version of the runtime system too.

 * Add `+RTS -rfoo.ticky` to the run-time command line, to put the ticky-ticky profile in the file `foo.ticky`.

You need to use `-ddump-simpl -ddump-prep` when compiling the source files to see the functions that correspond to the performance counter report.

It's very low level stuff, but in exchange:
  * It's guaranteed that adding `-ticky` doesn't affect optimisation or transformation.  It just adds the overhead of performance counters to the final code.

  * You can mix modules compiled with `-ticky` and modules compiled without.

To ''really'' see everything you need to compile all the libraries with `-ticky`.  To do that in a standard build tree, here are some flag settings in `build.mk` that work:
{{{
# Build all libraries with -ticky
GhcLibOpts += -ticky

# Build the RTS in the ticky way
GhcRTSWays += t

# Currently ticky is incompatible with threading
GhcThreaded = NO
}}}
