# Pattern-match checking

## Patches

Those with an MR actually have code.

- !1851: refactoring `PmPat`.

- Clean up `provideEvidenceForEquation`, define `ensureInhabited delta = null <$> provideEvidenceForEquation 1 delta`  
  - Apparently, `provideEvidenceForEquation` currently assumes that every COMPLETE set is inhabited, and thus implicitly assumes that `ensureInhabited` is true for that data type. So we can't actually just re-define on in terms of the other just yet.

- !1765: Preserve non-void constraints  
  - Should not remove inhabitation candidate stuff just yet, newtypes...
  - Perhpas postpone test until get to RHS (pmc []), and then ask for `not (null (provideEvidence 1 delta))`

- `data PmCt = TyCt .. | TmCt ...`; then `addPmCt :: Delta -> PmCt -> DsM Delta`

- ```
  data ClauseCoverage = Redundant | Matched RhsAccessibility
  data RhsAccessibility = RhsInaccessible | RhsAccessable
  data PmClauseResult = PCR { uncovered :: [Delta]
                            , coverage :: ClauseCoverage }
  data PmResult       = PR  { uncovered :: [Delta]
                            , clauses :: [ClauseCoverage] }
  ```
- ```
  newtype Delta = Delta (Bag Theta) deriving (Functor, Foldable, Traversable)
  liftDelta :: Monad m => (Theta-> m (Maybe Theta)) -> Delta -> m Delta
  liftDelta f = fmap catBagsMaybe . traverse f
  ```
  And then define `pmc` in terms of that. `liftDelta` for ops like `addTmCt`.  
    - Also we can finally get rid of `n_siblings` for the throttling function, it's just `length Delta` now

- ```
  data Clause = AtRhs
              | Guard PmGrd Clause
              | Many [Clause]
  pmc :: Clause -> Deltas -> DsM 
  ```

- When we have `Delta = Delta (Bag Theta)`, we can actually use the Covered set as a `Delta` for "long distance info"  
  - No more just positive info and the `computeCovered` duplication can go away
  - Performance-wise, we should be fine with !1752

- Implement "smarter `CoreMap`"
- Test for "N series" (Matching over a binary tree, like the code generated by `-XDeriveGeneric`)

## Issues

- #17270: `Origin` annotations should be consistent about TH  
  - Faintly related: #14838, #14899. Should we warn about TH? Probably guard it behind a flag. Off by default? SG thinks so. This code is generated potentially in another library by a different user. Also compiler performance

## Epics

- Paper  
  - Type-set checking function, commit to syntax for Delta
- Think about how to fix "regression" in T11822  
  - SG bets a smart `CoreMap` would do
- Maybe pattern-match check typed TH quotations? SG doesn't think this is a good idea, because they might not even end up in that form in spliced code.

# Separate CPR

- Wiki page: https://gitlab.haskell.org/ghc/ghc/wikis/nested-cpr/split-off-cpr  
  - Collect proper arguments
  - Include the example from https://gitlab.haskell.org/ghc/ghc/merge_requests/1427#note_214697
- !1427: Splits-off CPR analysis from DmdAnal, but still needs work  
  - Delete CPR stuff from DmdAnal
  - Encode `Arity` in CPR signature
  - Measure compile-time impact

# Nested CPR

- Mostly working prototype at https://gitlab.haskell.org/ghc/ghc/tree/wip/nested-cpr-2019

## Roadblocks 

- Nested CPR of DataCon wrappers needs to look at RHS of wrapper (think of `data T = T !(Int, Int)`) 
- Do nested CPR for KindReps/TypeReps/Modules? Horrendeous signatures in T7360 and T8274, but stats only improve overall
- T9291: unsafePtrEquality checks for STG CSE  
  - `bar x = (Right x, Right x)` gets CPR'd, `$wbar x = (# x, x #)` can't CSE at call site. Fixed testcase with `lazy`, but is that the right thing to do?
- integerConstantFolding: `CONSTANT_FOLDED` on `decodeDoubleInteger`, but gets WW'd because of nested `Int64`
  - We can't really just return the unboxed Int#, because that's platform dependent. BUT we could return Int64# instead
  - Alternatively, inline `decodeIntegerDouble` and recognise the PrimOp, seems like the much saner behavior?!