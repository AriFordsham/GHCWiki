# Pattern-match checking

## Patches

Those with an MR actually have code.

- #17248, #17376, !1975: Get rid of the special case for `-XEmptyCase`. Fix handling of newtypes because of testsuite failures. Some ground work for proper non-void constraint handling.

- #17357: Fix strictness of pattern synonyms. We came to the agreement that it's not worth the trouble and most useful pattern synonyms are strict anyway.

- Clean up `provideEvidenceForEquation`, define `ensureInhabited delta = null <$> provideEvidenceForEquation 1 delta`
  - Apparently, `provideEvidenceForEquation` currently assumes that every COMPLETE set is inhabited, and thus implicitly assumes that `ensureInhabited` is true for that data type. So we can't actually just re-define on in terms of the other just yet.
  - `provideEvidence*` is a strange beast: It tries to provide positive evidence for an equation that can be presented to the user. But at the same time it isn't concerned with testing whether Delta is inhabited at all: In fact it just blindly assumes so (see last point) and preserves that invariant by calling `refineToAltCon`/`addRefutableAltCon`.

- !1765: Preserve non-void constraints  
  - Should not remove inhabitation candidate stuff just yet, newtypes...
  - Perhpas postpone test until get to RHS (pmc []), and then ask for `not (null (provideEvidence 1 delta))`

- `data PmCt = TyCt .. | TmCt ...`; then `addPmCt :: Delta -> PmCt -> DsM Delta`

- ```
  data ClauseCoverage = Redundant | Matched RhsAccessibility
  data RhsAccessibility = RhsInaccessible | RhsAccessable
  data PmClauseResult = PCR { uncovered :: [Delta]
                            , coverage :: ClauseCoverage }
  data PmResult       = PR  { uncovered :: [Delta]
                            , clauses :: [ClauseCoverage] }
  ```
- ```
  newtype Delta = Delta (Bag Theta) deriving (Functor, Foldable, Traversable)
  liftDelta :: Monad m => (Theta-> m (Maybe Theta)) -> Delta -> m Delta
  liftDelta f = fmap catBagsMaybe . traverse f
  ```
  And then define `pmc` in terms of that. `liftDelta` for ops like `addTmCt`.  
    - Also we can finally get rid of `n_siblings` for the throttling function, it's just `length Delta` now

- ```
  data Clause = AtRhs
              | Guard PmGrd Clause
              | Many [Clause]
  pmc :: Clause -> Deltas -> DsM 
  ```

- When we have `Delta = Delta (Bag Theta)`, we can actually use the Covered set as a `Delta` for "long distance info"  
  - No more just positive info and the `computeCovered` duplication can go away
  - Performance-wise, we should be fine with !1752

- Implement "smarter `CoreMap`"
- Test for "N series" (Matching over a binary tree, like the code generated by `-XDeriveGeneric`)

## Issues

- #17270: `Origin` annotations should be consistent about TH  
  - Faintly related: #14838, #14899. Should we warn about TH? Probably guard it behind a flag. Off by default? SG thinks so. This code is generated potentially in another library by a different user. Also compiler performance

## Epics

- Paper  
  - Type-set checking function, commit to syntax for Delta
- Think about how to fix "regression" in T11822  
  - SG bets a smart `CoreMap` would do
- Maybe pattern-match check typed TH quotations? SG doesn't think this is a good idea, because they might not even end up in that form in spliced code.
- Can we check if a clause is uniform? E.g. can be moved around (more or less) freely, up or down.  
  - I think we can, by trying to move up the clause and see if its new Covered set has a non-empty intersection (e.g. overlaps) with the clause that was previously there. Example:  
    ```haskell
    data T = A | B | C
    f (Just False) = ()
    f Nothing      = ()
    f (Just _)     = ()
    ```
    If we try to move the third clause up once, it covers the left over `Just True`. The second clause covers `Nothing`, so  the two clauses don't overlap. If we try to move up the third clause to the top, it suddenly covers `Just _`, which overlaps with `Just False` from the actual first clause. So we may switch second and third clause but not move the third clause to the top.
  - This is very similar to redundancy checking, but in redundancy checking we see if we *completely* overlap the pattern. Here, we see if their Covered sets overlap *at all* instead of seeing if one completely covers the other.
  - I suppose this also has tricky interactions with bottom. But our existing machinery should cover it.

# Separate CPR

- Wiki page: https://gitlab.haskell.org/ghc/ghc/wikis/nested-cpr/split-off-cpr  
  - Collect proper arguments
  - Include the example from https://gitlab.haskell.org/ghc/ghc/merge_requests/1427#note_214697
- !1427: Splits-off CPR analysis from DmdAnal, but still needs work  
  - Delete CPR stuff from DmdAnal
  - Encode `Arity` in CPR signature
  - Measure compile-time impact

# Nested CPR

- Mostly working prototype at https://gitlab.haskell.org/ghc/ghc/tree/wip/nested-cpr-2019

## Roadblocks 

- Nested CPR of DataCon wrappers needs to look at RHS of wrapper (think of `data T = T !(Int, Int)`) 
- Do nested CPR for KindReps/TypeReps/Modules? Horrendeous signatures in T7360 and T8274, but stats only improve overall
- T9291: unsafePtrEquality checks for STG CSE  
  - `bar x = (Right x, Right x)` gets CPR'd, `$wbar x = (# x, x #)` can't CSE at call site. Fixed testcase with `lazy`, but is that the right thing to do?
- integerConstantFolding: `CONSTANT_FOLDED` on `decodeDoubleInteger`, but gets WW'd because of nested `Int64`
  - We can't really just return the unboxed Int#, because that's platform dependent. BUT we could return Int64# instead
  - Alternatively, inline `decodeIntegerDouble` and recognise the PrimOp, seems like the much saner behavior?!