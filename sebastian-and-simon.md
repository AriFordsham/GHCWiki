# Pattern-match checking

## Patches

Those with an MR actually have code.

- !2192: Reflect tree structure of clauses and gaurds in the syntax we check. A variant of the following:
  ```
  data ClauseCoverage = Redundant | Matched RhsAccessibility
  data RhsAccessibility = RhsInaccessible | RhsAccessable
  data PmClauseResult = PCR { uncovered :: [Delta]
                            , coverage :: Clause  }
  data PmResult       = PR  { uncovered :: [Delta]
                            , clauses :: [ClauseCoverage] }

  data Clause = AtRhs
              | Guard PmGrd Clause
              | Many [Clause]
  pmc :: Clause -> Deltas -> DsM 
  ```
  only that `Clause` is the skeleton for 3 different kinds of trees. 
  - In !2192 Seb proposed
    ```haskell
    data ClauseTree many branch rhs
      = Many   !many           [ClauseTree many branch rhs]
      | Branch !branch         !(ClauseTree many branch rhs)
      | AtRhs  !(Located SDoc) !rhs

    --                             many   branch      rhs
    type GrdTree      = ClauseTree GrdVec Void        GrdVec
    type CtTree       = ClauseTree PmCts  BranchPmCts PmCts
    type DigestedTree = ClauseTree ()     Diverged    Covered
    ```
    The `Clause` data type above has the advantage that there is only a single
    location where we annotate `PmGrd`s. But this data type is better suited to
    express the semantics for `PmCt`s: `Branch` will be annotated with
    diverging and uncovered constraints and thus captures fall-through
    semantics. Maybe we do both in separate data types?
    Anyway, converting one into the other is simple, but needs continuation passing style for wrapping `Branch`es.
  - Maybe we should have separate data types for `GrdTree` and `CtTree`/`DigestedTree`?

- Clean up `provideEvidence`, define `ensureInhabited delta = null <$> provideEvidence 1 delta`
  - !1975 featured a rewrite, which makes for better warning messages
  - But `provideEvidence` currently assumes that every COMPLETE set is inhabited, and thus implicitly assumes that `ensureInhabited` is true for that data type. So we can't actually just re-define it in terms of the other just yet.
  - `provideEvidence` currently picks the smallest residual COMPLETE set for reports. But it doesn't consider type information! So it may indeed happen that we pick a residual COMPLETE set that looks smaller (say, size 2) and is still inhabited in favor of one that disregarding type info looks bigger (size 3) but actually only 1 is inhabited. For the same reason, we can't use `provideEvidence` as a replacement for `ensureInhabited`.
  - It *is* possible to make `provideEvidence` behave appropriately to replace `ensureInhabited`, but it's not very efficient. Also `ensureInhabited` is entirely orthogonal to what `provideEvidence` does. Think of recursive data types, for example: `provideEvidence` doesn't attempt to recurse *at all*. It just doesn't make for good warning messages.

- https://gitlab.haskell.org/ghc/ghc/tree/wip/pmcheck-refactor-deltas:
  ```
  data Delta = Empty | And Delta PmCt | Or Delta Delta
  ```
  And then define `pmCheck` in terms of that.

- #17378, !1765: Preserve non-void constraints  
  - Should not remove inhabitation candidate stuff just yet, newtypes...
  - Perhpas postpone test until get to RHS (pmc []), and then ask for `not (null (provideEvidence 1 delta))`

- `data PmCt = TyCt .. | TmCt ...`; then `addPmCt :: Delta -> PmCt -> DsM Delta`  
  - Type evidence only in bulk lists, so `addPmCt` doesn't really make sense. It should be `addPmCts`, taking a bag of `PmCt`s.


- When we have `Delta = Delta (Bag Theta)`, we can actually use the Covered set as a `Delta` for "long distance info"  
  - No more just positive info and the `computeCovered` duplication can go away
  - Performance-wise, we should be fine with !1752

- Implement "smarter `CoreMap`"
- Test for "N series" (Matching over a binary tree, like the code generated by `-XDeriveGeneric`)

## Issues

- #17270: `Origin` annotations should be consistent about TH  
  - Faintly related: #14838, #14899. Should we warn about TH? Probably guard it behind a flag. Off by default? SG thinks so. This code is generated potentially in another library by a different user. Also compiler performance

## Epics

- Paper  
  - Type-set checking function
  - Commit to syntax for Delta
    - Like in the presentation: Have a "value set" that is a refinement of the type of the value vector, Delta ::= { Gamma | Constraints }
  - Gamma binds only match vars. This implies that Constraint trees have the notion of scoping, like list comprehensions
  - Having the condensed form `Redundant | Inaccessible | Reachable` is inconsequential, because then we need to concern `pmcheck` with inhabitation testing (\cup_C and \cup_D, for example), when in the rest of the checking function we don't test for inhabitants eagerly. I think we should commit to either early or late inhabitation testing, not this in-between stuff. Also we need the Covered set for long distance info anyway. But where should we attach Gamma then? To the ClauseResult triple? To the incoming uncovered set? Both need it. But for `pmcheck` we can just take Gamma as a parameter, so we should be fine. But also Gamma is specific to each theta. Yuck!!!
- Think about how to fix "regression" in T11822  
  - SG bets a smart `CoreMap` would do
- Maybe pattern-match check typed TH quotations? SG doesn't think this is a good idea, because they might not even end up in that form in spliced code.
- Can we check if a clause is uniform? E.g. can be moved around (more or less) freely, up or down.  
  - I think we can, by trying to move up the clause and see if its new Covered set has a non-empty intersection (e.g. overlaps) with the clause that was previously there. Example:  
    ```haskell
    data T = A | B | C
    f (Just False) = ()
    f Nothing      = ()
    f (Just _)     = ()
    ```
    If we try to move the third clause up once, it covers the left over `Just True`. The second clause covers `Nothing`, so  the two clauses don't overlap. If we try to move up the third clause to the top, it suddenly covers `Just _`, which overlaps with `Just False` from the actual first clause. So we may switch second and third clause but not move the third clause to the top.
  - This is very similar to redundancy checking, but in redundancy checking we see if we *completely* overlap the pattern. Here, we see if their Covered sets overlap *at all* instead of seeing if one completely covers the other.
  - I suppose this also has tricky interactions with bottom. But our existing machinery should cover it.

# Separate CPR

- Wiki page: https://gitlab.haskell.org/ghc/ghc/wikis/nested-cpr/split-off-cpr  
  - Collect proper arguments
  - Include the example from https://gitlab.haskell.org/ghc/ghc/merge_requests/1427#note_214697
- !1427: Splits-off CPR analysis from DmdAnal, but still needs work  
  - Delete CPR stuff from DmdAnal
  - Encode `Arity` in CPR signature
  - Measure compile-time impact

# Nested CPR

- Mostly working prototype at https://gitlab.haskell.org/ghc/ghc/tree/wip/nested-cpr-2019

## Roadblocks 

- Nested CPR of DataCon wrappers needs to look at RHS of wrapper (think of `data T = T !(Int, Int)`) 
- Do nested CPR for KindReps/TypeReps/Modules? Horrendeous signatures in T7360 and T8274, but stats only improve overall
- T9291: unsafePtrEquality checks for STG CSE  
  - `bar x = (Right x, Right x)` gets CPR'd, `$wbar x = (# x, x #)` can't CSE at call site. Fixed testcase with `lazy`, but is that the right thing to do?
- integerConstantFolding: `CONSTANT_FOLDED` on `decodeDoubleInteger`, but gets WW'd because of nested `Int64`
  - We can't really just return the unboxed Int#, because that's platform dependent. BUT we could return Int64# instead
  - Alternatively, inline `decodeIntegerDouble` and recognise the PrimOp, seems like the much saner behavior?!

# On hold

- https://gitlab.haskell.org/ghc/ghc/tree/wip/ext-arity: Rebased Zach's implementation of the extensionality paper  
  - Wait for levity polymorphism and matchability polymorphism to work out

# Done

- #17248, #17376, !1975: Get rid of the special case for `-XEmptyCase`. Fix handling of newtypes because of testsuite failures. Some ground work for proper non-void constraint handling.
- #17357: Fix strictness of pattern synonyms. We came to the agreement that it's not worth the trouble and most useful pattern synonyms are strict anyway.


