# Pattern-match checking

## Patches

Those with an MR actually have code.

- #17248, #17376, !1975: Get rid of the special case for `-XEmptyCase`. Fix handling of newtypes because of testsuite failures. Some ground work for proper non-void constraint handling. Currently blocked on a potentially spurious metric regression in `T10370`, which measures maximum residency (sigh). Side note: SG thinks we should refactor the testsuite to use `+RTS -h -i0.05 -A100k` instead of `+RTS -G1` for accurate measurements. At least `Note [residency]` suggests that.

- #17357: Fix strictness of pattern synonyms. We came to the agreement that it's not worth the trouble and most useful pattern synonyms are strict anyway.

- Clean up `provideEvidence`, define `ensureInhabited delta = null <$> provideEvidence 1 delta`
  - !1975 features a rewrite, which makes for better warning messages
  - But `provideEvidence` currently assumes that every COMPLETE set is inhabited, and thus implicitly assumes that `ensureInhabited` is true for that data type. So we can't actually just re-define it in terms of the other just yet.
  - `provideEvidence` currently picks the smallest residual COMPLETE set for reports. But it doesn't consider type information! So it may indeed happen that we pick a residual COMPLETE set that looks smaller (say, size 2) and is still inhabited in favor of one that disregarding type info looks bigger (size 3) but actually only 1 is inhabited. For the same reason, we can't use `provideEvidence` as a replacement for `ensureInhabited`.
  - It *is* possible to make `provideEvidence` behave appropriately to replace `ensureInhabited`, but it's not very efficient. Also `ensureInhabited` is entirely orthogonal to what `provideEvidence` does. Think of recursive data types, for example: `provideEvidence` doesn't attempt to recurse *at all*. It just doesn't make for good warning messages.

- https://gitlab.haskell.org/ghc/ghc/tree/wip/ext-arity: Rebased Zach's implementation of the extensionality paper

- #17378, !1765: Preserve non-void constraints  
  - Should not remove inhabitation candidate stuff just yet, newtypes...
  - Perhpas postpone test until get to RHS (pmc []), and then ask for `not (null (provideEvidence 1 delta))`

- `data PmCt = TyCt .. | TmCt ...`; then `addPmCt :: Delta -> PmCt -> DsM Delta`  
  - Type evidence only in bulk lists, so `addPmCt` doesn't really make sense. It should be `addPmCts`, taking a bag of `PmCt`s.

- ```
  data ClauseCoverage = Redundant | Matched RhsAccessibility
  data RhsAccessibility = RhsInaccessible | RhsAccessable
  data PmClauseResult = PCR { uncovered :: [Delta]
                            , coverage :: ClauseCoverage }
  data PmResult       = PR  { uncovered :: [Delta]
                            , clauses :: [ClauseCoverage] }
  ```
- https://gitlab.haskell.org/ghc/ghc/tree/wip/pmcheck-refactor-deltas:
  ```
  newtype Delta = Delta (Bag Theta) deriving (Functor, Foldable, Traversable)
  liftDelta :: Monad m => (Theta-> m (Maybe Theta)) -> Delta -> m Delta
  liftDelta f = fmap catBagsMaybe . traverse f
  ```
  And then define `pmc` in terms of that. `liftDelta` for ops like `addTmCt`.  
    - Also we can finally get rid of `n_siblings` for the throttling function, it's just `length Delta` now
    - It turns out that it's not so easy to implement throttling in a satisfying manner. By handling all `Delta`s in one bulk, we lose the connection between original Delta and offspring Deltas, e.g. the branching factor. So we somehow need to retain that connection, without leaking the details into the Oracle... So we basically handle a `[Theta]` in the checking function, not great. ARgh

- ```
  data Clause = AtRhs
              | Guard PmGrd Clause
              | Many [Clause]
  pmc :: Clause -> Deltas -> DsM 
  ```

- When we have `Delta = Delta (Bag Theta)`, we can actually use the Covered set as a `Delta` for "long distance info"  
  - No more just positive info and the `computeCovered` duplication can go away
  - Performance-wise, we should be fine with !1752

- Implement "smarter `CoreMap`"
- Test for "N series" (Matching over a binary tree, like the code generated by `-XDeriveGeneric`)

## Issues

- #17270: `Origin` annotations should be consistent about TH  
  - Faintly related: #14838, #14899. Should we warn about TH? Probably guard it behind a flag. Off by default? SG thinks so. This code is generated potentially in another library by a different user. Also compiler performance

## Epics

- Paper  
  - Type-set checking function
  - Commit to syntax for Delta
    - Ã  la Refinement type? But then we aren't in DNF (i.e. union only on the top-level).
    - But if we have the "\Theta = union of \theta" idea, then how does \theta look? -> Just a list of constraints, of course (which are `all` true at the same time). Then \oplus just lifts adding a constraint over all the thetas.
    - How do we call the empty \theta? \epsilon (neutral element of constraint list) seems misleading compared to \emptyset (neutral element of union).
  - What are FV (the things we bind in Gamma) of Theta? Only the match variables or also let-bound stuff? We don't have any binding constructs in our representation of theta, so probably the latter? That is quite weird, because Gamma will bind stuff from other closed lexical scopes. See `h` in #17378, where in the second equation, Gamma would have to bind `y` although it's only a thing in the first equation.
  - Having the condensed form `Redundant | Inaccessible | Reachable` is inconsequential, because then we need to concern `pmcheck` with inhabitation testing (\cup_C and \cup_D, for example), when in the rest of the checking function we don't test for inhabitants eagerly. I think we should commit to either early or late inhabitation testing, not this in-between stuff. Also we need the Covered set for long distance info anyway. But where should we attach Gamma then? To the ClauseResult triple? To the incoming uncovered set? Both need it. But for `pmcheck` we can just take Gamma as a parameter, so we should be fine. But also Gamma is specific to each theta. Yuck!!!
  - So: Gamma must be part of theta/we should name the list of constraints delta and have `\theta ::= \Gamma \vdash \Delta`.
- Think about how to fix "regression" in T11822  
  - SG bets a smart `CoreMap` would do
- Maybe pattern-match check typed TH quotations? SG doesn't think this is a good idea, because they might not even end up in that form in spliced code.
- Can we check if a clause is uniform? E.g. can be moved around (more or less) freely, up or down.  
  - I think we can, by trying to move up the clause and see if its new Covered set has a non-empty intersection (e.g. overlaps) with the clause that was previously there. Example:  
    ```haskell
    data T = A | B | C
    f (Just False) = ()
    f Nothing      = ()
    f (Just _)     = ()
    ```
    If we try to move the third clause up once, it covers the left over `Just True`. The second clause covers `Nothing`, so  the two clauses don't overlap. If we try to move up the third clause to the top, it suddenly covers `Just _`, which overlaps with `Just False` from the actual first clause. So we may switch second and third clause but not move the third clause to the top.
  - This is very similar to redundancy checking, but in redundancy checking we see if we *completely* overlap the pattern. Here, we see if their Covered sets overlap *at all* instead of seeing if one completely covers the other.
  - I suppose this also has tricky interactions with bottom. But our existing machinery should cover it.

# Separate CPR

- Wiki page: https://gitlab.haskell.org/ghc/ghc/wikis/nested-cpr/split-off-cpr  
  - Collect proper arguments
  - Include the example from https://gitlab.haskell.org/ghc/ghc/merge_requests/1427#note_214697
- !1427: Splits-off CPR analysis from DmdAnal, but still needs work  
  - Delete CPR stuff from DmdAnal
  - Encode `Arity` in CPR signature
  - Measure compile-time impact

# Nested CPR

- Mostly working prototype at https://gitlab.haskell.org/ghc/ghc/tree/wip/nested-cpr-2019

## Roadblocks 

- Nested CPR of DataCon wrappers needs to look at RHS of wrapper (think of `data T = T !(Int, Int)`) 
- Do nested CPR for KindReps/TypeReps/Modules? Horrendeous signatures in T7360 and T8274, but stats only improve overall
- T9291: unsafePtrEquality checks for STG CSE  
  - `bar x = (Right x, Right x)` gets CPR'd, `$wbar x = (# x, x #)` can't CSE at call site. Fixed testcase with `lazy`, but is that the right thing to do?
- integerConstantFolding: `CONSTANT_FOLDED` on `decodeDoubleInteger`, but gets WW'd because of nested `Int64`
  - We can't really just return the unboxed Int#, because that's platform dependent. BUT we could return Int64# instead
  - Alternatively, inline `decodeIntegerDouble` and recognise the PrimOp, seems like the much saner behavior?!
