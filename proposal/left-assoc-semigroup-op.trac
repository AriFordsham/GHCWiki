= Left-Associative `Semigroup` Operator Alias

[[PageOutline]]

== Problem ==

With the implementation of prime:Libraries/Proposals/SemigroupMonoid, `Semigroup` will become a superclass of `Monoid`, and consequently `Semigroup((<>))` will be re-exported alongside `Monoid` from the `Prelude` module.

{{{#!hs
-- reduced/simplified definition
class Semigroup a where
    (<>) :: a -> a -> a

infixr 6 <>
}}}

=== Conflicting fixities of `<>` in pretty printing APIs

However, there are a few popular pretty-printing modules which already define a `<>` top-level binding for their respective semigroup/monoid binary operation. The problem now is that those `<>` definitions use a different operator fixity/associativity:

{{{#!hs
-- pretty
module Text.PrettyPrint.Annotated.HughesPJ where

infixl 6 <>
infixl 6 <+>
infixl 5 $$, $+$

-- pretty
module Text.PrettyPrint.HughesPJ where

infixl 6 <>
infixl 6 <+>
infixl 5 $$, $+$
}}}

{{{#!hs
-- template-haskell
module Language.Haskell.TH.PprLib where

infixl 6 <> 
infixl 6 <+>
infixl 5 $$, $+$
}}}

{{{#!hs
-- ghc
module Outputable
infixl 9 <> 
infixl 9 <+>
infixl 9 $$, $+$

-- ghc
module Pretty where

infixl 6 <>
infixl 6 <+>
infixl 5 $$, $+$
}}}

=== Changing `<>`'s associativity in pretty-printing APIs

Changing the fixity of `pretty`'s `<>` would however results in a semantic change for code which relies on the relative fixity between `<+>` and `<>` as was [https://mail.haskell.org/pipermail/libraries/2011-November/017066.html pointed out by Duncan back in 2011] already:

> So I was preparing to commit this change in base and validating ghc when I discovered a more subtle issue in the pretty package:
>
> Consider
>
>
> {{{#!hs
> a <> empty <+> b
> }}}
>
> The fixity of `<>` and `<+>` is critical:
>
> {{{#!hs
>   (a <> empty) <+> b
> = {- empty is unit of <> -}
>   (a         ) <+> b
> 
>   a <> (empty <+> b)
> = {- empty is unit of <+> -}
>   a <> (          b)
> }}}
>
> Currently Text.Pretty declares `infixl 5 <>, <+>`. If we change them to be `infixr` then we get the latter  meaning of `a <> empty <+> b`. Existing code relies on the former meaning and produces different output with the latter (e.g. ghc producing error messages like "instancefor" when it should have been "instance for").

=== Unsatisfying Situation Requiring a Solution

Consequently, it's confusing and bad practice to have a soon-to-be-in-Prelude `<>` operator whose meaning depends on which `import`s are currently in scope. Moreover, a module needs to combine pretty-printing monoids and other non-pretty-printing monoids, the conflicting `<>`s operator needs to be disambiguated via module qualification or similiar techniques.

However, there also seems to be a legitimate use-case for a right-associative `<>` operator.



