= Intrinsic Superclasses =

'''Note''' This page is a new version of the DefaultSuperclassInstances proposal, and may ultimately supplant it. For now, I'm keeping the two separate as the delta is large, superficially at least. See also on [http://www.reddit.com/r/haskell/comments/2avs16/intrinsicsuperclasses_for_haskell_new_proposal/ Reddit].

== The Problem ==

Sometimes we want to refactor the type class hierarchy, and it always hurts. The typical scenario is that we have a library class
{{{
class C x where
  f :: ...
  g :: ...
}}}
but then realise that `C` is the "has `g`" special case of a useful general notion `S`, so we would really prefer to have had the library supply
{{{
class S x where
  f :: ...
class S x => C x where
  g :: ...
}}}
The cost of the generalization is that all our old `C` instances must be split into a `C` and an `S`. Client code breaks all over the place and people complain bitterly. This is the reason to resist making `Functor` and `Applicative` superclasses of `Monad`. It would have been pleasant to introduce `Applicative` as a generalization of `Monad` and somehow have all our old `Monad` instances generate `Applicative` instances too.

'''Requirement 1''' It should somehow be possible for an instance definition in source code to generate more than one instance internally.

However, the problem deepens. What if we actually had
{{{
class C x where
  f :: ...
  f =  ...g...
  g :: ...
}}}
to start with? That is, types with a `C` instance can be given an `S` instance in a "standard" way, but there are other types which have `S` instances defined differently and no `C` instance at all. Again, that is a familiar situation: every `Monad` has is `Applicative` with `(<*>) = ap`, but non-monadic `Applicative` instances have `(<*>)` defined in other ways. But now our split hits trouble. We cannot have
{{{
class S x where
  f :: ...
  f =  ...g...
class S x => C x where
  g :: ...
}}}
because (technically) `g` is no longer in scope for the default `f` definition and (morally) because only the `S`s which are also `C` should have that default definition anyway: the default `f` definition rightly belongs in the declaration of `C`, but `f` is not a method of `C`.

'''Requirement 2''' Some subclasses should somehow be able to offer default definitions for things in some of their superclasses.

If only we could write something like
{{{
class S x where
  f :: ...
class (instance S x) => C x where
  g :: ...
  f =  ...g...
}}}
where the extra `instance` marking the superclass constraint makes `S` an '''intrinsic''' superclass of `C`, so that `f` can be treated as if it were a method of `C` for purposes of `C`'s instances and for default definition in the `C` class declaration.

If this machinery had been in place when `Applicative` was invented, we could just have given
{{{
class (instance Functor f) => Applicative f where
  return :: x -> f x
  (<*>)  :: f (a -> b) -> f a -> f b
  fmap = (<*>) . return
class (instance Applicative m) => Monad m where
  (>>=) :: m a -> (a -> m b) -> m b
  mf <*> ma = mf >>= \ f -> ma >>= \ a -> return (f a)
}}}
and, moreover, we could have chosen to give `Monad` its own specialized `fmap`
{{{
  fmap f ma = ma >>= \ a -> return (f a)
}}}

'''Requirement 3''' Subclass declarations should somehow be able to override default definitions from their superclass declarations. Such overriding default definitions should be further overridable in sub-subclass declarations and in instance definitions.

Even if we can build a technology which supports such a treatment, we face further problems rolling it out across the legacy codebase. We hit some trouble if we take an existing subclass and make it intrinsic, e.g.,
{{{
class (instance Eq x) => Ord x where
  compare :: x -> x -> Ordering
  x == y = case compare x y of {EQ -> True; _ -> False}
}}}
because every old `Ord` instance will now generate an `Eq` instance for which a duplicate ''must'' already exist. Worse is the situation with `Monad` and `Applicative` where we make an existing class into a ''new'' superclass and make it intrinsic: the prior constraints no longer make the whereabouts of duplicated `Applicative` instances particularly predictable.

'''Requirement 4''' At least transitionally, we must somehow ensure that client code which supplies explicit instances now duplicated by intrinsic superclass instances is broken as infrequently as possible.

We face not only conflicts between explicit and intrinsic instances, but also between multiple intrinsic instances. We should expect
{{{
class (instance Functor t, instance Foldable t) => Traversable t where
  traverse :: Applicative f => (a -> f b) -> t a -> f (t b)
  fmap f = runIdentity . traverse (Identity . f)
  foldMap f = runConst . traverse (Const . f)
}}}
but now if we define
{{{
data Square x = x :& x
instance Monad Square where
  return x = x :& x
  (a :& a') >>= f = case (f a, f a') of
    (b :& _, _ :& b') -> b :& b'
instance Traversable Square where
  traverse f (a :& a') = return (:&) <*> f a <*> f a'
}}}
then we have silently generated duplicate instances for `Functor Square` and no particular reason to choose one over the other.

'''Requirement 5''' Whatever mechanism we employ for generating instances, we need an explicit means to disable it.

We might perhaps write
{{{
data Square x = x :& x
instance Monad Square - Functor where
  ...
instance Traversable Square where
  ...
}}}
to inhibit the `Functor` instance arising from `Monad` but retain that from `Traversable`. It is probably a good thing in any case to be clear about which instances should be generated and which not.

'''Requirement 6''' The meaning of an instance definition should be clear only from its class declaration (and those of its superclasses) and not deduced from the presence or absence of other instances.

A helpful observation is that the language for describing which instances to generate from a given instance definition should be the same as the language for specifying which intrinsic superclass instances should be generated by default in a class declaration, because they are two manifestations of the same problem. In both cases, we need to perform a closure computation, tracing back from a given atomic constraint to find all the intrinsic superclasses which have not been explicitly excluded.


== Terminology and Notation ==

To nail down the technicalities of the proposal, we shall need names for things, and notation to present the things thus named.

Firstly, let us talk about the stuff which gets declared in classes, defined by default in classes, and defined in instances:

 * The '''immediate members''' of a class C are the methods and associated type and data families which are declared in the class declaration for C.
 * The '''members''' of a class C are the methods and associated type and data families which may be defined in instance definitions for C.
 * A '''defaulted member''' of a class C is a member with a default definition which will be added to any C instance which does not contain an overriding definition.
 * An '''immediately defaulted member''' of a class C is a member of class C which is given a default definition in the declaration of C.

In current Haskell, all members are immediate, but this proposal seeks to change that. Similarly, the only defaulted members we currently have are immediately defaulted immediate members. Data families cannot be defaulted (because that could lead to the duplication of data constructors), but methods and type families can be defaulted.

'''Fact''' ''The name of a class member uniquely determines the class of which it is an immediate member.''

Next, let us fix terminology for talking about the superclasses of a class.

 * An '''immediate superclass''' S of a class C is any class which heads a constraint in the declaration of C.
 * A '''superclass''' of C is either C or a proper superclass of C.
 * A '''proper superclass''' of C is a superclass of an immediate superclass of C.

Note that the use of "immediate" is consistent in that it applies to things which are introduced explicitly in class declarations.

Now, let us allow some superclass constraints in class declarations to be labelled with the `instance` keyword.

''toplevel'' ::= ...
  | `class` (''sups'' `=>`)? ''Name'' ''name''+ `where` ''declarations''

''sups'' ::= ''sup'' | `(`''sup'',*`)`

''atom'' ::= ''Name'' ''type''+

''closure'' ::= ''atom'' (`-` ''Name''+)?

''sup'' ::= ''atom'' | `instance` ''closure''

(Grammar grammar: postfix ? for 0 or 1, postfix + for 1 or more, postfix ,* for 0 or more comma-separated)

We can say what are the "intrinsic" superclasses of a class, with "immediate" and "proper" used as above.

 * An '''immediate intrinsic superclass''' S of a class C is any class ''Name''d in an `instance` ''sup'' in the declaration of C.
 * An '''intrinsic superclass''' of C is either C or a proper intrinsic superclass of C
 * A '''proper intrinsic superclass''' of C is an intrinsic superclass of an immediate intrinsic superclass of C.

Of course, the above is an inductive definition, so it gives rise to a notion of '''intrinsic superclass derivation''', being the explanation why some S is an intrinsic superclass of some C.

The ''closure'' formulae, above, explain how to compute which intrinsic superclasses we are bundling with a given class or instance. Every ''closure'' formula, F, has an '''intrinsic closure''', IC(F), being the multiset of atomic formulae given by tracing each intrinsic superclass derivation of F's named class without passing through the classes explicitly listed after the `-` sign, substituting actual for formal parameters. E.g,

  * IC(`Monad []`) = {`Monad []`, `Applicative []`, `Functor []`}
  * IC(`Monad [] - Functor`) = {`Monad []`, `Applicative []`}
  * IC(`Monad [] - Applicative`) = {`Monad []`}

and if we had
{{{
class (instance Ord [x]) => Blah x where ...
}}}
then

  * IC(`Blah Int`) = {`Blah Int`, `Ord [Int]`, `Eq [Int]`}

We shall also need to talk about instances:

''toplevel'' ::= ...
  | `instance` (''constrs'' `=>`)? ''closure'' `where` ''definitions''

''constrs'' ::= ''atom'' | `(`''atom'',*`)`

Let us define the key underlying notion of instance with which we work:

 * An '''immediate''' C '''instance''' for some As `=>` C ts, is the means to define the immediate members of C for actual parameters ts, whenever the constraints As hold.

At present, all instances are immediate. We have an existing technology for managing the implicit inference of class dictionaries given immediate instances for the productions made explicit in `instance` definitions in source code. The point, however, is to liberalize the notion of "member" whilst still being able to generate immediate instances internally from the instances written by the programmer.


== The Proposal ==

'''Action 1''' ''The members of a class C shall be the immediate members of the intrinsic superclasses of C. An instance targeting closure forumla F may define immediate members of all the classes named in IC(F)''

Note that this action makes the members of C the members of the intrinsic superclasses of C (including C itself, of course). The effect is to let C's instances give definitions for not only C's immediate members but also those it has by virtue of intrinsic superclasses. We may now write
{{{
instance Applicative Square where
  pure a = a :& a
  (f :& g) <*> (a :& b) = f a :& g b
  fmap f (a :& b) = f a :& f b
}}}
or
{{{
instance Applicative Square - Functor where
  pure a = a :& a
  (f :& g) <*> (a :& b) = f a :& g b
instance Functor Square
  fmap f (a :& b) = f a :& f b
}}}
but not
{{{
instance Applicative Square - Functor where
  pure a = a :& a
  (f :& g) <*> (a :& b) = f a :& g b
  fmap f (a :& b) = f a :& f b  -- oops
}}}

To give this a clear semantics, we need to ensure that we can take an instance for a production, As `=>` F and split it into immediate instances for the productions {As `=>` S | S in IC(F)}. A sufficient condition for achieving this is to make sure that the intrinsic closure of any atomic constraint have distinct class names, so that it is clear how to distribute members to immediate instances by the above Fact. Let us enforce this condition.

'''Action 2''' ''By policy, intrinsic superclass derivations are unique. Class declarations which violate this policy are rejected.''

E.g., we reject
{{{
class (instance Applicative f, instance Traversable f) => Transposable f where...
}}}
because we could then derive that `Functor` is an intrinsic superclass of `Transposable` (perhaps with different default `fmap` definitions) in two ways. We also forbid
{{{
class (instance Tweedle dum, instance Tweedle dee) => Diddly dum dee where ...
}}}
because we have no uniform way to send `Tweedle` members to the appropriate immediate instance.

'''Action 3''' ''The defaulted members of a class C shall be the immediately defaulted members of C or the defaulted members of C's immediate intrinsic superclasses, with the immediate default definitions prioritized over the superclass defaults.''

We may thus write
{{{
class (instance Functor f) => Applicative f where
  return, pure :: x -> f x
  pure = return
  (<*>)  :: f (a -> b) -> f a -> f b
  fmap = (<*>) . return
class (instance Applicative m) => Monad m where
  (>>=) :: m a -> (a -> m b) -> m b
  pure = return
  mf <*> ma = mf >>= \ f -> ma >>= \ a -> return (f a)
  fmap f ma = ma >>= \ a -> return (f a)
}}}
and note that
  * `<*>` is not a defaulted member of `Applicative`, but it is a defaulted member of `Monad`;
  * `fmap` is a defaulted member of both `Applicative` and `Monad` but with different default definitions.

(By the way, the above negotiation with `return` and `pure` should allow existing `Applicative` instances to work as intended, but generate a warning that `return` has not been defined.)

This proposal satisfies Requirements 1,2,3,5 and 6. However, it breaks plenty of code, so it fails Requirement 4. That comes next.


== Transitional Relief for Legacy Code ==

In the discussion of Action 1, an example conspicuous by its absence is the status quo:
{{{
instance Applicative Square where
  pure a = a :& a
  (f :& g) <*> (a :& b) = f a :& g b
instance Functor Square
  fmap f (a :& b) = f a :& f b
}}}

The proposal as it stands implies that the `Applicative Square` instance would generate an instance for `Functor`, duplicating the explicit instance. Indeed, whenever we make an existing superclass intrinsic, every instance of the subclass duplicates an instance which must exist in the legacy codebase. Think of all those `deriving (Eq,Ord)`s!
Requirement 4 is distinctly unsatisfied.

To do better at Requirement 4, we can choose to sacrifice Requirement 6 by throwing out the parts of an intrinsic closure which are already "pre-empted" by explicit instances. To do so would recover the above legacy declaration, but still exclude
{{{
instance Applicative Square where
  pure a = a :& a
  (f :& g) <*> (a :& b) = f a :& g b
  fmap = (<*>) . pure
instance Functor Square
  fmap f (a :& b) = f a :& f b
}}}

We should not encourage such definitions, but we surely must be able to live with them until people update to the new technology. One suitably nuanced approach might be to support a pragma in class declarations which allows intrinsic superclasses to be pre-empted on an individual basis. For the above, we should have written
{{{
class ({-# PRE-EMPT #-}instance Functor f) => Applicative f where
  ...
}}}
to signal that an intrinsic closure computation can be cut short at that point by an explicit instance.

'''Action 4''' ''An immediate intrinsic superclass marked `{-# PRE-EMPT #-}` will not contribute to an intrinsic closure if the corresponding instance is explicitly in scope. A warning will be issued when this pre-emption happens.''

When we make an existing superclass intrinsic, we can thus ensure no code breakage for the transitional period where we allow pre-emption, whilst issuing warnings to fix code soon.

We still face legacy problems when we make an old class into a new intrinsic superclass, as we will with `Applicative` for `Monad`. Modules which make new things `Applicative` and `Monad`ic will be fine, but if a module imports a `Monad` and makes it `Applicative`, we will have an unavoidable duplicate. It seems dangerous to allow silently generate code to pre-empt explicit code, and even if we did, we could not be sure that the generated instance would have constraints as generous as the later explicit instance, so code compiled with the latter might break against the former.

We might hope that, in future, people might become sufficiently good at deciding to make immediate superclasses intrinsic from the start that we can do away with the need for pre-emption. It seems a necessary evil now.


== Multiple Instances ==

We might consider allowing a single `instance` declaration to define multiple instances explicitly, provided we retain the property that it is clear how to split their members into immediate instances and how to find default members. E.g. we might write
{{{
data Fred = Fred
instance (Read Fred, Show Fred) where
  read _ = Fred
  show _ = "Fred"
}}}

Just as before, we should have to exclude
{{{
instance (Monad Square, Traversable Square) where
  return a = a :& a
  (a :& a') >>= f = case (f a, f a') of
    (b :& _, _ :& b') -> b :& b'
  traverse f (a :& a') = return (:&) <*> f a <*> f a'
}}}
because it is not clear which default `Functor` instance is intended. But we would allow
{{{
instance (Monad Square - Functor, Traversable Square) where
  return a = a :& a
  (a :& a') >>= f = case (f a, f a') of
    (b :& _, _ :& b') -> b :& b'
  traverse f (a :& a') = return (:&) <*> f a <*> f a'
}}}

It would seem churlish to require such definitions to exclude explicitly instances which are present explicitly in the very same header. Nor would it be in violation of Requirement 6, as the pre-emption would happen within a single instance declaration. Such pre-emption needs no warning.

Note that one could then write
{{{
instance (Monad Square, Traversable Square, Functor Square) where
  return a = a :& a
  (a :& a') >>= f = case (f a, f a') of
    (b :& _, _ :& b') -> b :& b'
  traverse f (a :& a') = return (:&) <*> f a <*> f a'
}}}
and compile to get a warning that the promised explicit `Functor` instance is missing its implementation of `fmap`.

The same logic should clearly apply to `deriving` clauses, so that (e.g. for `Square`)

  * `deriving Ord` gives `Ord a => Ord (Square a)` as usual and `Ord a => Eq (Square a)` with default implementation;
  * `deriving (Ord, Eq) gives `Ord a => Ord (Square a)` and `Eq a => Eq (Square a)`, with no pre-emption warning;
  * `deriving (Ord - Eq)` gives just `Ord a => Ord (Square a)` requiring a separate hand-rolled `Eq (Square a)` instance.
