Using `Data.Reflection` has some runtime costs. Notably, there can be no inlining or unboxing of reified values. I think it would be nice to add a GHC special to support it. I'll get right to the point of what I want, and then give a bit of background about why.

=== What I want ===

I propose the following magical function:

{{{#!hs
reify# :: (forall s . c s a => t s r) -> a -> r
}}}

`c` is assumed to be a single-method class with no superclasses whose dictionary representation is exactly the same as the representation of `a`, and `t s r` is assumed to be a newtype wrapper around `r`. In desugaring, `reify# f` would be turned into some coercion of `f`. See below regarding specialization concerns.

=== Why I want it ===

The following is a somewhat modified version of the main idea in `Data.Reflection`, with some relatively minor changes to clean up the very core of it.

{{{#!hs
newtype Tagged s a = Tagged { unTagged :: a }

unproxy :: (Proxy s -> a) -> Tagged s a
unproxy f = Tagged (f Proxy)

class Reifies s a | s -> a where
  reflect' :: Tagged s a

-- For convenience
reflect :: forall s a proxy . Reifies s a => proxy s -> a
reflect _ = unTagged (reflect' :: Tagged s a)

-- The key function--see below regarding implementation
reify' :: (forall s . Reifies s a => Tagged s r) -> a -> r

-- For convenience
reify :: a -> (forall s . Reifies s a => Proxy s -> r) -> r
reify a f = reify' (unproxy f) a
}}}

The key idea of `reify'` is that something of type

{{{#!hs
forall s . Reifies s a => Tagged s r
}}}

is represented in memory exactly the same as a function of type `a -> r`.

So we can currently use `unsafeCoerce` to interpret one as the other. Following the general approach of the library, we can do this as such:

{{{#!hs
newtype Magic a r = Magic (forall s . Reifies s a => Tagged s r)
reify' :: (forall s . Reifies s a => Tagged s r) -> a -> r
reify' f = unsafeCoerce (Magic f)
}}}

This certainly works. The trouble is that any knowledge about what is reflected goes unused. For instance, if I write

{{{#!hs
reify 12 $ \p -> reflect p + 3
}}}

then GHC will not see, at compile time, that the result is 15. If I write

{{{#!hs
reify (+1) $ \p -> reflect p x
}}}

then GHC will never inline the application of `(+1)`. Etc. It appears that the `forall s` in `Magic` gums up the inliner somehow.

I'd like to replace `reify'` with `reify#` to allow such optimizations.

=== Why so general ===

{{{#!hs
reify# :: (forall s . c s a => t s r) -> a -> r
}}}

is, of course, far more polymorphic than it has any right to be. In principle, we should only need one `c`, namely `Data.Reflection.Reifies`, and one `t`, namely `Data.Tagged.Tagged`. But making it polymorphic prevents us from having to use a class and type available in `ghc-prim`.

=== Specialization concerns ===

I've found an approach that seems to get the inlining I want in userspace, by changing `Magic`, but I'm not confident it's safe:

{{{#!hs
type family Skolem :: * where
newtype Magic a r = Magic (Reifies Skolem a => Tagged Skolem r)
}}}

My concern with this approach is that in sufficiently complex circumstances, the specializer could conflate two different reified values of the same type, as each of them will, at a certain point, look like `Reifies Skolem A`. I haven't actually found a way to make this happen yet, but it smells fishy nonetheless. I would hope GHC would be able to guarantee that the argument to `reify#` will never be specialized to a particular instance of `c` (i.e., `Reifies`).