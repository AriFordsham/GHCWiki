This page is to track the discussions on #11348 and #12088.

The essential problem is that type-checking declarations can depend on `type instances` so we must be careful to process `type instance`s in the correct order. 

The motivating example is

{{{
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE TypeInType #-}

import Data.Kind
import Data.Proxy

type family TrivialFamily t :: Type
type instance TrivialFamily (t :: Type) = Bool

data R where
    R :: Proxy Bool -> R

type ProblemType t = 'R ('Proxy :: Proxy (TrivialFamily t))
}}}

Which was rejected with

{{{
error:
    • Expected kind ‘Proxy Bool’,
        but ‘'Proxy’ has kind ‘Proxy (TrivialFamily t)’
    • In the first argument of ‘R’, namely
        ‘(Proxy :: Proxy (TrivialFamily t))’
      In the type ‘R (Proxy :: Proxy (TrivialFamily t))’
      In the type declaration for ‘ProblemType’
}}}

GHC was typechecking `ProblemType` before the instance for `TrivialFamily` was processed.

= Original Solution

Alex Vieth partially solved the solution for simple cases where `type` declaractions depend on `type instances` as in the example. The solution was
to *eagerly* process type family instances as soon as it was possible to do so. The solution is inadequate due to the method used to compute dependencies for type instances. 

The algorithm is:

1. Compute the SCCs for `TyClDecls` as we do now in HEAD.
2. For all of the `InstDecls`, associate it with its `FreeVars`, intersected with the set of `Name`s of `TyClDecls` that we just analysed.
3. Fold the list of SCCs, at each step extracting the set of `InstDecls` for which its FreeVars is empty, and then eliminating all of the Names found in that SCC. That set of `InstDecls`, if non-empty, comes before the current component in the output list.

Implicit in step 2 is an algorithm to compute the free variables of each `type instance` declaration.

It was implemented as follows:

For a `type instance` declaration for a type family `T`, the free variables of the declaration are

1. The type constructor `T`.
2. For a free variables `v` in the LHS patterns and RHS. Either the parent of `v` if one exists or else `v` itself.

For example, considering


{{{
data Fin :: N -> Type where                                                     
   FZ :: Fin (S n)                                                               
   FS :: Fin n -> Fin (S n)  

data T

type instance F T FZ = Int
}}}

We compute the free variables to be `{ F, T, Fin }`. Then, Alex's algorithm ensures that as soon as `F` `T` and `Fin` are declared, the instance declaration is added to environment. This ensures that if later declarations depend on `F`, they can make use of this instance.

= The Problem

However, this is insufficient as there are other (hidden) dependencies for type instance declarations. We also perform *kind checking* of 
each argument to the instance declaration, as a result, we should also declare these dependencies to ensure that all instances which could affect this kind checking are processed first.

The problem is not that the type family declaration will not have been processed by the time we get to the instance declaration as the current dependency analysis ensures that `F1` is declared before `F` is declared (as `F1` appears lexically in `F`). It is instead that we should also process all instances for `F1` before any instances for `F` as whether the arguments are well-kinded can depend on the instances for `F1`. 

```
type instance F ... ===> type family F .... => type family F1
```

= The Solution

#12088 is a lengthy discussion about possible solutions to solve this problem.

== Alex V: 1 

Alex's first proposal was to augment the dependency graph with extra edges to ensure the order resolved correctly. Simon articulates which edges are added:

* We need an edge that makes a `TyClDecl` `D` depend on every `InstDecl` that does not depend (transitively) on D.



{{{#!box note
This is incomplete. Please help me fill in the details..!
}}}


