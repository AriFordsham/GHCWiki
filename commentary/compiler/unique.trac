== Unique ==

`Unique`s provide a fast comparison mechanism for more complex things. Every `RdrName`, `Name`, `Var`, `TyCon`, `TyVar`, etc. has a `Unique`. When these more complex structures are collected (in `UniqFM`s or other types of collection), their `Unique` typically provides the key by which the collection is indexed.

A `Unique` consists of the ''domain'' of the thing it identifies and a unique integer value 'within' that domain. Details are discussed below.

=== Lifetime

The lifetime of a `Unique` is a single invocation of GHC, i.e. they must not 'leak' to compiler output, the reason being that `Unique`s may be generated/assigned non-deterministically. When compiler output is non-deterministic, it becomes significantly harder to, for example, [wiki:Commentary/Compiler/RecompilationAvoidance avoid recompilation]. Uniques do not get serialised into .hi files, for example.

Note, that "one compiler invocation" is not the same as the compilation of a single `Module`. Invocations such as `ghc --make` or `ghc --interactive` give rise to longer invocation life-times. 

This is also the reasons why `OccName`s are ''not'' ordered based on the `Unique`s of their underlying `FastString`s, but rather ''lexicographically'' (see [[GhcFile(compiler/basicTypes/OccName.lhs)]] for details).  '''SLPJ:''' I am far from sure that the Ord instance for `OccName` is ever used, so this remark is probably misleading.  Try deleting it and see where it is used (if at all).  '''End SLPJ'''

== Redesign (2014) ==

=== TL;DR
The redesign is to accomplish the following:
 * Allow derivation of type class instances for `Unique`
 * Restore invariants from the original design; hide representation details
 * Eliminate violations of invariants and design-violations in other places of the compiler (e.g. `Unique`s shouldn't be written to `hi`-files, but are)

=== Longer

In an attempt to give more of GHC's innards well-behaved instances of `Typeable`, `Data`, `Foldable`, `Traversable`, etc. the implementation of `Unique`s was a bit of a sore spot. They were implemented (20+ years earlier) using custom boxing, viz.
{{{
data Unique = MkUnique Int#
}}}
making automatic derivation of such type class instances hard. There was already a comment asking why it wasn't simply a `newtype` around a normal (boxed) `Int`. Independently, there was some discussion on the mailinglists about the use of (signed) `Int`s in places where `Word`s would be more appropriate. Further inspection of the `Unique` implementation made clear that a lot of invariants mentioned in comments had been violated by incremental edits. This is discussed in more detail below, but these things together (the desire for automatic derivation and the restoration of some important invariants) motivated a moderate redesign.


=== Status Quo (pre redesign)

A `Unique` has a domain (`TyCon`, `DataCon`, `PrelName`, `Builtin`, etc.) that was codified by a character. The remainder of the `Unique` was an integer that should be unique for said domain. This '''was''' once guaranteed through the export list of [[GhcFile(compiler/basicTypes/Unique.lhs)]], where direct access to the domain-character was hidden, i.e.
{{{
mkUnique :: Char -> Int -> Unique
unpkUnique :: Unique -> (Char,Int)
}}}
were not exported. This should have guaranteed that every domain was assigned its own unique character, because only in [[GhcFile(compiler/basicTypes/Unique.lhs)]] could those `Char`s be assigned. However, through
{{{
mkUniqueGrimily :: Int -> Unique
mkUniqueGrimily i = MkUnique (iUnbox i)
}}}
this separation of concerns leaked out to [[GhcFile(compiler/basicTypes/UniqSupply.lhs)]], because its `Int` argument is the ''entire'' `Unique` and not just the integer part 'under' the domain character. The function `mkSplitUniqSupply` made the domain-character accessible to all the other modules, by having a wholly separate implementation of the functionality of `mkUnique`.

Another broken design choice is that `Unique`s should not appear in compiler output. However, from [[GhcFile(compiler/iface/BinIface.lhs)]]:
{{{
-- Note [Symbol table representation of names]
-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
--
-- An occurrence of a name in an interface file is serialized as a single 32-bit word.
-- The format of this word is:
--  00xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
--   A normal name. x is an index into the symbol table
--  01xxxxxxxxyyyyyyyyyyyyyyyyyyyyyyyy
--   A known-key name. x is the Unique's Char, y is the int part
--  10xxyyzzzzzzzzzzzzzzzzzzzzzzzzzzzz
--   A tuple name:
--    x is the tuple sort (00b ==> boxed, 01b ==> unboxed, 10b ==> constraint)
--    y is the thing (00b ==> tycon, 01b ==> datacon, 10b ==> datacon worker)
--    z is the arity
--  11xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
--   An implicit parameter TyCon name. x is an index into the FastString *dictionary*
--
-- Note that we have to have special representation for tuples and IP TyCons because they
-- form an "infinite" family and hence are not recorded explicitly in wiredInTyThings or
-- basicKnownKeyNames.
}}}
Notice the `01`-case. It is not quite clear ''why'' `Unique`s are written to `hi`-files here.

=== New plan

In the new design, the domains are explicitly encoded in a sum-type `UniqueDomain`. At the very least, this should help make the code a little more self-documenting ''and'' prevent accidental overlap in the choice of bits to identify the domain. Since the purpose of `Unique`s is to provide ''fast'' comparison for different types of things, the redesign should remain performance concious. With this in mind, keeping the `UniqueDomain` and the integer-part explicitly in the type
{{{
data Unique = MkUnique UniqueDomain Word
}}}
seems unwise, but by choosing
{{{
newtype Unique = MkUnique Word
}}}
we win the ability to automatically derive things and should also be able to test how far optimisation has come in the past 20+ years; does default boxing with `newtype`-style wrapping have (nearly) the same performance as manual unboxing? This should follow from the tests.



