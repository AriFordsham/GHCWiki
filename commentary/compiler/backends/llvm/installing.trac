[[PageOutline]]
= Installing & Using the LLVM Back-end =

The patch needed for GHC can be found at:

 * GHC Patch: http://www.cse.unsw.edu.au/~davidt/downloads/ghc-llvmbackend-full.dpatch

== Installing ==

Apply the darcs patch linked above to GHC head. This will make some changes across GHC, with the bulk of the new code ending up in 'compiler/llvmGen'.

To build GHC you need to add one flags to build.mk, it is:

{{{
GhcEnableTablesNextToCode = NO
}}}

The LLVM code generator doesn't support at this time the [wiki:Commentary/Rts/Storage/HeapObjects?redirectedfrom=Commentary/Rts/HeapObjects#TABLES_NEXT_TO_CODE TABLES_NEXT_TO_CODE] optimisation due to limitations with LLVM. As long as its disabled the build system will detect this an automatically add in the LLVM backend.

=== LLVM ===

You will also need LLVM installed on your computer to use the back-end. If you wish to simply use an unregistered build of GHC, then the back-end should work with any standard LLVM version. If you wish to use a registered build of GHC however, then you may need to apply a patch to LLVM and build it yourself:

 * '''Version 2.7''': (or later) natively support GHC, no patch is needed.
 * ~~'''Version 2.6''': Apply this [http://www.cse.unsw.edu.au/~davidt/downloads/llvm-ghc-callconv-2.6.patch patch] to the source code.~~
 * ~~'''Version 2.5''': Apply this [http://www.cse.unsw.edu.au/~davidt/downloads/llvm-ghc-callconv-2.5.patch patch] to the source code.~~

'''Just use LLVM 2.7. While the above patches do work the LLVM backend now uses the features of 2.7 and higher.'''

The patches can be applied with:
{{{
$ cd llvm
$ patch -p0 -i <patch file>
}}}

LLVM is very easy to build and install. It can be done as follows:

{{{
$ svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm
$ cd llvm
$ ./configure --enable-optimized # probably also want to set --prefix
$ make
$ make install
}}}


== Using ==

Once GHC is built, you can trigger GHC to use the LLVM back-end with the {{{-fllvm}}} flag. There is also a new {{{-ddump-llvm}}} which will dump out the LLVM IR code generated (must be used in combination with the {{{-fllvm}}} flag. (or use the {{{-keep-tmp-files}}} flag).

{{{ghc --info}}} should also now report that it includes the llvm code generator.

The [http://hackage.haskell.org/package/ghc-core ghc-core] tool also supports the llvm backend, and will display the generated assembly code for your platform.


== Supported Platforms & Correctness ==

 * Linux x86-32/x86-64 are currently well supported. The back-end can pass the test suite and build a working version of GHC (bootstrap test).
 * Mac OS X 10.5 currently has a rather nasty bug with any dynamic lib calls (all libffi stuff) [due to the stack not being 16byte aligned when the calls are made as required by OSX ABI for the curious]. Test suite passes except for most the ffi tests.
 * Windows 32bit: The backend works for most things but no extensive testing or support yet.
 * Other platforms haven't been tested at all. As using the back-end with a registered build of GHC requires a modified version of LLVM, people wanting to try it out on those platforms will need to either make the needed changes to LLVM themselves, or use an unregistered build of GHC which will work with a vanilla install of LLVM. (A patch for LLVM for x86 is linked to below.)


== Performance ==

(All done on linux/x86-32)

A quick summary of the results are that for the 'nofib' benchmark suite, the LLVM code generator was 3.8% slower than the NCG (the C code generator was 6.9% slower than the NCG). The DPH project includes a benchmark suite which I (David Terei) also ran and for this type of code using the LLVM back-end shortened the runtime by an average of 25% compared to the NCG. Also, while not included in my thesis paper as I ran out of time, I did do some benchmarking with the 'nobench' benchmark suite. It gave performance ratios for the back-ends of around:

||NCG || 1.11||
||C || 1.05||
||LLVM || 1.14||

A nice demonstration of the improvements the LLVM back-end can bring to some code though can be see at http://donsbot.wordpress.com/2010/02/21/smoking-fast-haskell-code-using-ghcs-new-llvm-codegen/
