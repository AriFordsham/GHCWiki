

= GHC Commentary: The Code Generator =

[[GhcFile(compiler/codeGen)]]

See [wiki:Commentary/Rts/Storage The Storage Manager] for the [wiki:Commentary/Rts/Storage/Stack Layout of the stack].


== Storage manager representations ==

The code generator needs to know the layout of heap objects, because it generates code that accesses and constructs those heap objects.  The runtime also needs to know about the layout of heap objects, because it contains the garbage collector.  How can we share the definition of storage layout such that the code generator and the runtime both have access to it, and so that we don't have to keep two independent definitions in sync?

Currently we solve the problem this way:

 * C types representing heap objects are defined in the C header files, see for example [[GhcFile(includes/Closures.h)]].

 * A C program, [[GhcFile(includes/mkDerivedConstants.c)]],  `#includes` the runtime headers.
   This program is built and run when you type `make` or `make boot` in `includes/`.  It is
   run twice: once to generate `includes\DerivedConstants.h`, and again to generate 
   `includes/GHCConstants.h`.

 * The file `DerivedConstants.h` contains lots of `#defines` like this:
{{{
#define OFFSET_StgTSO_why_blocked 18
}}}
   which says that the offset to the why_blocked field of an `StgTSO` is 18 bytes.  This file
   is `#included` into [[GhcFile(includes/Cmm.h)]], so these offests are available to the
   [wiki:Commentary/Rts/Cmm hand-written .cmm files].

 * The file `GHCConstants.h` contains similar definitions:
{{{
oFFSET_StgTSO_why_blocked = 18::Int
}}}
  This time the definitions are in Haskell syntax, and this file is `#included` directly into
  [[GhcFile(compiler/main/Constants.lhs)]].  This is the way that these offsets are made
  available to GHC's code generator.

== Generated Cmm Naming Convention ==

See [[GhcFile(compiler/cmm/CLabel.hs)]]

Labels generated by the code generator are of the form {{{<name>_<type>}}}
where {{{<name>}}} is {{{<Module>_<name>}}} for external names and {{{<unique>}}} for
internal names. {{{<type>}}} is one of the following:

  info::                   Info table
  srt::                    Static reference table
  srtd::                   Static reference table descriptor
  entry::                  Entry code (function, closure)
  slow::                   Slow entry code (if any)
  ret::                    Direct return address    
  vtbl::                   Vector table
  <n>_alt::                Case alternative (tag n)
  dflt::                   Default case alternative
  btm::                    Large bitmap vector
  closure::                Static closure
  con_entry::              Dynamic Constructor entry code
  con_info::               Dynamic Constructor info table
  static_entry::           Static Constructor entry code
  static_info::            Static Constructor info table
  sel_info::               Selector info table
  sel_entry::              Selector entry code
  cc::                     Cost centre
  ccs::                    Cost centre stack

Many of these distinctions are only for documentation reasons.  For
example, _ret is only distinguished from _entry to make it easy to
tell whether a code fragment is a return point or a closure/function
entry.

== Modules ==
=== Primary Modules ===
  {{{CodeGen}}}:: Top level. Called by the {{{HscMain}}} module.
  {{{CgClosure}}}:: Called by {{{CodeGen}}} for top level bindings.
  {{{CgCon}}}:: Called by {{{CodeGen}}} for data types.

  {{{CgExpr}}}:: Called by {{{CgClosure}}} and {{{CgCon}}}.
    Since everything in STG is an expression, almost everything branches off from here.

  {{{CgMonad}}}:: The monad that most of codeGen operates inside
   * Reader
   * State
   * (could be Writer?)
   * fork
   * flatten

=== Memory and Register Management ===
 {{{CgBindery}}}::
   Module for {{{CgBindings}}} which maps variable names
   to all the volitile or stable locations where they are stored
   (e.g. register, stack slot, computed from other expressions, etc.)
   Provides the {{{addBindC}}}, {{{modifyBindC}}} and {{{getCgIdInfo}}} functions
   for adding, modifying and looking up bindings.

 {{{CgStackery}}}::
   Mostly utility functions for allocating and freeing stack slots.
   But also has things on setting up update frames.

 {{{CgHeapery}}}::
   Functions for allocating objects that appear on the heap such as closures and constructors.
   Also includes code for stack and heap checks and {{{emitSetDynHdr}}}.

=== Misc utilities ===
 {{{Bitmap}}}::
   Utility functions for making bitmaps (e.g. {{{mkBitmap}}} with type {{{[Bool] -> Bitmap}}})
 {{{ClosureInfo}}}::
   Stores info about closures and bindings.
   Includes information about memory layout, how to call a binding ({{{LambdaFormInfo}}})
   and information used to build the info table ({{{ClosureInfo}}}).
 {{{SMRep}}}::
   Storage manager representation of closures.
   Part of ClosureInfo but kept separate to "keep nhc happy."
 {{{CgUtils}}}:: TODO

=== Special runtime support ===
 {{{CgTicky}}}:: Ticky-ticky profiling
 {{{CgProf}}}:: Cost-centre profiling
 {{{CgHpc}}}:: Support for the Haskell Program Coverage (hpc) toolkit, inside GHC.
 {{{CgParallel}}}::
   Code generation for GranSim (GRAN) and parallel (PAR).
   All the functions are dead stubs except {{{granYield}}} and {{{granFetchAndReschedule}}}.

=== Not yet classified ===
Please help classify these if you know what they are.

 CgInfoTbls
 CgCallConv

 CgCase
 CgLetNoEscape

 CgPrimOp
 CgTailCall
 CgForeignCall
