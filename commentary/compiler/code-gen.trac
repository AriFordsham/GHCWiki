

= GHC Commentary: The Code Generator =

[[GhcFile(compiler/codeGen)]]

== Storage manager representations ==

The code generator needs to know the layout of heap objects, because it generates code that accesses and constructs those heap objects.  The runtime also needs to know about the layout of heap objects, because it contains the garbage collector.  How can we share the definition of storage layout such that the code generator and the runtime both have access to it, and so that we don't have to keep two independent definitions in sync?

Currently we solve the problem this way:

 * C types representing heap objects are defined in the C header files, see for example [[GhcFile(includes/Closures.h)]].

 * A C program, [[GhcFile(includes/mkDerivedConstants.c)]],  `#includes` the runtime headers.
   This program is built and run when you type `make` or `make boot` in `includes/`.  It is
   run twice: once to generate `includes\DerivedConstants.h`, and again to generate 
   `includes/GHCConstants.h`.

 * The file `DerivedConstants.h` contains lots of `#defines` like this:
{{{
#define OFFSET_StgTSO_why_blocked 18
}}}
   which says that the offset to the why_blocked field of an `StgTSO` is 18 bytes.  This file
   is `#included` into [[GhcFile(includes/Cmm.h)]], so these offests are available to the
   [wiki:Commentary/Rts/Cmm hand-written .cmm files].

 * The file `GHCConstants.h` contains similar definitions:
{{{
oFFSET_StgTSO_why_blocked = 18::Int
}}}
  This time the definitions are in Haskell syntax, and this file is `#included` directly into
  [[GhcFile(compiler/main/Constants.lhs)]].  This is the way that these offsets are made
  available to GHC's code generator.

== Generated Cmm Naming Convention ==

See [[GhcFile(compiler/cmm/CLabel.hs)]]

Labels generated by the code generator are of the form {{{<name>_<type>}}}
where {{{<name>}}} is {{{<Module>_<name>}}} for external names and {{{<unique>}}} for
internal names. {{{<type>}}} is one of the following:

  info::                   Info table
  srt::                    Static reference table
  srtd::                   Static reference table descriptor
  entry::                  Entry code (function, closure)
  slow::                   Slow entry code (if any)
  ret::                    Direct return address    
  vtbl::                   Vector table
  <n>_alt::                Case alternative (tag n)
  dflt::                   Default case alternative
  btm::                    Large bitmap vector
  closure::                Static closure
  con_entry::              Dynamic Constructor entry code
  con_info::               Dynamic Constructor info table
  static_entry::           Static Constructor entry code
  static_info::            Static Constructor info table
  sel_info::               Selector info table
  sel_entry::              Selector entry code
  cc::                     Cost centre
  ccs::                    Cost centre stack

Many of these distinctions are only for documentation reasons.  For
example, _ret is only distinguished from _entry to make it easy to
tell whether a code fragment is a return point or a closure/function
entry.
