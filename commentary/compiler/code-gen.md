# GHC Commentary: The Code Generator

[compiler/codeGen](/trac/ghc/browser/ghc/compiler/codeGen)


See [The Storage Manager](commentary/rts/storage) for the [Layout of the stack](commentary/rts/storage/stack).

## Storage manager representations


The code generator needs to know the layout of heap objects, because it generates code that accesses and constructs those heap objects.  The runtime also needs to know about the layout of heap objects, because it contains the garbage collector.  How can we share the definition of storage layout such that the code generator and the runtime both have access to it, and so that we don't have to keep two independent definitions in sync?


Currently we solve the problem this way:

- C types representing heap objects are defined in the C header files, see for example [includes/Closures.h](/trac/ghc/browser/ghc/includes/Closures.h).

- A C program, [includes/mkDerivedConstants.c](/trac/ghc/browser/ghc/includes/mkDerivedConstants.c),  `#includes` the runtime headers.
  This program is built and run when you type `make` or `make boot` in `includes/`.  It is
  run twice: once to generate `includes\DerivedConstants.h`, and again to generate 
  `includes/GHCConstants.h`.

- The file `DerivedConstants.h` contains lots of `#defines` like this:

  ```wiki
  #define OFFSET_StgTSO_why_blocked 18
  ```

  which says that the offset to the why_blocked field of an `StgTSO` is 18 bytes.  This file
  is `#included` into [includes/Cmm.h](/trac/ghc/browser/ghc/includes/Cmm.h), so these offests are available to the
  [hand-written .cmm files](commentary/rts/cmm).

- The file `GHCConstants.h` contains similar definitions:

  ```wiki
  oFFSET_StgTSO_why_blocked = 18::Int
  ```

  This time the definitions are in Haskell syntax, and this file is `#included` directly into
  [compiler/main/Constants.lhs](/trac/ghc/browser/ghc/compiler/main/Constants.lhs).  This is the way that these offsets are made
  available to GHC's code generator.

## Generated Cmm Naming Convention


See [compiler/cmm/CLabel.hs](/trac/ghc/browser/ghc/compiler/cmm/CLabel.hs)


Labels generated by the code generator are of the form `<name>_<type>`
where `<name>` is `<Module>_<name>` for external names and `<unique>` for
internal names. `<type>` is one of the following:

<table><tr><th>info</th>
<td>Info table
</td></tr>
<tr><th>srt</th>
<td>Static reference table
</td></tr>
<tr><th>srtd</th>
<td>Static reference table descriptor
</td></tr>
<tr><th>entry</th>
<td>Entry code (function, closure)
</td></tr>
<tr><th>slow</th>
<td>Slow entry code (if any)
</td></tr>
<tr><th>ret</th>
<td>Direct return address    
</td></tr>
<tr><th>vtbl</th>
<td>Vector table
</td></tr>
<tr><th>\<n\>_alt</th>
<td>Case alternative (tag n)
</td></tr>
<tr><th>dflt</th>
<td>Default case alternative
</td></tr>
<tr><th>btm</th>
<td>Large bitmap vector
</td></tr>
<tr><th>closure</th>
<td>Static closure
</td></tr>
<tr><th>con_entry</th>
<td>Dynamic Constructor entry code
</td></tr>
<tr><th>con_info</th>
<td>Dynamic Constructor info table
</td></tr>
<tr><th>static_entry</th>
<td>Static Constructor entry code
</td></tr>
<tr><th>static_info</th>
<td>Static Constructor info table
</td></tr>
<tr><th>sel_info</th>
<td>Selector info table
</td></tr>
<tr><th>sel_entry</th>
<td>Selector entry code
</td></tr>
<tr><th>cc</th>
<td>Cost centre
</td></tr>
<tr><th>ccs</th>
<td>Cost centre stack
</td></tr></table>


Many of these distinctions are only for documentation reasons.  For
example, _ret is only distinguished from _entry to make it easy to
tell whether a code fragment is a return point or a closure/function
entry.

## Modules

<table><tr><th>`CodeGen`</th>
<td>Top level. Called by the `HscMain` module.
</td></tr></table>

<table><tr><th>`CgMonad`</th>
<td>The monad that most of codeGen operates inside

- Reader
- State
- (could be Writer?)
- fork
- flatten

</td></tr></table>

<table><tr><th>`CgExpr`</th>
<td>Seems to be the core function since everything in STG is an expression
</td></tr></table>

### Misc utilities

<table><tr><th>Bitmap</th>
<td>
Utility functions for making bitmaps (e.g. `mkBitmap` with type `[Bool] -> Bitmap`)
</td></tr>
<tr><th>ClosureInfo</th>
<td>
Stores info about the memory layouts of closures
</td></tr>
<tr><th>SMRep</th>
<td>
Storage manager representation of closures.
Part of ClosureInfo but kept separate to "keep nhc happy."
</td></tr>
<tr><th>CgUtils</th>
<td>TODO</td></tr></table>

### Special runtime support

<table><tr><th>CgTicky</th>
<td>Ticky-ticky profiling
</td></tr>
<tr><th>CgProf</th>
<td>Cost-centre profiling
</td></tr>
<tr><th>CgHpc</th>
<td>Support for the Haskell Program Coverage (hpc) toolkit, inside GHC.
</td></tr>
<tr><th>CgParallel</th>
<td>
Code generation for GranSim (GRAN) and parallel (PAR).
All the functions are dead stubs except `granYield` and `granFetchAndReschedule`.
</td></tr></table>

### Not yet classified


Please help classify these if you know what they are.

>
> CgBindery
> CgHeapery
> CgStackery

>
> CgClosure
> CgCon

>
> CgCase
> CgLetNoEscape

>
> CgInfoTbls
> CgCallConv

>
> CgPrimOp
> CgTailCall
> CgForeignCall
