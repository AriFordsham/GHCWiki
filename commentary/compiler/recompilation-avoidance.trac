= Recompilation checking in GHC =

== What is recompilation checking? ==

When GHC is compiling a module, it tries to determine early on whether

 * The object file (or byte-code in the case of GHCi) and [wiki:Commentary/Compiler/IfaceFiles interface file] exist from a previous compilation
 * Recompilation is sure to produce exactly the same results, so it
   is not necessary.

If both of these hold, GHC stops compilation early, because the existing object code and interface are still valid.  In GHCi and `--make`, we must generate the `ModDetails` from the `ModIface`, but this is easily done by calling `MkIface.typecheckIface`.

== Example ==

Let's use a running example to demonstrate the issues.  We'll have
four modules with dependencies like this:

{{{
      A
     / \
    B   C
     \ /
      D
}}}

`A.hs`:

{{{
module A where
import B
import C

a = print (f 2)
}}}

`B.hs`:

{{{
module B (f) where
import D
}}}

`C.hs`:

{{{
module C where
import D
}}}

`D.hs`:
{{{
module D (T, f, h) where

data T a b = C1 a | C2 b

f :: Int -> Int
f x = h x

h :: Int -> Int
h x = x + 3
}}}


== Why do we need recompilation checking? ==

=== `make` ===

`make` works by checking the timestamps on dependencies and
recompiling things when the dependencies are newer.  Dependency lists
for `make` look like this:

{{{
# DO NOT DELETE: Beginning of Haskell dependencies
D.o : D.hs
B.o : B.hs
B.o : D.hi
C.o : C.hs
C.o : D.hi
A.o : A.hs
A.o : C.hi
A.o : B.hi
# DO NOT DELETE: End of Haskell dependencies
}}}

Only the `.hi` files of the ''direct imports'' of a module are listed.
For example, `A.o` depends on `C.hi` and `B.hi`, but not `D.hi`.
Nevertheless, if D is modified, we might need to recompile A.  How
does this happen?  

  * first, make will recompile D because its source file has changed,
    generating a new `D.o` and `D.hi`.

  * If after recompiling D, we notice that its interface is the same
    as before, there is no need to modify the `.hi` file.  If the `.hi`
    file is not modified by the compilation, then `make` will notice
    and not recompile `B` or `C`.  This is an important optimisation.

  * Suppose the change to `D` did cause a change in the interface
    (e.g. the type of `f` changed).  Now, `make` will recompile both
    `B` and `C`.  Now, suppose that the interfaces to `B` and `C`
    remain the same: B's interface says only that it re-exports `D.f`,
    so the fact that `f` has a new type does not affect `B`'s
    interface.  

  * Now, `A`'s dependencies are unchanged, so `A` will not be
    recompiled.  But this is wrong: `A` might depend on something from
    `D` that was re-exported via `B` or `C`, and therefore need
    recompiling.

To ensure that `A` is recompiled, we therefore have two options:

  1. arrange that make knows about the dependency of A on D.

  2. arrange to touch `B.hi` and `C.hi` even if they haven't changed.

GHC currently does (2), more about that in a minute.

Why not do (1)?  I don't know - perhaps it was hard at the time GHC's
recompilation checker was designed, because the make dependencies were
generated by a separate Perl script, which worked by simply grepping
for `import`.  We consider this option later.

In addition to correctness (recompile when necessary), we also want to
avoid unnecessary recompilation as far as possible.
Make only knows about very coarse-grained dependencies.  For example,
it doesn't know that changing the type of `D.f` can have no effect on
`C`, so `C` does not in fact need to be recompiled, because to do so
would generate exactly the same `.o` and `.hi` files as last time.
GHC does have enough information to figure this out, so when GHC is
asked to recompile a module it invokes the ''recompilation checker''
to determine whether recompilation can be avoided in this case.

== How does it work? ==

An [wiki:Commentary/Compiler/IfaceFile interface file] contains:

 * The module ''version'' (more about this below)
 * ''exports'': what the module exports
 * ''decls'': what the module defines
 * ''dependencies'' and ''usages'': what the module depends on
 * various other stuff, but the above are the important bits

The module version starts at 1, and is increased each time the module
is compiled and either the ''exports'' or ''decls'' changes.

=== Deciding whether to recompile ===

If we already have an object file and interface file for a module, we
might not have to recompile it, if we can be sure the results will be
the same as last time.

 * If the source file has changed since the object file was created,
   we better recompile.

 * If anything else has changed in a way that would affect the results
   of compiling this module, we must recompile.

In order to determine the second point, we look at the
''dependencies'' and ''usages'' fields of the old interface file.  The
dependencies contains:

 * ''dep_mods'': Transitive closure of home-package modules that are
   imported by this module.  That is, all modules below the current
   one in the dependency graph.

 * ''dep_pkgs'': Transitive closure of packages depended on by this
   module, or by any module in ''dep_mods''.

 * other less important stuff.

First, the direct imports of the current module are resolved to
`Module`s using `findModule` (a `Module` contains a module name and a
package identifier).  If any of those `Module`s are not listed amongst
the dependencies of the old interface file, then either:

 * an exposed package has been upgraded
 * we are compiling with different package flags
 * a home module that was shadowing a package module has been removed
 * a new home module has been added that shadows a package module

and we must recompile.

Second, the ''usages'' of the module are checked.  The usages in the
interface file contains a list of every name that was ''used'' during
typechecking: that is, everything external that is referred to by the
source code.

The interface files for everything in the usages are read (they'll
already be in memory if we're doing `--make`), and the current
versions for each of these entities checked against the usages from
the old interface file.  If any of these versions has changed, the
module must be recompiled.

=== Example ===

There are some tricky cases to consider.

Suppose we change the definition of `D.f` in the example, and make it
{{{
f x = h x + 1
}}}
Now, ultimately we need to recompile `A`, because it might be using
an inlined copy of the old `D.f`, which it got via `B`.

It works like this: 

 * `D` is recopmiled; the version of `D.f` increases
 * `B` is considered; it recorded a usage on the old `D.f`, so
   gets recompiled, and now its interface records a usage on the new `D.f`
 * `C` is considered; it doesn't need to be recompiled.
 * `A` is considered (if we're using make, this is because `B.hi`
   changed); it recorded a usage on the old `D.f`, and so gets
   recompiled.

Now a slightly more tricky case: suppose we add an INLINE pragma to
`D.f` (this is a trick to prevent GHC from inlining `D.h`, so that we
can demonstrate dependencies between unfoldings).  The code for D.hs
is now

{{{
{-# INLINE f #-}
f :: Int -> Int
f x = h x + 1

h :: Int -> Int
h x = x + 3
}}}

Looking at the interface file we can see what happened (snipped slightly):

{{{
$ ghc --show-iface D.hi
interface main:D 3 6081 where
export main:D T f h
module dependencies:
package dependencies: base
3 f :: GHC.Base.Int -> GHC.Base.Int
    {- Arity: 1 HasNoCafRefs Strictness: U(L)m
       Unfolding: (__inline_me (\ x :: GHC.Base.Int ->
                                GHC.Base.plusInt (D.h x) (GHC.Base.I# 1))) -}
h :: GHC.Base.Int -> GHC.Base.Int
  {- Arity: 1 HasNoCafRefs Strictness: U(L)m
     Unfolding: (\ x :: GHC.Base.Int ->
                 case @ GHC.Base.Int x of wild { GHC.Base.I# x1 ->
                 GHC.Base.I# (GHC.Prim.+# x1 3) }) -}
data T a b
    RecFlag NonRecursive
    Generics: no
    = C1 :: forall a b. a -> T a b Stricts: _ |
      C2 :: forall a b. b -> T a b Stricts: _
    FamilyInstance: none
}}}

Note from the first line that this is version 3.  The first change was
to the definition of `D.f` above, and the second change we made just
now was to add the INLINE pragma to `D.f`.  The version of `D.f` is
also 3 (it has changed twice), and the version of `D.h` is still 1
(the version number is omitted if it is 1).

Note that the unfolding of `D.f` mentions `D.h`.

Now, let's modify `D.h`, and look at the interface file again:

{{{
$ ghc -O --show-iface D.hi
interface main:D 4 6081 where
export main:D T f h
module dependencies:
package dependencies: base
4 h :: GHC.Base.Int -> GHC.Base.Int
    {- Arity: 1 HasNoCafRefs Strictness: U(L)m
       Unfolding: (\ x :: GHC.Base.Int ->
                   case @ GHC.Base.Int x of wild { GHC.Base.I# x1 ->
                   GHC.Base.I# (GHC.Prim.+# x1 4) }) -}
4 f :: GHC.Base.Int -> GHC.Base.Int
    {- Arity: 1 HasNoCafRefs Strictness: U(L)m
       Unfolding: (__inline_me (\ x :: GHC.Base.Int ->
                                GHC.Base.plusInt (D.h x) (GHC.Base.I# 1))) -}
data T a b
    RecFlag NonRecursive
    Generics: no
    = C1 :: forall a b. a -> T a b Stricts: _ |
      C2 :: forall a b. b -> T a b Stricts: _
    FamilyInstance: none
}}}

The version of `D.h` jumped to 4 (things that change get the new
module version, rather than just increasing by 1).

However, the version of `D.f` also changed.  This is vital, because
anything that referred to `D.f` must be recompiled, because it may now
see the new unfolding for `D.h`.

In summary:

 * The version of an entity is bumped whenever either 
   * the entity's definition changed, or
   * the version of anything that the definition refers to changed.
 * This means that when recording usages, we only have to record
   usages on things that are directly mentioned, not their
   transitive closure.

== Alternative design choices ==

=== ghc -M should record transitive dependencies ===

We wouldn't have to record usages on entities that are just
re-exported, and we might get less recompilation.

=== fingerprints instead of versions ===

=== module-granularity instead of declaration-granularity ===
