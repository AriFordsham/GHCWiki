= The new Generic Deriving mechanism (ongoing work) =

GHC includes a new (in 2010) mechanism to let you write generic functions.  It is described in [http://www.dreixel.net/research/pdf/gdmh_nocolor.pdf A generic deriving mechanism for Haskell], by Magalhães, Dijkstra, Jeuring and Löh.  This page sketches the specifics of the implementation; we assume you have read the paper.

This mechanism replaces the [http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/generic-classes.html previous generic classes implementation]. The code is in a branch of GHC; you can get it with `darcs get http://darcs.haskell.org/ghc-generic-11Oct10/ghc`.

== Main components ==

 * `TcDeriv.tcDeriving` generates an `InstInfo` for each data type that fulfills the `isRep0` predicate. This `InstInfo` is the `Representable0` instance for that type, allowing it to be handled generically (by kind-`*` generic functions).

 * The representation types and core functionality of the library live on `GHC.Generics` (on the `ghc-prim` package).

 * Many names have been added as known in `prelude/PrelNames`

 * Most of the code generation is handled by `types/Generics`

== What already works ==

 * `Representable0` instances are automatically generated when `-XGenerics` is enabled.

== To do ==
 * Remove all of the old deriving mechanism stuff

 * Properly deal with fixity and isTuple information for constructors

 * Generate `Representable1` instances

 * What about base types like `[]`, `Maybe`, etc.?

 * Generic instances
  * Add `deriving` as a keyword. This replaces the `DERIVABLE` pragma from the UHC implementation, and is attached to a default method on a class declaration.
  * Change the `Class` definition to allow for generic defaults (in addition to standard defaults).
  * Generate default instances for representable types which derive generic classes.

== Testing ==

 * For temporary testing, a file test/Main.hs is available with sample datatypes.

== Problems/questions ==

 * Currently, in `TcDeriv.genGenericRepBind` we generate instances using `mkLocalInstance`. Is this right, or should we use `mkImportedInstance` instead?  SLPJ: mkLocalInstance: it's as if the instance declaration was in this module, right?
