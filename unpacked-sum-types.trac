This page explains the motivation and implementation of unpacking for sum types.

== Motivation ==

GHC does a good job of unpacking product types. Given a declaration like

{{{
data T1 a b = C1 a b
data T2 a b = C2 {-# UNPACK #-} !(T1 a b)
}}}

`C2` will have a representation where all the overhead of the `C1` constructor, both the pointer to it in the `C2` constructor and the info table pointer in the `C1` constructor, has been removed. This saves two words and one indirection  compared to a packed representation, which uses five words.

Unfortunately, a similar example using sum types cannot be unpacked today:

{{{
data T1 a = Some a | None
data T2 a = C !(T1 a)  -- Cannot UNPACK here
}}}

Here the representation of the `C` constructor will contain a pointer to e.g. the `Some` constructor. The `Some` constructor will be a separate heap object and thus needs one word to store its info table pointer.

In this example there is an alternative, unpacked representation that is more memory efficient and has fewer indirections. We could store a constructor tag together with the union of the fields of `T1` inside `C`. Conceptually the memory layout would look like this (in practice we might group pointer and non-pointer fields together):

|| C header || T1 constructor tag || Fields of `Some` || Fields of `None` ||

(In this case `None` has no fields.)

This representation saves one word and one indirection compared to the packed representation, which uses four words.

== Implementation ==

=== Computing the representation ===

There are several possible representations we could chose from. Briefly they are:

 * Store a constructor tag and the union of all the fields.
 * Store a constructor tag and the maximum number of needed pointer and non-pointer fields.

The former is simpler, especially when it comes to represent the types of the fields (since there's no aliasing), but the latter is more efficient.

=== Avoiding reboxing in case statements ===

Given

{{{
data T1 = C1 x_1..x_n | C2 y_1..y_n
data T2 = C {-# UNPACK #-} !T1
}}}

we might worried that doing

{{{
case t2 of
    C t1 -> case t1 of
        C1 x_1..x_n -> ...
        C2 y_1..y_n -> ...
}}}

would require that we need to allocate a `C1` or `C2` constructor just to deconstruct it again. Fortunately we should be able to avoid that because when we construct either `C1` or `C2` from the unpacked representation in `C` we'd do that we a case, like so:

{{{
unpack (C tag# x_1..x_n y_1..y_n) = case tag# of
    0# -> C1 x_1..x_n
    1# -> C2 y_1..y_n
}}}

This gives us

{{{
case t2 of
    C t1 -> case t1 of
        C1 x_1..x_n -> ... x_1..x_n ...
        C2 y_1..y_n -> ... y_1..y_n ...

===>

case t2 of
    C t1 -> case unpack t2 of
        C1 x_1..x_n -> ... x_1..x_n ...
        C2 y_1..y_n -> ... y_1..y_n ...

===> (inline unpack)

case t2 of
    C tag# x_1..x_n y_1..y_n -> (case tag# of
        0# -> C1 x_1..x_n
        1# -> C2 y_1..y_n) of
            C1 x_1..x_n -> ... x_1..x_n ...
            C2 y_1..y_n -> ... y_1..y_n ...

===> (case-of-case and case of known constructor)

case t2 of
    C tag# x_1..x_n y_1..y_n -> case tag# of
        0# -> ... x_1..x_n ...
        1# -> ... y_1..y_n ...
}}}