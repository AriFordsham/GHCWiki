= A plan for type-indexed type representations

This is Ben Gamari's plan for moving ahead with the type-indexed `Typeable`
scheme, described most recently in
[[http://research.microsoft.com/en-us/um/people/simonpj/papers/haskell-dynamic|A reflection on types]].

[[PageOutline]]

== `Data.Typeable`

The user-visible interface of `Data.Typeable` will look like this,

{{{#!hs
-- The user-facing interface
module Data.Typeable where

class Typeable (a :: k)

-- This is how we get the representation for a type
typeRep :: forall (a :: k). Typeable a => TypeRep a 

-- This is merely a record of some metadata about a type constructor.
-- One of these is produced for every type defined in a module during its
-- compilation.
--
-- This should also carry a fingerprint; to address #7897 this fingerprint
-- should hash not only the name of the tycon, but also the structure of its
-- data constructors
data TyCon

tyConPackage :: TyCon -> String
tyConModule :: TyCon -> String
tyConName :: TyCon -> String

-- A runtime type representation with O(1) access to a fingerprint.
data TypeRep (a :: k)

instance Show (TypeRep a)

-- Since TypeRep is indexed by its type and must be a singleton we can trivially
-- provide these
instance Eq (TTypeRep a)  where (==) _ _    = True
instance Ord (TTypeRep a) where compare _ _ = EQ

-- While TypeRep is abstract, we can pattern match against it:
pattern TRApp :: forall k2 (fun :: k2). ()
              => forall k1 (a :: k1 -> k2) (b :: k1). (fun ~ a b)
              => TypeRep a -> TypeRep b -> TypeRep fun

-- Open question: Should this pattern include the kind of the constructor?
-- It seems you often need it.
pattern TRCon :: forall k (a :: k). TyCon -> TypeRep a

-- decompose functions
pattern TRFun :: forall fun. ()
              => forall arg res. (fun ~ (arg -> res))
              => TypeRep arg
              -> TypeRep res
              -> TypeRep fun

-- We can also request the kind of a type
tTypeRepKind :: TypeRep (a :: k) -> TypeRep k

-- and compare types
eqTypeRep  :: forall k (a :: k) (b :: k).
              TypeRep a -> TypeRep b -> Maybe (a :~: b)
eqTypeRep' :: forall k1 k2 (a :: k1) (b :: k2).
              TypeRep a -> TypeRep b -> Maybe (a :~~: b)

-- it can also be useful to quantify over the type such that we can, e.g.,
-- index a map on a type
data TypeRepX where
    TypeRepX :: TypeRep a -> TypeRepX

-- these have some useful instances
instance Eq TypeRepX
instance Ord TypeRepX
instance Show TypeRepX

-- A `TypeRep a` gives rise to a `Typeable a` instance without loss of
-- confluence.
withTypeable :: TypeRep a -> (Typeable a => b) -> b
withTypeable = undefined

-- We can also allow the user to build up his own applications
mkTrApp :: forall k1 k2 (a :: k1 -> k2) (b :: k1).
           TTypeRep (a :: k1 -> k2)
        -> TTypeRep (b :: k1)
        -> TTypeRep (a b)

-- However, we can't (easily) allow instantiation of TyCons since we have
-- no way of producing the kind of the resulting type...
--mkTrCon :: forall k (a :: k). TyCon -> [TypeRep] -> TTypeRep a
}}}

== The representation serialization problem

Serialization of type representations is a bit tricky in this new world. Let's
say that we want to serialize (say, using the `binary` package), for instance, a
type-indexed map,

{{{#!hs
data TMap a
lookup :: TypeRepX -> TMap a -> Maybe a
insert :: TypeRepX -> a -> TMap a -> TMap a

-- we want to support these operations...
getTMap :: Binary a => Get (TMap a)
putTMap :: Binary a => TMap a -> Put
}}}

This is the sort of usage we might see in, for instance, the `Shake` build system.

=== Serializing `TypeRep`

Of course in order to provide `getTMap` and `putTMap` we need to be able to both
serialize and deserialize `TypeRepX`s. Serialization poses no particular issue.
For instance, we might write,
{{{#!hs
instance Binary TyCon

putTypeRep :: TypeRep a -> Put
putTypeRep tr@(TRCon tc) = do put 0
                              put tc
                              putTypeRep (typeRepKind tr) 
putTypeRep (TRApp f x)   = do put 1
                              putTypeRep f
                              putTypeRep x

putTypeRepX :: TypeRepX -> Put
putTypeRepX (TypeRepX rep) = putTypeRep rep
}}}
That was easy.

Now let's try deserialization.

=== Deserialization

We first need to consider which of these two types, `TypeRep` and `TypeRepX`, we want to imp

First, we need to define how deserialization should behave. For instance, defining
{{{#!hs
getTypeRep :: Get (TypeRep a)
}}}
is a non-starter as we have no way to verify that the representation that we
read plausibly represents the type `a` that the user requests.

For this we need more information: a `Typeable` dictionary,
{{{#!hs
getTypeRep :: TypeRep a -> Get (TypeRep a)
getTypeRep ty = do
    tag <- get :: Get Word8
    case tag of
        0 | TRCon con <- ty  -> do
            con' <- get
            when (con' /= con) $ fail "Binary: Mismatched type constructors"
            getTypeRep (typeRepKind ty)
        1 | TRApp rep_f rep_x <- ty  -> do
            getTypeRep rep_f
            getTypeRep rep_x
    pure ty
}}}
Note how here we aren't even constructing a new representation; we are merely
verifying that what we deserialize matches the representation that we expect.
Of course, the fact that we must know the type we are trying to deserialize
means that `getTypeRep` isn't terribly useful on its own; it certainly won't
help us to deserialize a `TMap`.

Then what of `TypeRepX`? We clearly can't use the `getTypeRep` defined above
since it requires that we already know which type we expect.
Furthermore, any attempt
{{{#!hs
getTypeRepX :: Get TypeRep
getTypeRepX ty = do
    rep <- getTypeRep'
    pure $ TypeRepX (rep :: TypeRep a)
  where
    getTypeRep' :: Get (TypeRep a)
    getTypeRep' = do
        tag <- get :: Get Word8
        case tag of
            0 | TRCon con <- ty  -> do
                con' <- get
                rep_k <- getTypeRepX
                getTypeRep rep_k
            1 | TRApp rep_f rep_x <- ty  -> do
                getTypeRepX rep_f
                getTypeRepX rep_x
        pure ty
      where rep_k = typeRepKind ty
}}}

=== Through static data?

On might have the idea that the solution here may be to avoid encoding
representations at all: instead use GHC's existing support for static data, e.g.
add `TypeRep a` entries to the static pointer table for every known type. But of
course, this is unrealistic: we have no way of enumerating the types that must
be considered and even if we did, there would be very many of them.

=== Through an un-indexed representation?

The "give up" approach here is to simply project the type-indexed `TypeRep` onto
something that is totally untyped,
{{{#!hs
data TypeRepXX = TypeConXX TyCon
               | TypeAppXX TypeRepXX TypeRepXX

toTypeRep :: TypeRepXX -> Maybe (TypeRep a)
toTypeRepX :: TypeRepXX -> TypeRepX
fromTypeRep :: TypeRep a -> TypeRepXX
fromTypeRepX :: TypeRepX  -> TypeRepXX
}}}
`TypeRepXX` is now just plain old data, requiring nothing special for
serialization and deserialization. However, this gives us an awkward third
variety of type representation

== `Data.Dynamic`

`Dynamic` doesn't really change,
{{{#!hs
module Data.Dynamic where

-- Dynamic itself no longer needs to be abstract
data Dynamic where
    Dynamic :: TypeRep a -> a -> Dynamic

-- Construction
toDynR :: TypeRep a -> a -> Dynamic
toDyn  :: Typeable a => a -> Dynamic

-- Elimination
fromDynamicR :: TypeRep a -> Dynamic -> Maybe a
fromDynamic  :: Typeable a => Dynamic -> Maybe a

-- 
fromDynR :: TypeRep a -> Dynamic -> a -> a
fromDyn  :: Typeable a => Dynamic -> a -> a

-- Application
dynApp   :: Dynamic -> Dynamic -> Dynamic  -- Existing function; calls error on failure
                                           -- I think this should be deprecated
dynApply :: Dynamic -> Dynamic -> Maybe Dynamic
}}}

Ben Pierce also
[[https://ghc.haskell.org/trac/ghc/wiki/TypeableT#Data.Dynamic|suggested]] this
variant of `Dynamic`, which models a value of dynamic type "inside" of a known
functor. He p
{{{#!hs
data SDynamic s where
    SDynamic :: TypeRep a -> s a -> SDynamic s

toSDynR :: TypeRep a -> s a -> SDynamic s
toSDyn :: Typeable a => s a -> SDynamic s
fromSDynamicR :: TypeRep a -> SDynamic s -> Maybe (s a)
fromSDynamic :: Typeable a => SDynamic s -> Maybe (s a)
fromSDynR :: TypeRep a -> SDynamic s -> s a -> s a
fromSDyn :: Typeable a => SDynamic s -> s a -> s a
}}}
