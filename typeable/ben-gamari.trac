= A plan for type-indexed type representations

This is Ben Gamari's plan for moving ahead with the type-indexed `Typeable`
scheme, described most recently in
[[http://research.microsoft.com/en-us/um/people/simonpj/papers/haskell-dynamic/|A reflection on types]].

[[PageOutline]]

== `Type.Reflection`

The new type-indexed typeable machinery will be exposed via a new module
(`Type.Reflection` is chosen here, although this name is still up in the air;
`Reflection` in particular has an unfortunate conflict with Edward Kmett's `reflection`
library). The user-visible interface of `GHC.Reflection` will look like this,

{{{#!hs
-- The user-facing interface
module Type.Reflection where

class Typeable (a :: k)

-- This is how we get the representation for a type
typeRep :: forall (a :: k). Typeable a => TypeRep a 

-- This is merely a record of some metadata about a type constructor.
-- One of these is produced for every type defined in a module during its
-- compilation.
--
-- This should also carry a fingerprint; to address #7897 this fingerprint
-- should hash not only the name of the tycon, but also the structure of its
-- data constructors
data TyCon

tyConPackage :: TyCon -> String
tyConModule :: TyCon -> String
tyConName :: TyCon -> String

-- A runtime type representation with O(1) access to a fingerprint.
data TypeRep (a :: k)

instance Show (TypeRep a)

-- Since TypeRep is indexed by its type and must be a singleton we can trivially
-- provide these
instance Eq (TypeRep a)  where (==) _ _    = True
instance Ord (TypeRep a) where compare _ _ = EQ

-- While TypeRep is abstract, we can pattern match against it.
-- This can be a bi-directional pattern (using mkTrApp for construction).
pattern TRApp :: forall k2 (fun :: k2). ()
              => forall k1 (a :: k1 -> k2) (b :: k1). (fun ~ a b)
              => TypeRep a -> TypeRep b -> TypeRep fun

-- Open question: Should this pattern include the kind of the constructor?
-- In practice you often need it when you need the TyCon
pattern TRCon :: forall k (a :: k). TyCon -> TypeRep a

-- decompose functions
pattern TRFun :: forall fun. ()
              => forall arg res. (fun ~ (arg -> res))
              => TypeRep arg
              -> TypeRep res
              -> TypeRep fun

-- We can also request the kind of a type
typeRepKind :: TypeRep (a :: k) -> TypeRep k

-- and compare types
eqTypeRep  :: forall k (a :: k) (b :: k).
              TypeRep a -> TypeRep b -> Maybe (a :~: b)
eqTypeRep' :: forall k1 k2 (a :: k1) (b :: k2).
              TypeRep a -> TypeRep b -> Maybe (a :~~: b)

-- it can also be useful to quantify over the type such that we can, e.g.,
-- index a map on a type
data TypeRepX where
    TypeRepX :: forall a. TypeRep a -> TypeRepX

-- these have some useful instances
instance Eq TypeRepX
instance Ord TypeRepX
instance Show TypeRepX

-- A `TypeRep a` gives rise to a `Typeable a` instance without loss of
-- confluence.
withTypeable :: TypeRep a -> (Typeable a => b) -> b
withTypeable = undefined

-- We can also allow the user to build up his own applications
mkTrApp :: forall k1 k2 (a :: k1 -> k2) (b :: k1).
           TypeRep (a :: k1 -> k2)
        -> TypeRep (b :: k1)
        -> TypeRep (a b)

-- However, we can't (easily) allow instantiation of TyCons since we have
-- no way of producing the kind of the resulting type...
--mkTrCon :: forall k (a :: k). TyCon -> [TypeRepX] -> TypeRep a
}}}

== Preserving compatibility with `Data.Typeable`

Note how above we placed the new type-indexed typeable in an entirely new
module. The goal of this is to preserve compatibility with the old
`Data.Typeable`. Notice how the old `Data.Typeable.TypeRep` is essentially
`TypeRepX` under the new scheme. This gives us a very nice compatibility story,
as noted by Richard Eisenberg,
{{{#!hs
module Data.Typeable
    ( I.Typeable
    , module Data.Typeable
    ) where

import Type.Reflection as I

-- | A quantified type representation.
type TypeRep = I.TypeRepX

typeOf :: forall a. Typeable a => a -> TypeRep
typeOf _ = I.typeRepX (Proxy :: Proxy a)

typeRep :: forall proxy a. Typeable a => proxy a -> TypeRep
typeRep = I.typeRepX

cast :: forall a b. (Typeable a, Typeable b) => a -> Maybe b
cast x
  | Just HRefl <- ta `I.eqTypeRep` tb = Just x
  | otherwise                         = Nothing
  where
    ta = I.typeRep :: I.TypeRep a
    tb = I.typeRep :: I.TypeRep b

eqT :: forall a b. (Typeable a, Typeable b) => Maybe (a :~: b)
eqT
  | Just HRefl <- ta `I.eqTypeRep` tb = Just Refl
  | otherwise                         = Nothing
  where
    ta = I.typeRep :: I.TypeRep a
    tb = I.typeRep :: I.TypeRep b

typeRepTyCon :: TypeRep -> TyCon

-- the old typeOfN exports from the pre-PolyKinds days can
-- also be trivially provided.
}}}

== The representation serialization problem

Serialization of type representations is a bit tricky in this new world. Let's
say that we want to serialize (say, using the `binary` package), for instance, a
type-indexed map,

{{{#!hs
data TMap a
lookup :: TypeRepX -> TMap a -> Maybe a
insert :: TypeRepX -> a -> TMap a -> TMap a

-- we want to support these operations...
getTMap :: Binary a => Get (TMap a)
putTMap :: Binary a => TMap a -> Put
}}}

This is the sort of usage we might see in, for instance, the `Shake` build system.

=== Serializing `TypeRep`

Of course in order to provide `getTMap` and `putTMap` we need to be able to both
serialize and deserialize `TypeRepX`s. Serialization poses no particular issue.
For instance, we might write,
{{{#!hs
instance Binary TyCon

putTypeRep :: TypeRep a -> Put
putTypeRep tr@(TRCon tc) = do put 0
                              put tc
                              putTypeRep (typeRepKind tr) 
putTypeRep (TRApp f x)   = do put 1
                              putTypeRep f
                              putTypeRep x

putTypeRepX :: TypeRepX -> Put
putTypeRepX (TypeRepX rep) = putTypeRep rep
}}}
That was easy.

Now let's try deserialization.

=== Deserialization

First, we need to define how deserialization should behave. For instance, defining
{{{#!hs
getTypeRep :: Get (TypeRep a)
}}}
is a non-starter as we have no way to verify that the representation that we
deserialize plausibly represents the type `a` that the user requests.

Instead, let's first consider `TypeRepX` (thanks to Adam Gundry for his guidance),
{{{#!hs
getTypeRepX :: Get TypeRepX
getTypeRepX = do
    tag <- get :: Get Word8
    case tag of
        0 -> do con <- get :: Get TyCon
                TypeRepX rep_k <- getTypeRepX
                case rep_k `eqTypeRep` (typeRep :: TypeRep Type) of
                    Just HRefl -> pure $ TypeRepX $ mkTrCon con rep_k
                    Nothing    -> fail "getTypeRepX: Kind mismatch"

        1 -> do TypeRepX f <- getTypeRepX
                TypeRepX x <- getTypeRepX
                case typeRepKind f of
                    TRFun arg _ | Just HRefl <- arg `eqTypeRep` x ->
                      pure $ TypeRepX $ mkTrApp f x
                    _ -> fail "getTypeRepX: Kind mismatch"
        _ -> fail "getTypeRepX: Invalid TypeRepX"
}}}
Note how we need to invoke type equality here to ensure,

 * in the case of a tycon: that the tycon's kind is `Type` (as all kinds must be in the `TypeInType` scheme)
 * in the case of applications `f x`:
  * that the type `f` is indeed an arrow
  * that the type `f` is applied at the type `x` that it expects

Given this we can easily implement `TypeRep a` given a representation of the expected `a`,
{{{#!hs
getTypeRep :: Typeable a => Get (TypeRep a)
getTypeRep = do
   TypeRepX rep <- getTypeRepX
   case rep `eqTypeRep` (typeRep :: TypeRep a) of
       Just HRefl -> pure rep
       Nothing    -> fail "Binary: Type mismatch"
}}}

=== Through static data?

One might have the idea that the solution here may be to avoid encoding
representations at all: instead use GHC's existing support for static data, e.g.
add `TypeRep a` entries to the static pointer table for every known type. One will quickly realize, however, that
this is unrealistic: we have no way of enumerating the types that must
be considered and even if we did, there would be very many of them.

== Type-indexed `TyCon`s

Under the above proposal `TyCon` is merely a record of static metadata; it has no
type information and consequently the user is quite limited in what they can do with it.
Another point in the design space would be to add a type index to `TyCon`,
{{{#!hs
-- metadata describing a tycon
data TyConMeta = TyConMeta { tyConPackage :: String
                           , tyConModule  :: String
                           , tyConName    :: String
                           }
newtype TyCon (a :: k) = TyCon TyConMeta

pattern TRCon :: TyCon a -> TypeRep a

-- which allows us to provide
mkTyCon :: TyCon a -> TypeRep a
}}}

While this is something that we could do, I have yet to see a compelling reason
why we **should** do it. The only way you can produce a `TyCon` is from a `TypeRep`,
so ultimately you should be able to accomplish everything you can with type-index
`TyCon`s by just not destructuring the `TypeRep` from which it arose.

== `Data.Dynamic`

`Dynamic` doesn't really change,
{{{#!hs
module Data.Dynamic where

-- Dynamic itself no longer needs to be abstract
data Dynamic where
    Dynamic :: TypeRep a -> a -> Dynamic

-- Construction
toDynR :: TypeRep a -> a -> Dynamic
toDyn  :: Typeable a => a -> Dynamic

-- Elimination
fromDynamicR :: TypeRep a -> Dynamic -> Maybe a
fromDynamic  :: Typeable a => Dynamic -> Maybe a

-- 
fromDynR :: TypeRep a -> Dynamic -> a -> a
fromDyn  :: Typeable a => Dynamic -> a -> a

-- Application
dynApp   :: Dynamic -> Dynamic -> Dynamic  -- Existing function; calls error on failure
                                           -- I think this should be deprecated
dynApply :: Dynamic -> Dynamic -> Maybe Dynamic
}}}

Ben Pierce also
[[https://ghc.haskell.org/trac/ghc/wiki/TypeableT#Data.Dynamic|suggested]] this
variant of `Dynamic`, which models a value of dynamic type "inside" of a known
functor. He p
{{{#!hs
data SDynamic s where
    SDynamic :: TypeRep a -> s a -> SDynamic s

toSDynR :: TypeRep a -> s a -> SDynamic s
toSDyn :: Typeable a => s a -> SDynamic s
fromSDynamicR :: TypeRep a -> SDynamic s -> Maybe (s a)
fromSDynamic :: Typeable a => SDynamic s -> Maybe (s a)
fromSDynR :: TypeRep a -> SDynamic s -> s a -> s a
fromSDyn :: Typeable a => SDynamic s -> s a -> s a
}}}
