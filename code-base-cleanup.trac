This page documents some cleanups that I (Sylvain Henry) would like to perform on GHC's code base.

== Why?

* Make the code more beginner friendly
  * Avoid acronyms
  * Hierarchical modules help in understanding the compiler structure
  * Try to correctly name things:
    * e.g. the "type checker" doesn't only check types, hence maybe we should call it "type system"
    * Avoid meaningless codename (e.g. backpack, hoopl)
* Make the compiler more modular
  * Allow easier reuse (with the GHC API)
  * Make the compiler easier to debug
  * Make adding new passes/optimisations easier
  * Allow easier and faster testing (testing per component instead of testing the whole pipeline)
  * Allow new more interactive frontends (step-run each compiler pass and show IR, stats, etc.)
  * Allow profile guided optimizations (passes count and order, etc.)

== Step 1: introduce basic module hierarchy

Implement the [wiki:ModuleDependencies/Hierarchical proposal for hierarchical module structure in GHC] (#13009).

It consists only in renaming/moving modules.

Compared to the original proposal, I have:
* changed GHC.Types into GHC.Data as the former is misleading (from a GHC API user point of view)
* changed GHC.Typecheck into GHC.TypeSystem as it contains deriving mechanisms, etc.
* split GHC.Utils into GHC.Utils and GHC.Data (e.g., Bag is in Data, not Utils)
* Put IR into GHC.IR and compilers into GHC.Compilers
* etc.

Tree logic:
* IR: intermediate representations. Each one contains its syntax and stuff manipulating it
    * Haskell
        * Parser
        * PrettyPrint
        * Analyse
        * Renamer
        * TypeSystem
        * Template
    * Core
        * Analyse
        * Transform.{Simplify,Specialise,Vectorise,WorkerWrapper,FloatIn,FloatOut,CommonSubExpr, etc.}
    * Cmm
        * Analyse
        * Parser
        * PrettyPrint
        * Transform.{CommonBlockElim,ConstantFolding,Dataflow,ShortCutting,Sinking}
    * Stg
        * Analyse
        * Transform.{CommonSubExpr,CostCentreCollect,Unarise}
    * ByteCode
    * Interface
    * Llvm
* Compiler: converters between representations
    * HaskellToCore
    * CoreToStg
    * StgToCmm
    * CmmToAsm
    * CmmToLlvm
    * CoreToByteCode
    * CoreToInterface
    * CmmToC
* Program: GHC-the-program (command-line parser, etc.)
* Interactive: interactive stuff (debugger, closure inspection, interpreter, etc.)
* Data: data structures (Bag, etc.) and entities (Class, etc.)
* Config: GHC configuration
    * Platform: host platform info
    * Flags: dynamic configuration (DynFlags)
* Packages: package management stuff
* Builtin: primitives
* RTS: interaction with the runtime system
* Utils: utility code or code that doesn't easily belong to another directory
* Plugin: modules to import to write compiler plugins

Actual renaming:
* TODO: insert result of `git diff origin/master --summary -M20`

Issues:
* name clashes: some modules in `base` and `ghc-prim` use the same GHC prefix (e.g., GHC.Desugar, GHC.Types).
  * maybe we should put all GHC extensions to base under GHC.Exts.* or GHC.Base.*


TODO:
* Fix comments:
  * header in OccName/RdrName/Name/Id/Var
  * header in GHC.Data.Types
  * header in GHC.Syntax.Utils
  * Fix notes referring to old file/module names
  * LaTeX doc (e.g., subsection's names)
* Fix core-spec (links to module files)
* Split GHC.Data.*?
  * Maybe we could have GHC.Entity.* for code entities (Module, Class, Type, Coercion, etc.) and keep GHC.Data.* for utility data (Maybe, FastString, Bag, etc.)
* Rename CAF into "static thunk"
* Replace file names (especially for "Note [XXX] in path/to/something.hs") with module names
* put notes files (e.g. profiling-notes, *.tex files) into actual notes or in the wiki
* there are some traces of RnHsSyn that doesn't exist anymore


Questions:
  * Why don't we use the mangled selector name ($sel:foo:MkT) in every cases (not only when we have -XDuplicateRecordFields) instead of using the ambiguous one (foo)?

== Step 2: split and edit some modules

Some modules contain a lot of (unrelated) stuff. We should split them.

* GHC.Utils (previously compiler/utils/Util.hs) contains a lot of stuff that should be split
  * Compiler configuration (ghciSupported, etc.): GHC.Config
  * List operations: GHC.Data.List{.Sort,.Fold}
  * Transitive closure: GHC.Data.Graph?
  * Edit distance and fuzzy match: GHC.Utils.FuzzyMatch?
  * Shared globals between GHC package instances: GHC.Utils.SharedGlobals?
  * Command-line parser: GHC.Utils.CmdLine
  * exactLog2 (Integer): GHC.Data.Integer (why isn't it in base?)
  * Read helpers (rational, maybe, etc.): GHC.Utils.Read?
  * doesDirNameExist, getModificationUTCTime: GHC.Utils.FilePath
  * hSetTranslit: GHC.Utils.Handle.Encoding
  * etc.
* Split GHC.Types (was HscTypes) as it contains a lot of unrelated things
  * ModGuts/ModDetails/ModIface: move to GHC.Data.Module.*
  * Usage/Dependencies: move to GHC.Data.Module.Usage/Dependencies
* GHC.Data.*: split
  * Split OccEnv from OccName (to harmonize with GHC.Data.Name.Env)?
  * Split ModuleEnv/ModuleSet from Module?
* Split GHC.Data.Types (was TyCoRep)?
  * Contains many data types (TyThing, Coercion, Type, Kind, etc.)
* Split PrettyPrint from GHC.Syntax.{Type,Expr,etc.}
* Split GHC.IR.Core.Transform.{Simplify,SimplUtils,etc.}
* Split GHC.Rename.ImportExport (e.g., contains "warnMissingSignature")
* Put cmmToCmm optimisations from GHC.Compilers.CmmToAsm into GHC.IR.Cmm.Transform
* Split type-checker solvers (class lookup, givens, wanted, etc.) (was TcSimplify, TcInteract, etc.)
* Module name GHC.Compilers.StgToCmm.Layout seems dubious: split and rename?

Some function/type names should be modified:

* Rename codeGen function into stgToCmm
* Rename nativeCodeGen into cmmToAsm
* Rename ORdList (in GHC.Data.Tree.OrdList) into TreeSomething? (misleading)
* CorePrep (prepare Core for codegen) could use a more explicit name
* Maybe rename GHC.Data.RepType
* Maybe rename OccName/RdrName/Name/Id to make them more explicit (may become obsolete with "trees that grow" patch)
  * OccName: NSName (NameSpacedName)
  * RdrName: ParsedName
  * Name: UniqueName
  * Id: TypedName




== Step 3: clearly separate GHC-the-program and GHC's API

* Make the GHC API purer

=== Abstract file loading (i.e. pluggable Finder)

Currently the Finder assumes that a filesystem exists into which it can find some packages/modules.

I would like to add support for module sources that are only available in memory or that can be retrieved from elsewhere (network, etc.).

Something similar to Java's class loaders.

=== Abstract error reporting and logging (i.e. pluggable Logger)

Allow new frontends (using GHC API) to use HTML reporting, etc.

* Avoid dumping to the filesystem and/or stdout/stderr
* Use data types instead of raw SDoc reports


=== Step 4: clearly separate phases

* split DynFlags to only pass the required info to each pass
    * e.g. only the required hooks
* use data types to report phase statistics, intermediate representations, etc.