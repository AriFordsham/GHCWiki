= Refactoring GHC Types

This page is to document several ideas for how to refactor the way types are stored and processed within GHC. The general goal here is to clean up code, but it is also possible we'll be able to improve error messages through this work.

This page was started in June 2018.

== Desugaring types separately

Currently (June 2018), GHC sports these two functions:

{{{#!hs
tc_hs_type :: TcTyMode -> HsType GhcRn -> TcKind -> TcM TcType -- in TcHsType.hs
tcExpr :: HsExpr GhcRn -> ExpRhoType -> TcM (HsExpr GhcTcId)   -- in TcExpr.hs
}}}

The first takes a Haskell type (`HsType GhcRn`) and its expected kind and outputs a `TcType`: a Core type (possibly with `TcTyVar`s in it -- that's the `Tc` prefix). In contrast, the second takes a Haskell expression (`HsExpr GhcRn`) and its expected type and outputs a `HsExpr GhcTcId`: a Haskell expression using `TcId`s as its binders. Despite performing parallel operations, these two functions have wildly different output forms: one is a Core thing and one is a Haskell thing. Accordingly, expressions must be desugared in a later pass to Core expressions, while types are essentially desugared while being checked.

The first goal in this refactor is to align these functions. Desugaring separately has several advantages:

 * Type checking is complicated. Desugaring can be, too. Better to separate them.
 * We report type errors during type checking (and sometimes afterwards). These messages can use the code the user has written only if we don't desugar simultaneously.
 * As we will see later, doing this sets the stage for removing the "knot" in type checking.