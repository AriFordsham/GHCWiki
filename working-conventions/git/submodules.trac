[[PageOutline()]]

= Workflows for Handling GHC's Git Submodules =

GHC is a large project with several external dependencies. We use git submodules to track these repositories, and here you'll learn a bit about how to manage them.

General information about Git's submodule support:

 - [http://git-scm.com/docs/git-submodule "git submodule" manual page]
 - [http://git-scm.com/book/en/Git-Tools-Submodules Pro Git "6.6 Git Tools - Submodules" chapter]
 - [http://www.vogella.com/tutorials/Git/article.html#submodules Submodule Tutorial]

== Cloning a fresh GHC source tree ==

Initial cloning of GHC HEAD (into the folder `./ghc`) is a simple as:

{{{#!sh
git clone --recursive git://git.haskell.org/ghc.git
}}}

(Obviously, the clone URL can be replaced by any of the supported `ghc.git` URLs as listed on http://git.haskell.org/ghc.git)

== Updating an existing GHC source tree clone ==

Sometimes when you pull in new commits, the authors updated a submodule. After pulling, you'll also need to update your submodules, or you'll get errors.

At the top-level of `ghc.git` working copy:

{{{#!sh
git pull --rebase
git submodule update --init
}}}

{{{#!box note

In seldom cases it can happen that `git submodule update` aborts with an error similar to the following one

{{{
fatal: Needed a single revision
Unable to find current revision in submodule path 'libraries/parallel'
}}}

This means that for some (unknown) reason, the Git submodule in question is in an unexpected/corrupted state. The easiest remedy is remove the named path (or just move it out of the way in case it contains unsaved work), and retry. E.g.

{{{
rm -rf libraries/parallel
git submodule update --init
}}}

}}}

=== Using a Git alias ===

A commonly defined Git alias that combines the two commands into one convenient Git alias is:

{{{#!sh
git config --global alias.pullall '!f(){ git pull "$@" && git submodule update --init --recursive; }; f'
}}}

(the `--global` flag make this alias persist in the `${HOME}/.gitconfig` file, so this needs to be done only once, the `--recursive` option is not needed for GHC but it's commonly used for the `pullall` alias)

After setting this alias, one can now simply use the single invocation

{{{#!sh
git pullall --rebase
}}}

to update `ghc.git` and all its submodules.

== `git status` and dirty submodules ==

By default, git will consider your submodule as "dirty" when you do `git status` if it has any changes or any untracked files.  Sometimes this can be inconvenient, especially when using [wiki:Phabricator] which won't allow you to upload a diff if there are dirty submodules.  Phabricator will let you ignore untracked files in the main GHC repo, but to ignore untracked files in a submodule you'll need a change to `.git/config` in the GHC repo.  For example, to ignore untracked files in the `nofib` repo, add the line `ignore = untracked` to the section for `nofib` in `.git/config`:

{{{
[submodule "nofib"]
	url = /home/simon/ghc-mirror/nofib.git
        ignore = untracked
}}}

== Making changes to GHC submodules ==

It's very important to keep in mind that Git submodules track commits (i.e. not branches!) to avoid getting confused. Therefore, `git submodule update` will result in submodules having checked out a so-called [http://alblue.bandlem.com/2011/08/git-tip-of-week-detached-heads.html detached HEAD].

So, in order to make change to a submodule you can either:

 1) Work directly on the detached HEAD in the submodule directory.

 2) Checkout the respective branch the commit is supposed to be pointed at from (normally `master`. See the table below for the full branch/repo summary). 

The example below will demonstrate the latter approach for the `utils/haddock` submodule:

{{{#!sh
# do this *before* making changes to the submodule
cd utils/haddock
git checkout master
git pull --rebase

# perform modifications and as many `git {add,rm,commit}`s as you deem necessary
$EDITOR src/somefile.hs

# finally, after you're ready to publish your changes, simply push the changes as for an ordinary Git repo
git push

# go back to ghc.git top-level
cd ../..
}}}

At this point, the remote `haddock.git` contains newer commits in the `master` branch, which still need to be registered with `ghc.git`:

{{{#!sh
# if you want, you can inspect with `git submodule` and/or `git status`
# if there are submodules needing attention;
# specifically, the commands below should report new commits in `util/haddock`
git submodule
git submodule summary
git status

# Register the submodule update for the next `git commit` as you would any other file
# Note: You can think of submodule-references as virtual files which 
#       contain a SHA1 string pointing to the submodule's commit.
git add util/haddock

# you can also add other changes in `ghc.git` (e.g. testsuite changes) and/or other submodules 
# you need to update atomically with the next commit
git add testsuite/...

# prepare a commit, and make sure to mention the string `submodule` in the commit message
git commit -m 'update haddock submodule ... blablabla'

# finally, push the commit to the remote `ghc.git` repo
git push
}}}


{{{#!box info
Git supports a recursive `git push` operation. If you issue a

{{{
git push --recurse-submodules=on-demand
}}}

this will cause Git to push all submodules changes that have been registered in the revisions
to be pushed to the super repository.

TODO: show how to define a `git pushall` alias in the style of the `git pullall` alias
}}}

=== Validation hooks ===

There are server-side validation hooks in place on `git.haskell.org` to make sure for non-`wip/` branches that `ghc.git` never points to non-existing commits. Also, as a safe-guard against accidental submodule reference updates, the string `submodule` ***must occur somewhere in commit messages of commits*** updating submodule references. So just remember that:

 1) If you update a submodule pointer,

 2) You had to have pushed it upstream already,

 3) And you have to say the word 'submodule' in the commit.

== Upstream repositories ==

Below is a table summarizing the repositories GHC uses. It lists the upstream location of the repository, and the branch name. All the upstream repositories are either located on `git.haskell.org` or `github.com` as of right now.

 - Patches for `git.haskell.org` repositories should go to GHC developers. Developers can push to these repositories directly.

 - Patches for `github.com` repositories should be made into Pull Requests on GitHub. GHC developers have access to the repositories under the `haskell` organization in particular, and can push directly.

As stated above - GHC tracks the branch listed here for the specific repository. If you're going to base your change on a branch, always do it on this one, and make sure your change is on the specified branch. Then update the submodule.

{{{
#!html
<table border="1">
<tr><td><strong>Location in tree</strong></td> <td><strong>Upstream repo</strong></td> <td><strong>Upstream GHC branch</strong></td></tr>
<tr><td>utils/hsc2hs</td>           <td>https://git.haskell.org/hsc2hs.git</td> <td>master</td></tr>
<tr><td>utils/haddock</td>          <td>https://github.com/haskell/haddock</td> <td>master</td></tr>
<tr><td>nofib</td>                  <td>https://git.haskell.org/nofib.git</td> <td>master</td></tr>
<tr><td>libraries/array</td>        <td>https://git.haskell.org/packages/array.git</td> <td>master</td></tr>
<tr><td>libraries/binary</td>       <td>https://github.com/haskell/binary</td> <td>master</td></tr>
<tr><td>libraries/bytestring</td>   <td>https://github.com/haskell/bytestring</td> <td>master</td></tr>
<tr><td>libraries/Cabal</td>        <td>https://github.com/haskell/Cabal</td> <td>master</td></tr>
<tr><td>libraries/containers</td>   <td>https://github.com/haskell/containers</td> <td>master</td></tr>
<tr><td>libraries/deepseq</td>      <td>https://git.haskell.org/packages/deepseq.git</td> <td>master</td></tr>
<tr><td>libraries/directory</td>    <td>https://git.haskell.org/packages/directory.git</td> <td>master</td></tr>
<tr><td>libraries/filepath</td>     <td>https://git.haskell.org/packages/filepath.git</td> <td>master</td></tr>
<tr><td>libraries/haskeline</td>    <td>https://github.com/judah/haskeline</td> <td>master</td></tr>
<tr><td>libraries/haskell98</td>    <td>https://git.haskell.org/packages/haskell98.git</td> <td>master</td></tr>
<tr><td>libraries/haskell2010</td>  <td>https://git.haskell.org/packages/haskell2010.git</td> <td>master</td></tr>
<tr><td>libraries/hoopl</td>        <td>https://git.haskell.org/packages/hoopl.git</td> <td>master</td></tr>
<tr><td>libraries/hpc</td>          <td>https://git.haskell.org/packages/hpc.git</td> <td>master</td></tr>
<tr><td>libraries/old-locale</td>   <td>https://git.haskell.org/packages/old-locale.git</td> <td>master</td></tr>
<tr><td>libraries/old-time</td>     <td>https://git.haskell.org/packages/old-time.git</td> <td>master</td></tr>
<tr><td>libraries/process</td>      <td>https://git.haskell.org/packages/process.git</td> <td>master</td></tr>
<tr><td>libraries/terminfo</td>     <td>https://github.com/judah/terminfo</td> <td>master</td></tr>
<tr><td>libraries/time</td>         <td>https://github.com/haskell/time</td> <td>master</td></tr>
<tr><td>libraries/unix</td>         <td>https://github.com/haskell/unix</td> <td>master</td></tr>
<tr><td>libraries/Win32</td>        <td>https://git.haskell.org/packages/Win32.git</td> <td>master</td></tr>
<tr><td>libraries/xhtml</td>        <td>https://github.com/haskell/xhtml</td> <td>master</td></tr>
<tr><td>libraries/random</td>       <td>https://github.com/haskell/random</td> <td>master</td></tr>
<tr><td>libraries/primitive</td>    <td>https://github.com/haskell/primitive</td> <td>master</td></tr>
<tr><td>libraries/vector</td>       <td>https://github.com/haskell/vector</td> <td>master</td></tr>
<tr><td>libraries/dph</td>          <td>https://git.haskell.org/packages/dph.git</td> <td>master</td></tr>
<tr><td>libraries/parallel</td>     <td>https://git.haskell.org/packages/parallel.git</td> <td>master</td></tr>
<tr><td>libraries/stm</td>          <td>https://git.haskell.org/packages/stm.git</td> <td>master</td></tr>
</table>
}}}


== TODO ==

- Describe how to make use of `git submodule update --remote`
- Describe darcs mirroring for `transformers`
- Describe status of `pretty` which is one-off at the moment and doesn't exactly track upstream.