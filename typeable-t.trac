= Type Indexed Type Representations Proposal =

== Overview ==

This page describes a new API for type indexed type representations, basic `Dynamic` functionality, static pointers and distributed closures.
It is a specific realisation of the ideas in [wiki:DistributedHaskell].

Just as in [wiki:DistributedHaskell], we provide 4 APIs
 * `Data.Typeable`: type-indexed type representation.  This replaces the existing `Typeable` class, and the kind of `TypeRep` changes to `TypeRep :: k -> *`.

 * `Data.Dynamic`: dynamically-typed values; replaces the existing `Data.Dynamic`.  The API is almost unchanged.

 * `Data.StaticPtr`: static pointers. The idea is that this will ultimately by the foundation for the `[https://hackage.haskell.org/package/distributed-static Cloud Haskell]` package.

 * `Control.DistributedClosure`: serialisable closures.  The idea is that this will ultimately by the foundation for the Cloud Haskell `distributed-static` package.

Each is described in more detail below.

== Transition Plan ==

We propose to
 * ''Outright replace'' the existing `Typeable` class with the new one; ditto the `TypeRep` type.
   This seems better than inventing new names for everything (e.g. class `TypeableT`, data type `TypeRepT`.
   Not many packages use `TypeRep` explicitly, we want to encourage those that do to switch over.

 * GHC magic for the `Typeable` class will apply to the new class.

 * To ease the transition we will provide both
   * The old API via a (deprecated) new module `Data.Typeable710`.
   * The old API via the exiting module `Data.Typeable` but with new names for (deprecated) old types and functions.

== Questions ==

See also the individual questions sections below.

* Now is the easiest time to rename things - do you have suggestions for better naming schemes?
* Any comments would be gladly received!

--------------------------
== Data.Typeable ==

For `Data.Typeable` we ultimately need Richard Eisenberg's kind equalities.
But until GHC gets kind equalities we offer a variant ("homogeneous case") that doesn't need them, but has an extra `unsafeCoerce` or two, and returns `Bool` rather than a type equality on kind-heterogeneous comparisons.

=== Without kind equalities ===

{{{#!hs
data TypeRep (a :: k) -- abstract
typeRepFingerprint :: TypeRep a -> Fingerprint
appR :: TypeRep (a :: k -> k') -> TypeRep (b :: k) -> TypeRep (a b)

class Typeable (a :: k) where
  typeRep :: TypeRep a

-- GHC has magic built-in support for Typeable instances
-- but the effect is similar to declarations like these:
instance (Typeable c, Typeable a) => Typeable (c a)
instance Typeable Bool
instance Typeable (->)

withTypeable :: TypeRep a -> (Typeable a => b) -> b
-- c.f. Trac #2439

eqRR :: TypeRep (a :: k1) -> TypeRep (b :: k2) -> Bool
eqRRHom :: TypeRep (a :: k) -> TypeRep (b :: k) -> Maybe (a :~: b)

data GetApp (a :: k) where
  GA :: TypeRep (a :: k1 -> k2) -> TypeRep (b :: k1) -> GetApp (a b)
getAppR :: TypeRep (a :: k) -> Maybe (GetApp a)

data G1 c a where
  G1 :: TypeRep (a :: k) -> G1 (c :: k -> k') (c a)
getR1 :: TypeRep (ct :: k1 -> k) -> TypeRep (c'at :: k) -> Maybe (G1 ct c'at)
-- Implementation uses an unsafeCoerce

data G2 c a where
  G2 :: TypeRep (a :: k1) -> TypeRep (b :: k2) -> G2 (c :: k1 -> k2 -> k3) (c a b)
getR2 :: TypeRep (c :: k2 -> k1 -> k) -> TypeRep (a :: k) -> Maybe (G2 c a)
-- Implementation uses an unsafeCoerce

-- rest are for convenience
typeOf  :: Typeable a => (a :: *) -> TypeRep a
getFnR  :: TypeRep (a :: *) -> Maybe (G2 (->) a)
castR   :: TypeRep (a :: *) -> TypeRep (b :: *) -> a -> Maybe b
cast    :: (Typeable (a :: *), Typeable (b :: *)) => a -> Maybe b
gcastR  :: TypeRep (a :: k) -> TypeRep (b :: k) -> c a -> Maybe (c b)
gcast   :: (Typeable (a :: k), Typeable (b :: k)) => c a -> Maybe (c b)
gcastR1 :: TypeRep (t :: k1 -> k2) -> TypeRep (t' :: k1 -> k2) -> c (t a) -> Maybe (c (t' a))
gcast1  :: (Typeable (t :: k1 -> k2), Typeable (t' :: k1 -> k2)) => c (t a) -> Maybe (c (t' a))
gcastR2 :: TypeRep (t :: k1 -> k2 -> k3) -> TypeRep (t' :: k1 -> k2 -> k3) -> c (t a b) -> Maybe (c (t' a b))
gcast2 :: (Typeable (t :: k1 -> k2 -> k3), Typeable (t' :: k1 -> k2 -> k3)) => c (t a b) -> Maybe (c (t' a b))
}}}

Notes:
 * Many of these functions come in two variants:
   * one which takes an explicit `TypeRep` argument, and
   * one that take an implicit `TypeRep` argument via a `Typeable a` constraint.
 We use a consistent naming scheme: put an `R` suffix on variants that take an explicit `TypeRep` parameter, no suffix for `Typeable` constraint versions.

 * Note that the type `(:~:)` comes from `Data.Type.Equality`.
   And `Fingerprint` is from `GHC.Fingerprint`.

 * `typeRepFingerprint` is not used internally (although it could be for `eqRR`), but is provided for users.
   e.g. to add consistency checks when using `Control.DistributedClosure` that two nodes agree on their static pointer table (or at least the types agree, if not the values).

 * Note also {{{eqRR}}} is not hugely useful as (if it returns True) we know that types and kinds are the same, but GHC doesn't, so `unsafeCoerce` is often needed.

 * The `withTypeable` function is useful, and illustrates a generally useful pattern: see [wiki:Typeable/WithTypeable].

=== Key differences from GHC 7.10 ===

 * The key difference is that `TypeRep` becomes type-indexed, so that if `x :: TypeRep [Int]` then `x` is a runtime-inspectable type representation for `[Int]`.
   It is poly-kinded, of course, so that `TypeRep Maybe` is fine.

 * In class `Typeable`, the `typeRep` method therefore no longer needs a proxy argument.
   Indeed the class dictionary precisely is a single type representation.

 * Functions for constructing and destructing `TypeRep`s differ, in particular destructing needs a GADT return type to deal with existentially hidden `TypeRep` indices.

 * The new API does not expose `TyCon`, and is therefore a much smaller API; see questions below.

=== With kind equalities ===

Once we have kind equalities, we have a kind-heterogeneous `:~~:`.
Now we do not `unsafeCoerce` in `getR1` and the like, so we can now just export `getAppR` and leave the rest to the users.

The changes are that now:
 * `eqRR :: TypeRep (a :: k1) -> TypeRep (b :: k2) -> a :~~: b` (i.e. now returns {{{a:~~:b}}} rather than `Bool`), and is more useful (doesn't force us to use {{{unsafeCoerce}}})
 * {{{getR1}}} and {{{getR2}}} don't need {{{unsafeCoerce}}}, and we can generalise {{{G1}}}, `getR1` etc. to be poly-kinded i.e. `getR1 :: TypeRep (a :: k1 -> k) -> TypeRep (b :: k2) -> Maybe (G1 a b)` where `k /= k2`
.
We obviously may want to provide (and deprecate) `getR1`, `eqRRHom` etc. for compatibility, but they now can be written entirely safely in user-code.

(I am not yet sure whether it would be useful to keep the homogeneous equality functions around --- potentially enforcing kind homogeneity could be useful)

=== Trusted code base ===

The TCB consists of (in the homogeneous case), the implementation of `data TypeRep`, `class Typeable` and its implementations, `eqRR` and `eqRRHom` (comparison of `TypeRep`s), `getR1` and `getR2` (decomposing `TypeRep`s).
As is currently done for `Typeable`, the instances for `Typeable` should be "magically" provided by GHC.

In the kind-heterogeneous case, `getR1` and `getR2` come out of the TCB.

=== Questions ===

* How many `getR1`, `getR2` etc should we provide?

* Currently, equality checks for `TypeRep`s are done recursively rather than using fingerprints, and once no-kinds is merged, it will actually build equality evidence out of smaller equality evidince.
  However, using fingerprints and one `unsafeCoerce` may be more efficient (especially if fingerprints are cached in the datatype), but is argueably less principled, and certainly brings more code into the TCB.
  Which method do we want to use?
  Or perhaps provide both `eqRR` with fingerprints and `eqRRParanoid` recursively?

* Do we want explicit names for some type representations?
  Perhaps `typeRepBool` etc., and just for Prelude defined types.
  (It is nice to avoid writing `typeRep :: TypeRep Bool`)

* `TyCon` is used internally but is now entirely hidden from the user.
  Is there a use-case where this is not desirable?  By way of background, the internal representatation looks like this
{{{
data TypeRep (a :: k) where
  TRCon :: TyCon a -> TypeRep a
  TRApp :: TypeRep a -> TypeRep b -> TypeRep (a b)
}}}
  where the `TyCon a` is a now-internal data type describing a type constructor.

--------------------------------
== Data.Dynamic ==

This should be a fairly seamless changeover, since `Dynamic` is abstract currently (although we cannot provide a `dynTypeRep :: Dynamic -> TypeRep ?` function - this does not seem oft-used & can be avoided by pattern matching as our `Dynamic` is not abstract).

The API follows the current API, except missing `dynTypeRep`, as detailed above.
We provide variants of functions that take explicit `TypeRep` arguments.
{{{#!hs
data Dynamic where
  Dynamic :: TypeRep a -> a -> Dynamic

toDynR :: TypeRep a -> a -> Dynamic
toDyn  :: Typeable a => a -> Dynamic
fromDynamicR :: TypeRep a -> Dynamic -> Maybe a
fromDynamic  :: Typeable a => Dynamic -> Maybe a

fromDynR :: TypeRep a -> Dynamic -> a -> a
fromDyn  :: Typeable a => Dynamic -> a -> a

dynApp   :: Dynamic -> Dynamic -> Dynamic  -- Existing function; calls error on failure
dynApply :: Dynamic -> Dynamic -> Maybe Dynamic

data SDynamic s where
  SDynamic :: TypeRep a -> s a -> SDynamic s

toSDynR :: TypeRep a -> s a -> SDynamic s
toSDyn :: Typeable a => s a -> SDynamic s
fromSDynamicR :: TypeRep a -> SDynamic s -> Maybe (s a)
fromSDynamic :: Typeable a => SDynamic s -> Maybe (s a)
fromSDynR :: TypeRep a -> SDynamic s -> s a -> s a
fromSDyn :: Typeable a => SDynamic s -> s a -> s a
}}}

Notes
 * These is no trusted code here; i.e. no `unsafeCorece`s in the implementation.

 * `Dynamic` is ''not'' abstract so that you can pattern match on it. If it was abstract we'd need to add
{{{
unpackDynamic :: Dynamic -> (forall a. TypeRep a -> a -> r) -> r
}}}

 * `SDynamic` is a mid-point between fully dynamic & fully static types.
   We statically know some "Shape" information, but not all info about type.
   e.g., `SDynamic Maybe` contains a value that is definitely a `Maybe ty` for some type `ty`, but the type `ty` can vary between values of type `SDynamic Maybe`.

 One use-case is in the implementation of `StaticPtr`.

=== Questions ===

* Do we want to provide `dynApp` which calls `error` instead of returning `Nothing`?
  It seems to be much less used than `dynApply`, and personally I dislike that style.

--------------------------
== Data.StaticPtr ==

Note that the static pointer support requires a static pointer table in a different form to what GHC already supports, and an extension to the static keyword.

{{{#!hs
data Dict c where
  Dict :: forall c . c => Dict c

-- A StaticPtr is just a /code/ pointer to a monomorphic value
data StaticPtr (a :: *) -- abstract

deRefStaticPtr :: StaticPtr a -> a

putSDynStaticPtr :: SDynamic StaticPtr -> Put
getSDynStaticPtr :: Get (SDynamic StaticPtr)
instance Binary (SDynamic StaticPtr)

putStaticPtr :: StaticPtr a -> Put
getStaticPtr :: TypeRep a -> Get (StaticPtr a)
instance Typeable a => Binary (StaticPtr a)

-- A Static is either a StaticPtr, a "polymorphic code pointer", or a syntax tree of applications of such.
data Static (a :: *) -- abstract

deRefStatic :: Static a -> a

staticMono :: StaticPtr a -> Static a
staticApp :: Static (a -> b) -> Static a -> Static b

putSDynStatic :: SDynamic Static -> Put
getSDynStatic :: Get (SDynamic Static)
instance Binary (SDynamic Static)

putStatic :: Static a -> Put
getStatic :: TypeRep a -> Get (Static a)
instance Typeable a => Binary (Static a)
}}}

Notes
* To serialise a static pointer, we just serialise it's name
 * What a name actually comprises is fairly flexible:
   * If all binaries have the same SPT, we could just have an numeric index into the SPT
   * If we want to support overlapping SPTs, we could do a (package,module,name) triple
   Since we have a safe lookup function, this choice cannot impact type-safety
* We don't actually expore a `lookupSPT` function, but that is the content of `getStaticPtr`.

TODO: talk about poly

=== Trusted Code Base ===
Just the RTS support for building the static pointer table.

=== Questions ===

* Naming of `deRef*`: for StaticPtr, this was chosen for consistency with current GHC
  Consistency between `Static` and `StaticPtr` is nice, but `deRefStatic` makes the operation sound trivial (follow a pointer?), but we may need to do arbitrary computations to evaluate applications.
  * Option 1: leave as is
  * Option 2: rename `deRefStatic` to `unStatic` (then consistent with Closures)
  * Option 3: rename both `deRef*` to `un*`

* `Dict` should probably live somewhere else. Where?

* The static "polymorphism" support is a bit kludgy - any comments on this would be most helpful!

--------------------------
== Control.DistributedClosure ==
`Closure`s are based on the fact that both `Static`s and `ByteString`s are easilly serialisable.
The `Serialisable` class and `closurePure` use this by noting that if we have a 'static' decoding function `sf` for `a`, then we can serialise `sf` and `encode a :: ByteString`, and this is a serialisation of `a` itself.

Note however, that we require a fully-fledged 'static' `Typeable` and `Binary` dictionary, this enables us to be able to write instances like `instance Serializable b => Serializable (Maybe b)`.
These instances are where we require our polymorphism support in `Data.StaticPtr`

{{{#!hs
data Closure (a :: *) -- abstract
unclosure :: Closure a -> a

closureSP :: StaticPtr a -> Closure a
closureS :: Static a -> Closure a
closureEnc :: ByteString -> Closure ByteString
closureApp :: Closure (a -> b) -> Closure a -> Closure b

-- | A class for those types for which we have /static/ evidence of their 'Binary' and 'Typeable'
-- nature, and so can serialise them (via 'closurePure')
class (Binary a, Typeable a) => Serializable a where
  binDict :: Static (Dict (Binary a))
  typDict :: Static (Dict (Typeable a))

closurePure :: Serializable a => a -> Closure a

putSDynClosure :: SDynamic Closure -> Put
getSDynClosure :: Get (SDynamic Closure)
instance Binary (SDynamic Closure) where

putClosure :: Closure a -> Put
getClosure :: TypeRep a -> Get (Closure a)
instance Typeable a => Binary (Closure a) where
}}}
