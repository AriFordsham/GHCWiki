= Visible Type Application =

Visible Type Application, language extension `TypeApplications`, allows you to give explicit type arguments to a polymorphic function; e.g. `map @Int @Bool isEven xs`.  Visible type application was introduced in GHC 8.0.

This the feature page that summarises status, open issues, etc.

== Status

Use Keyword = `TypeApplications` to ensure that a ticket ends up on these lists.

'''Open Tickets:'''
[[TicketQuery(status=infoneeded,status=new|patch,keywords=~TypeApplications)]]

'''Closed Tickets:'''
[[TicketQuery(status=infoneeded,status=closed,keywords=~TypeApplications)]]



-------------------------
'''Everything below here is the old wiki page.  Much of it is relevant, but it needs curation. Richard will do that in due course.'''

Another relevant out of date page is [wiki:ExplicitTypeApplication]
== Type Application ==


[Explicit] Type Application is a feature requested for Haskell that lets a programmer explicitly declare what types should be instantiated for the arguments to a function application, in which the function is polymorphic (containing type variables and possibly constraints) . Doing so essentially “short-circuits” much of the type variable unification process, which is what GHC normally attempts when dealing with polymorphic function application.

In general, Haskell’s unification algorithm is robust enough that it can do this without the programmer needing to specify explicit types. There are a few edge cases, however: see below for examples. Though some of these cases can be solved with type annotations, such annotations can be cumbersome, as the programmer needs to provide the entire signature, which can be cumbersome in complicated expressions. 


It is worth noting that GHC’s intermediate language, “Core”, is fully typed and has no ambiguity - every polymorphic function application is explicitly typed. Thus, one way to think of this addition is “exposing” this feature of Core to the programmer. Indeed, once the evidence (generated by instantiating the types) is propagated to Core, it is able to be handled completely by that part of the compiler - implementing this feature did not require any changes to Core, nor to the lower-level compiler pipeline (optimizations, assembly generation, etc).
See directly below for usage examples. More detailed design decisions follow the examples.


----


== '''Usage:''' ==
 

This extension can be enabled with “TypeApplications” within the LANGUAGE pragma, or use the flag “-XTypeApplications”. The usage of this flag does not turn on any other flag implicitly. Using this flag will make a whitespace-sensitive distinction preceding each ‘@’ character: No whitespace before ‘@’ will result in an as-pattern, while having whitespace before the ‘@’ will parse as a type-application. (When this flag is turned off, the behavior is the same as it is now - no whitespace sensitivity). See '''Design''' with more information on the syntax.

Here are some examples where type application is useful:


This test case shows how using explicit type application resolves ambiguity, by
using the infamous "show/read" problem as an example. (The show/read problem is
a problem in which the answer to using show followed by read - 'show (read "3")'
should be obvious, but fails in the typechecker because of an ambiguity in the
constraints). Using type application on either of the functions, or both, allows the compiler
to correctly typecheck the program.

{{{
answer_read = show (read @Int "3") -- "3" :: String
answer_show = show @Integer (read "5") -- "5" :: String
answer_showread = show @Int (read @Int "7") -- "7" :: String
}}}

A more difficult example involves type families, which are generally difficult to infer, and this creates problems when attempting to unify types involving type families. In this specific example, the declaration "g False" would be ill-typed [since it has no type signature], but adding the explicit type “@Char” will resolve this problem.

{{{
type family F a
type instance F Char = Bool

g :: F a -> a
g _ = undefined

f :: Char
f = g True

h = g False -- will cause an error
h' = g @Char False
}}}

One does not need to have the “-XExplicitForAll” extension turned on to use “-XExplicitTypeApplication”. Without the forall flag, generally types will be inferred by simply stacking all of the foralls at the beginning. You can also leave off explicit types by simply withholding the annotation, or by providing “@_” to let the typechecker instantiate the variable regularly. This is particularly useful when you want to provide a type to the first and third type variable, but not the second, for example:

{{{
-- Will be treated as:
-- forall a b c d. a -> b -> c -> d -> (a, b, c, d)...
quad :: a -> b -> c -> d -> (a, b, c, d)
quad w x y z = (w, x, y, z)

foo = quad @Bool @_ @Int False 'c' 17 "Hello!" -- Char and [Char] will be inferred for type variables ‘b’ and ‘d’.
}}}

This also works with types of arbitrary kinds, including with kind variables. (There is no explicit kind application yet, but with the current implementation, it is very easy to extend it in the future). Of course, the types within the type applications will have to satisfy the kinds you are providing.

{{{
data Two (a :: * -> k) = T

two :: Two a -> Int
two _ = 2

twoBase = two T
twoOk = two @(Either Int) T
twoBad = too @Maybe (T :: Two Either)
}}}

----

== '''Design''' ==

There are several small design questions that can be asked of Explicit Type Application. Below are the questions and the decisions that were made:

- ''Is a type annotation and/or signature required for a function in order to use type applications when applying it?''

  No. Haskell generalizes certain functions, with a simple, straightforward signature; all the type variables are at the top, and it is a fairly simple signature to instantiate and work with. 

- ''Should we require a forall in the signature?'' 

  No, for similar reasons as above. Additionally, we did not want to create a dependency on the "ExplicitForAll" flag, and wanted type applications to be a small, surgical feature that has as few side effects as possible.

- ''What order is used to instantiate the type variables?'' 

  Left-to-right order of the type variables appearing in the foralls. This is the most logical order that occurs when the instantiation is done at the type-variable level. Nested foralls work slightly differently, but at a single forall location with multiple variables, left-to-right order takes place. (See below for nested foralls).

- ''How will it work with partial function application? Will we allow: leaving out arguments in function application, but allow type application to de-generalize the expression?''

  Yes. This will allow the programmer to use the partially applied the function later, but only to arguments with specific types. This could be useful for a library designer, to use a generalized function internally, and only expose a specialized version of that function in the interface.  

- '' Wildcard Application''
  Allows the programmer to not instantiate every type variable if they do not want to. Example
{{{
f xs = reverse @ (Maybe _) xs
-- Instantiates reverse at a Maybe type
-- but lets GHC infer which
}}}
  An explicit application `@ _` is just like the implicit form: instantiate with a fresh unification variable.  

- ''Named wildcards''.  Can you write
{{{
f xs = reverse @ (_a -> _a) xs
}}}
  The intent here is that `_a` stands for a type, but not necessarily a type variable.

- ''Should non-prenex-form functions be allowed to use type applications? If so, how should we allow it? ''

  Yes. We allow this by requiring that type application appear where the forall is located in the type. See the following example:
{{{
many :: forall a b. a -> b -> forall c. [c] -> forall d . Num d => d -> (a, b, [c], d)
many a b c d = (a, b, c, d)
foo =  many @Int @Bool 5 True @Char "hello" @Float 17
}}}

- ''Concrete Syntax'':

We choose to use the ‘@’ symbol, as this is the symbol that is used in Core, GHC’s intermediate language. Turning on this extension will make the ‘@’ symbol whitespace-sensitive in the front: whitespace before an ‘@’ will parse as a type-application, while no whitespace in front of the ‘@’ will parse as an as-pattern. This is similar to the way ‘.’ behaves differently with whitespace (function composition vs. module naming), but note that the only whitespace sensitivity occurs ‘’’before’’’ the ‘@’ and not after. Additionally, when the extension is off, there is no change in current behavior and no whitespace sensitivity.

