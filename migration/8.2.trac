[[PageOutline]]

= GHC 8.2.x Migration Guide =

This guide summarises the changes you may need to make to your code to migrate from GHC 8.0 to GHC 8.2. This guide complements the GHC 8.2.x release notes which should be consulted as well.

----------------------------------
== Compiler changes

=== Impredicative types removed
Note that the `-XImpredicativeTypes` extension, which has been
[[ImpredicativePolymorphism|known]] to be broken for many years. It has now at long last been removed. TODO '''RGS''': is this really true?

=== `DefaultSignatures` is pickier
There a new validity check for default class method implementations using `-XDefaultSignatures`. In particular, if you have a class `Foo`:

{{{#!hs
class Foo a where
  bar :: C => a -> b -> b
}}}

and you add a default type signature for `bar`, it //must// be of the form:

{{{#!hs
  default bar :: C' => a -> b -> b
}}}

That is, the right-hand sides of the type signatures must be the same, but the contexts `C` and `C'` are allowed to be different. That means that these default type signatures for `bar`:

{{{#!hs
  default bar :: C' => b -> a -> b
  default bar :: C' => b -> b -> a
  default bar :: C' => a -> b -> b -> b
}}}

will all be rejected.

These will also be rejected:

{{{#!hs
  default bar :: C' => a -> Int -> Int
  default bar :: C' => a -> TF b -> TF b
}}}

(where `TF` is a type family). But it's possible to rearrange these into equivalent forms that GHC accepts: just use type equalities!

{{{#!hs
  default bar :: (C', b ~ Int)  => a -> b -> b
  default bar :: (C', b ~ TF c) => a -> b -> b
}}}

As shown in the `TF` example, you might have to create new type variables (e.g., `c`) to make the type equalities work out.

=== Associated type family instances are pickier ===
There is also a new validity check for associated type family instances. That is, if you have a class with an associated type family:

{{{#!hs
class C a b where
  type T a x b
}}}

And you create and instance of `C`:

{{{#!hs
instance C ty1 ty2 where ...
}}}

Then the associated `T` instance must look //exactly// like:

{{{#!hs
  type T ty1 v ty2 = ...
  -- 'ty1' for 'a'
  -- 'ty2' for 'b', and
  -- some type `v` for 'x'
}}}

As a concrete example, this code, which would have been allowed before GHC 8.2, is now disallowed:

{{{#!hs
class Foo a where
  type Bar a

instance Foo (Either a b) where
  type Bar (Either c d) = d -> c
}}}

To fix this instance, simply use the same type variables in the `Bar` instance as in the instance head:

{{{#!hs

instance Foo (Either a b) where
  type Bar (Either a b) = b -> a
}}}

=== Instances for class synonyms are now disallowed ===

Previously, GHC silently accepted nonsense instance declarations like this:

{{{#!hs
type ReadShow a = (Read a, Show a)

instance Read Foo
instance Show Foo
instance ReadShow Foo
}}}

It's not even clear what this is supposed to mean, since `ReadShow` isn't a class in and of itself. To disallow this, GHC now prevents all instances of the form `instance (...) => Syn (...)`, where `Syn` is a type synonym.

This check is a bit conservative, as it bars you from writing this as well:

{{{#!hs
type MyShow = Show
instance MyShow Foo
}}}

The workaround is to define the instance using `Show` instead of `MyShow`.

--------------------------------
== Library changes

=== `base-4.10.0.0`

* Type-indexed `Typeable` changes
  * The `Data.Typeable.Internal` module has been removed entirely. Much of the `Typeable` internals now live in the new `Type.Reflection` module.
  * `Data.Typeable.TypeRep` is now a type synonym (so you may need `TypeSynonymInstances` to create an instance for it, unless you switch it to use `Type.Reflection.SomeTypeRep`)
  * `mkFunTy`, `mkAppTy`, `mkTyConApp`, and `` have been removed. If you use these then you might instead consider looking at the new type-indexed interfaces found in `Type.Reflection`.
  * `mkTyCon3` and `mkTyConApp` are no longer exported by `Data.Typeable`. They are instead exported by `Type.Reflection.Unsafe`.
  * `Data.Dynamic` no longer re-exports all of `Data.Typeable` (only the `Typeable` class).
* The type signature of `fromLabel` has changed:

{{{#!hs
fromLabel :: Proxy# x -> a -- old type signature
fromLabel ::             a -- new type signature
}}}

  The new `fromLabel` can be accommodated using `TypeApplications`:

{{{#!hs
fromLabel (proxy# :: Proxy# "foo") :: alpha -- old style
fromLabel @"foo"                   :: alpha -- new style
}}}

=== `template-haskell-2.12.0.0`

 * The `DataD`, `NewtypeD`, `DataInstD`, and `NewtypeInstD` constructors now take a `[DerivCxtQ]` instead of a `CxtQ` to represent `deriving` clauses (#10598). This change was necessary because:
  * Due to the introduction of [https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/DerivingStrategies deriving strategies], data types can now accept multiple deriving clauses (hence the need for `[DerivCxtQ]` instead of `DerivCxtQ`).
  * Each deriving clause now allows an optional strategy keyword, so a new `DerivClause` data type was introduced that contains a `Maybe DerivStrategy` in addition to the usual `Cxt`.
 Similarly, the `StandaloneDerivD` constructor now also takes an additional `Maybe DerivStrategy` argument, since deriving strategy keywords can also be used with standalone `deriving` declarations. The `standaloneDerivD` function's type signature remains unchanged, as it will produce a standalone deriving declaration with no strategy keyword. If you want to use an explicit keyword, use `standaloneDerivWithStrategyD`.


----------------------------------
== Tool changes

----------------------------------
== GHC API changes

* TODO The `StaticFlags` module has been removed