[[PageOutline]]

= GHC 8.2.x Migration Guide =

This guide summarises the changes you may need to make to your code to migrate from GHC 8.0 to GHC 8.2. This guide complements the GHC 8.2.x release notes which should be consulted as well.

----------------------------------
== Compiler changes

=== Impredicative types removed
Note that the `-XImpredicativeTypes` extension, which has been
[[ImpredicativePolymorphism|known]] to be broken for many years. It has now at long last been removed. '''RGS''': is this really true?

=== `DefaultSignatures` is pickier
There a new validity check for default class method implementations using `-XDefaultSignatures`. In particular, if you have a class `Foo`:

{{{#!hs
class Foo a where
  bar :: C => a -> b -> b
}}}

and you add a default type signature for `bar`, it //must// be of the form:

{{{#!hs
  default bar :: C' => a -> b -> b
}}}

That is, the right-hand sides of the type signatures must be the same, but the contexts `C` and `C'` are allowed to be different. That means that these default type signatures for `bar`:

{{{#!hs
  default bar :: C' => b -> a -> b
  default bar :: C' => b -> b -> a
  default bar :: C' => a -> b -> b -> b
}}}

will all be rejected.

These will also be rejected:

{{{#!hs
  default bar :: C' => a -> Int -> Int
  default bar :: C' => a -> TF b -> TF b
}}}

(where `TF` is a type family). But it's possible to rearrange these into equivalent forms that GHC accepts: just use type equalities!

{{{#!hs
  default bar :: (C', b ~ Int)  => a -> b -> b
  default bar :: (C', b ~ TF c) => a -> b -> b
}}}

As shown in the `TF` example, you might have to create new type variables (e.g., `c`) to make the type equalities work out.

--------------------------------
== Library changes

=== `base-4.10.0.0`

* TODO: Type-indexed `Typeable` changes
  * The `Data.Typeable.Internal` module has been removed
  * `Data.Typeable.TypeRep` is now a type synonym (so you may need `FlexibleInstances` to create an instance for it, unless you switch it to use `Type.Reflection.SomeTypeRep`)

=== `template-haskell-2.12.0.0`

 * The `DataD`, `NewtypeD`, `DataInstD`, and `NewtypeInstD` constructors now take a `[DerivCxtQ]` instead of a `CxtQ` to represent `deriving` clauses (#10598). This change was necessary because:
  * Due to the introduction of [https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/DerivingStrategies deriving strategies], data types can now accept multiple deriving clauses (hence the need for `[DerivCxtQ]` instead of `DerivCxtQ`).
  * Each deriving clause now allows an optional strategy keyword, so a new `DerivClause` data type was introduced that contains a `Maybe DerivStrategy` in addition to the usual `Cxt`.
 Similarly, the `StandaloneDerivD` constructor now also takes an additional `Maybe DerivStrategy` argument, since deriving strategy keywords can also be used with standalone `deriving` declarations. The `standaloneDerivD` function's type signature remains unchanged, as it will produce a standalone deriving declaration with no strategy keyword. If you want to use an explicit keyword, use `standaloneDerivWithStrategyD`.


----------------------------------
== Tool changes

----------------------------------
== GHC API changes

