[[PageOutline]]

= GHC 8.0.x Migration Guide =

This guide summarises the changes you may need to make to your code to migrate from GHC 7.10 to GHC 8.0

----------------------------------
== Compiler changes

=== `-fwarn-pointless-pragmas`

This flag has been removed and replaced by two flags `-Wmissed-specialisations` and `-Wall-missed-specialisations`.

=== Old GADT record syntax

The old syntax for record constructors for a GADT has been removed

{{{#!hs
-- Old Syntax
data G2 a :: * where
  G2A { g2a :: a, g2b :: Int } :: G2 a

-- New Syntax
data G2 a :: * where
  G2A :: { g2a :: a, g2b :: Int } -> G2 a

}}}

This flag was widely regarded as a misfeature, in prior versions it issued a deprecation warning, it it now not supported at all.

=== Old QuasiQuote syntax

The old syntax which allowed quotes to be prefixed by `$` has been removed. 

{{{#!hs
-- Old Syntax
foo = [$e| ... ] 

-- New Syntax
foo = [e| ... ]
}}}

== Pattern Synonym Signatures 

1. The ordering of the constraints has been changed so that required constraints appear before provided constraints. 

2. A single set of constraints corresponds to a set of required rather than provided constraints. 


--------------------------------
== Library changes

=== `base-4.9.0.0`


==== Normalise `Applicative`/`Monad` instance definitions 

`base-4.9.0.0` continues to generalise functions from `Monad` to `Applicative`. However, in order to avoid performance regressions due to sub-optimally defined `Applicative`/`Monad` instances, it's highly advised to follow the
[[Migration/7.10#GHCsaysNoinstanceforApplicative... | AMP+MRP refactoring guidelines ]] that were already provided in the [[Migration/7.10|GHC 7.10.x Migration Guide]].

A new warning that needs to be enabled via `-fwarn-noncanonical-monad-instances` is available to help detect code which may be at risk.


==== New `Generic` metadata representation ====

GHC 8.0 changes the way GHC generics encodes metadata. Previously, an empty data type would be generated for every datatype, constructor, and record selector associated with a `Generic` instance. For example:

{{{#!hs
data Example a = Example a deriving Generic
}}}

would have generated the following code prior to GHC 8.0:

{{{#!hs
instance Generic (Example a) where
  type Rep (Example a) =
    D1 D1Example
      (C1 C1_0Example
        (S1 NoSelector (Rec0 a)))
  ...

data D1Example
data C1_0Example

instance Datatype D1Example where ...
instance Constructor C1_0Example where ...
}}}

GHC 8.0, on the other hand, does not generate empty data types. The `M1` data type in `GHC.Generics` has been modified so that it is parameterized by a new `Meta` type:

{{{#!hs
data Meta = MetaData Symbol Symbol Symbol Bool
          | MetaCons Symbol FixityI Bool
          | MetaSel  (Maybe Symbol) SourceUnpackedness SourceStrictness DecidedStrictness

newtype M1 (i :: *) (c :: Meta) (f :: * -> *) (p :: *) = M1 { unM1 :: f p }
type D1 = M1 D
type C1 = M1 C
type S1 = M1 S
}}}

There is now only one instance for `Datatype`, `Constructor`, and `Selector`. (For more information on how this works, see [https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/GenericDeriving#Type-levelmetadataencoding this].)

{{{#!hs
instance Datatype ('MetaData n m p nt) where ...
instance Constructor ('MetaCons n f r) where ...
instance Selector ('MetaSel mn su ss ds) where ...
}}}

One major consequence of the additions to `MetaSel` is that the `NoSelector` datatype is insufficient to express all of the strictness properties of a record selector, so `NoSelector` was removed. If your generics-related code only mentions the `Datatype`, `Constructor`, and `Selector` typeclasses, it will not need to change. If your code does something more ambitious like checking for the presence of `NoSelector`, it will need to be updated to use `MetaSel` instead. For example, the above `Example` would have the following code generated:

{{{#!hs
instance Generic (Example a) where
  type Rep (Example a) =
    D1 ('MetaData "Example" "Module" "package" 'False)
      (C1 ('MetaCons "Example" 'PrefixI 'False)
        (S1 ('MetaSel 'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
          (Rec0 a)))
}}}

Notice that since `Example` has no record selector, it generated `('MetaSel 'Nothing ...)` instead of `('MetaSel ('Just "recordName") ...)`.

==== ...
TODO

...

=== `template-haskell-2.11.0.0`

 - The constructors of the `Info` type now have one field less (TODO: more details)

 - The `Strict` datatype has been overhauled. The functional equivalent of `Strict` in `template-haskell-2.11.0.0` is `Bang`:
   
   {{{#!hs
   data Bang = Bang SourceUnpackedness SourceStrictness
   
   data SourceUnpackedness
     = NoSourceUnpackedness -- ^ @C                  a@
     | SourceNoUnpack       -- ^ @C {-# NOUNPACK #-} a@
     | SourceUnpack         -- ^ @C {-# UNPACK #-}   a@
   
   data SourceStrictness = NoSourceStrictness    -- ^ @C  a@
                         | SourceLazy            -- ^ @C ~a@
                         | SourceStrict          -- ^ @C !a@
   
   type BangType    = (Bang, Type)
   type VarBangType = (Name, Bang, Type)
   }}}

   Note that the notions of unpackedness and strictness, which were previously combined in `Strict`, have now been decoupled. Also note the emphasis on ''source'', as `Bang` represents what the user writes in source code. A field's ''source'' strictness may be quite different from what GHC actually ''decides'' to use as a field's strictness.
   
   For example, if `-XStrict` is enabled, GHC will decided that any field not marked with a laziness annotation (`~`) will become strict. So if you compile the following datatype with `-XStrict` enabled:
   
   {{{#!hs
   data Example a = Example a
   }}}
   
   GHC will decide that `Example`'s field is strict. However, if you reify `Example`, its `Bang` value will be `Bang NoSourceUnpackedness NoSourceStrictness` because the user did not put an explicit strictness annotation (`!`) in the source code. To figure out what GHC decided, use the `reifyConStrictness` function:
   
   {{{#!hs
   reifyConStrictness :: Name -> Q [DecidedStrictness]
   
   data DecidedStrictness = DecidedLazy
                          | DecidedStrict
                          | DecidedUnpack
   }}}

----------------------------------
== Tool changes

=== `hsc2hs` defines an `#alignment` macro

`hsc2hs` now supports the `#alignment` macro, which can be used to calculate the alignment of a struct in bytes. It is common for `.hsc` files to implement `#alignment` manually via a `#let` directive:

{{{#!hs
#let alignment t = "%lu", (unsigned long)offsetof(struct {char x__; t (y__); }, y__)
}}}

This command was incorporated into `hsc2hs` with the release of GHC 8.0. As a result, if you have the above directive in your code, it will now emit a warning when compiled with GHC 8.0:

{{{
Module.hsc:24:0: warning: "hsc_alignment" redefined [enabled by default]
In file included from dist/build/Module_hsc_make.c:1:0:
/path/to/ghc/lib/template-hsc.h:88:0: note: this is the location of the previous definition
 #define hsc_alignment(t...) \
 ^
}}}

To make your code free of warnings on GHC 8.0 and earlier versions, surround the directive with a pragma checking for the right GHC version:

{{{#!hs
#if __GLASGOW_HASKELL__ < 800
#let alignment t = "%lu", (unsigned long)offsetof(struct {char x__; t (y__); }, y__)
#endif
}}}