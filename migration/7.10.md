# GHC 7.10.x Migration Guide

## Library changes

### `base-4.8.0.0`


The major changes include the implementation of the *Functor/Applicative/Monad-Proposal* as well as the *Foldable/Traversable-Proposal*

#### GHC complains `No instance for (Applicative ...)`


If GHC complains that

```wiki
Foo.hs:7:10:
    No instance for (Applicative Foo) arising from the superclasses of an instance declaration
    In the instance declaration for ‘Monad Foo’
```


then the easiest way to fix this error is by defining an `Applicative` (and possibly a `Functor`) instance:

```
instanceFunctorFoowhere
    fmap  = liftM

instanceApplicativeFoowhere
    pure  = return
    (<*>)= ap  -- defined in Control.Monad
```


For more details see [ AMP Proposal: Future-proofing current code](https://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal#Future-proofing_current_code).

### `deepseq-1.4.0.0`


The default method implementation has been changed, so instances defined via

```
instanceNFDataFoo
```


will now result in the following compile error (unless a `Generic` instance happens to exist):

```wiki
Foo.hs:5:10:
    No instance for (GHC.Generics.Generic Foo) arising from a use of ‘Control.DeepSeq.$gdmrnf’
    In the expression: Control.DeepSeq.$gdmrnf
    In an equation for ‘rnf’: rnf = Control.DeepSeq.$gdmrnf
    In the instance declaration for ‘NFData Foo’
```


The easiest way make code work again with `deepseq-1.4.0.0` which was relying on the pre-1.4 default method implementation of `rnf` is to explicitly define `rnf` like so

```
instanceNFDataFoowhere rnf x = seq x ()
```


instead of relying on the default method implementation.


For more details (and how to use the new facilities) see Haddock documentation of [ hackage:deepseq](http://hackage.haskell.org/package/deepseq)