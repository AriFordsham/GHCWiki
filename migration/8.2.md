# GHC 8.2.x Migration Guide


This guide summarises the changes you may need to make to your code to migrate from GHC 8.0 to GHC 8.2. This guide complements the GHC 8.2.x release notes which should be consulted as well.

---

## Compiler changes

### Impredicative types removed


Note that the `-XImpredicativeTypes` extension, which has been
[known](impredicative-polymorphism) to be broken for many years. It has now at long last been removed. **RGS**: is this really true?

### `DefaultSignatures` is pickier


There a new validity check for default class method implementations using `-XDefaultSignatures`. In particular, if you have a class `Foo`:

```
classFoo a where
  bar ::C=> a -> b -> b
```


and you add a default type signature for `bar`, it *must* be of the form:

```
default bar ::C'=> a -> b -> b
```


That is, the right-hand sides of the type signatures must be the same, but the contexts `C` and `C'` are allowed to be different. That means that these default type signatures for `bar`:

```
default bar ::C'=> b -> a -> b
  default bar ::C'=> b -> b -> a
  default bar ::C'=> a -> b -> b -> b
```


will all be rejected.


These will also be rejected:

```
default bar ::C'=> a ->Int->Intdefault bar ::C'=> a ->TF b ->TF b
```


(where `TF` is a type family). But it's possible to rearrange these into equivalent forms that GHC accepts: just use type equalities!

```
default bar ::(C', b ~Int)=> a -> b -> b
  default bar ::(C', b ~TF c)=> a -> b -> b
```


As shown in the `TF` example, you might have to create new type variables (e.g., `c`) to make the type equalities work out.

### Associated type family instances are pickier


There is also a new validity check for associated type family instances. That is, if you have a class with an associated type family:

```
classC a b wheretypeT a x b
```


And you create and instance of `C`:

```
instanceC ty1 ty2 where...
```


Then the associated `T` instance must look *exactly* like:

```
typeT ty1 v ty2 =...-- 'ty1' for 'a'-- 'ty2' for 'b', and-- some type `v` for 'x'
```


As a concrete example, this code, which would have been allowed before GHC 8.2, is now disallowed:

```
classFoo a wheretypeBar a

instanceFoo(Either a b)wheretypeBar(Either c d)= d -> c
```


To fix this instance, simply use the same type variables in the `Bar` instance as in the instance head:

```
instanceFoo(Either a b)wheretypeBar(Either a b)= b -> a
```

---

## Library changes

### `base-4.10.0.0`

- TODO Type-indexed `Typeable` changes

  - The `Data.Typeable.Internal` module has been removed
  - `Data.Typeable.TypeRep` is now a type synonym (so you may need `FlexibleInstances` to create an instance for it, unless you switch it to use `Type.Reflection.SomeTypeRep`)
  - `mkFunTy`, `mkAppTy`, `mkTyConApp`, and `mkTyCon3` have been removed

### `template-haskell-2.12.0.0`

- The `DataD`, `NewtypeD`, `DataInstD`, and `NewtypeInstD` constructors now take a `[DerivCxtQ]` instead of a `CxtQ` to represent `deriving` clauses ([\#10598](https://gitlab.haskell.org//ghc/ghc/issues/10598)). This change was necessary because:

  - Due to the introduction of [ deriving strategies](https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/DerivingStrategies), data types can now accept multiple deriving clauses (hence the need for `[DerivCxtQ]` instead of `DerivCxtQ`).
  - Each deriving clause now allows an optional strategy keyword, so a new `DerivClause` data type was introduced that contains a `Maybe DerivStrategy` in addition to the usual `Cxt`.

>
> Similarly, the `StandaloneDerivD` constructor now also takes an additional `Maybe DerivStrategy` argument, since deriving strategy keywords can also be used with standalone `deriving` declarations. The `standaloneDerivD` function's type signature remains unchanged, as it will produce a standalone deriving declaration with no strategy keyword. If you want to use an explicit keyword, use `standaloneDerivWithStrategyD`.

---

## Tool changes

---

## GHC API changes