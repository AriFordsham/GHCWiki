[[PageOutline]]

= GHC 8.6.x Migration Guide =

This guide summarises the changes you may need to make to your code to migrate from GHC 8.4 to GHC 8.6. This guide complements the GHC 8.6.x release notes which should be consulted as well.

----------------------------------
== Compiler changes

=== `StarIsType` ===

As part of [https://github.com/ghc-proposals/ghc-proposals/blob/05721788de9ab6538def68c3c2c9dec50c9f24a8/proposals/0020-no-type-in-type.rst this GHC proposal], a new `StarIsType` extension was introduced, which instructs GHC to treat `*` as a synonym for `Type` (from `Data.Kind`) instead of a binary type operator.

`StarIsType` is enabled by default, and one consequence of this is that GHC will interpret any use of `*` as `Type`, even if it would have been previously interpreted as a binary type operator. A notable example of such a binary type operator is `GHC.TypeLits.*`, so code like:

{{{#!hs
import GHC.TypeLits

f :: Proxy m -> Proxy n -> Proxy (m * n)
f _ _ = Proxy
}}}

Will not typecheck if `StarIsType` is enabled, since `m * n` is treated as if one had written `m Type n`. There are two ways to adapt to this:

1. Use `*` qualified (e.g., `Proxy (m GHC.TypeLits.* n`). This approach is compliant with the GHC three-release policy, as it does not require CPP to support older GHCs.
2. Enable the `NoStarIsType` extension. Since `(No)StarIsType` did not exist on older GHCs, this approach will require CPP in order to support older compilers.

=== Constructor-less GADTs now require `GADTSyntax` ===

Data types with empty `where` clauses (such as `data T where`) are no longer valid without the `GADTSyntax` extension. (Due to an oversight, previous versions of GHC would accept them without the extension enabled.)

=== `-Wincomplete-patterns` now applies to patterns in guards and `MultiWayIf`

Due to a bug, previous versions of GHC would not emit any `-Wincomplete-patterns` warnings at all for incomplete patterns inside of guards or `MultiWayIf` expressions. This bug has been fixed, which means that code like:

{{{#!hs
foo :: Bool -> Int
foo b = if | b -> 1
}}}

Will now raise a warning in GHC 8.6:

{{{
warning: [-Wincomplete-patterns]
    Pattern match(es) are non-exhaustive
    In a multi-way if alternative:
        Guards do not cover entire pattern space
}}}

=== `PolyKinds` is pickier

GHC is now more diligent about catching illegal uses of kind polymorphism that snuck into recent GHC releases. For instance, this used to be accepted without `PolyKinds`:

{{{#!hs
class C a where
  c :: Proxy (x :: a)
}}}

Despite the fact that `a` is used as a kind variable in the type signature for `c`. This is now an error unless `PolyKinds` is explicitly enabled.

Moreover, GHC 8.4 would accept the following without the use of `PolyKinds`:

{{{#!hs
f :: forall k (a :: k). Proxy a
f = Proxy
}}}

Despite the fact that `k` is used as both a type and kind variable. This is now an error unless `PolyKinds` is explicitly enabled.

--------------------------------
== Library changes

TODO