[[PageOutline]]

= GHC 8.8.x Migration Guide =

This guide summarises the changes you may need to make to your code to migrate from GHC 8.6 to GHC 8.8. This guide complements the GHC 8.8.x release notes which should be consulted as well.

----------------------------------
== Compiler changes

=== Kind generalization changes for local definitions

Starting in GHC 8.8, we now generalize the kinds in the types of local definitions (e.g., `let`- or `where`-bound functions). As a result, there are a handful of programs which will no longer compile. Here is one such example:

{{{#!hs
type family LetGo :: k

foo :: Proxy (LetGo :: Type)
foo = undefined

sSconcat :: forall (x :: Type). x
sSconcat = undefined
   where sGo :: x -> Proxy LetGo
         sGo _ = foo
}}}

This kind-checks on previous versions of GHC, since the return kind of `LetGo` (in `sGo`) is not generalized, so we have `sGo :: x -> Proxy (LetGo :: Type)` (which is necessary for the body of `sGo` to typecheck). However, this will //not// kind-check on GHC 8.8, since the return kind of `LetGo` //is// generalized, giving us `sGo :: x -> Proxy (LetGo :: k)` (which is too polymorphic for `foo`). Therefore, this code fails on GHC 8.8 with a `Couldn't match type ‘k’ with ‘*’` error.

To avoid this, one can use an explicit kind signature on `LetGo`, like so:

{{{#!hs
  sGo :: x -> Proxy (LetGo :: Type)
  sGo _ = foo
}}}

=== Template Haskell reification change for classes

If you have a type class like this:

{{{#!hs
class C a where
  method :: a
}}}

Then in previous versions of GHC, reifying `C` would give you something like this:

{{{#!hs
class C a where
  method :: forall a. C a => a
}}}

Notice that that `forall a. C a =>` in the type signature for `method` is completely redundant, since that's implied by the fact that it's a class method of `C`. This oversight has been fixed, so reifying `C` will now give you simply `a` as the type signature for `method`.

There may be code in the wild that previously depended on the assumption that reifying a class would put these redundant tyvars/class contexts at the front of each method's type signature, so it's possible that there may be breakage because of this.

--------------------------------
== Library changes

TODO