[[PageOutline]]

= GHC 7.10.x Migration Guide =

== Compiler changes

=== Inferred type-signatures now may require to enable `FlexibleContexts`, `GADTs`, or `TypeFamilies`

Basically GHC has become stricter and needs to explicitly enable language extensions in some cases that weren't needed previously. GHC will tell you which extension to enable. See also #8883 for details.

Example breakages:

 - https://github.com/haskell/HTTP/issues/62
 - https://github.com/bos/attoparsec/issues/67
 - https://github.com/diagrams/force-layout/pull/1

== Library changes

=== `base-4.8.0.0`

The major changes include the implementation of the ''Functor/Applicative/Monad-Proposal'' as well as the ''Foldable/Traversable-Proposal''

==== GHC says `No instance for (Applicative ...)` ====

If GHC complains that

{{{
Foo.hs:7:10:
    No instance for (Applicative Foo) arising from the superclasses of an instance declaration
    In the instance declaration for ‘Monad Foo’
}}}

then the easiest way to fix this error is by defining an `Applicative` (and possibly a `Functor`) instance:

{{{#!hs
instance Functor Foo where
    fmap  = liftM

instance Applicative Foo where
    pure  = return
    (<*>) = ap  -- defined in Control.Monad
}}}

For more details see [https://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal#Future-proofing_current_code AMP Proposal: Future-proofing current code].

==== GHC says `No instance for (Alternative ...)` ====

A side-effect of the AMP is that `Alternative` became a super-class of `MonadPlus`. The easy remedy:

{{{#!hs
instance Alternative Foo where
    (<|>) = mplus
    empty = mzero
}}}

==== GHC says `No instance for (Foldable ...) arising from the use of...` ====

Some functions in the Prelude were generalised to `Foldable`s in the implementation of the FTP. This can lead to type-inference problems for code making use of `-XOverloadedStrings`, in which code like e.g.

{{{#!hs
{-# LANGUAGE OverloadedStrings #-}

main :: IO ()
main = print ('I' `elem` "team")
}}}

will let GHC spit out the intimidating complaint that

{{{
Foo.hs:4:19:
    No instance for (Foldable t0) arising from a use of ‘elem’
    The type variable ‘t0’ is ambiguous
    Note: there are several potential instances:
      instance Foldable (Either a) -- Defined in ‘Data.Foldable’
      instance Foldable Data.Proxy.Proxy -- Defined in ‘Data.Foldable’
      instance GHC.Arr.Ix i => Foldable (GHC.Arr.Array i) -- Defined in ‘Data.Foldable’
      ...plus three others
    In the first argument of ‘print’, namely ‘('I' `elem` "team")’
    In the expression: print ('I' `elem` "team")
    In an equation for ‘main’: main = print ('I' `elem` "team")

Foo.hs:4:26:
    No instance for (Data.String.IsString (t0 Char)) arising from the literal ‘"team"’
    The type variable ‘t0’ is ambiguous
    Note: there is a potential instance available: instance Data.String.IsString [Char] -- Defined in ‘Data.String’
    In the second argument of ‘elem’, namely ‘"team"’
    In the first argument of ‘print’, namely ‘('I' `elem` "team")’
    In the expression: print ('I' `elem` "team")
}}}

This can be fixed by helping GHC's type-inference to pin down `"team"` to `[Char]`, either by adding a `:: String` to the string literal, or (for short literals) by using list-syntax (i.e. `['t','e','a','m']`).

=== `deepseq-1.4.0.0`

The default method implementation has been changed, so instances defined via

{{{#!hs
instance NFData Foo
}}}

will now result in the following compile error (unless a `Generic` instance happens to exist):

{{{
Foo.hs:5:10:
    No instance for (GHC.Generics.Generic Foo) arising from a use of ‘Control.DeepSeq.$gdmrnf’
    In the expression: Control.DeepSeq.$gdmrnf
    In an equation for ‘rnf’: rnf = Control.DeepSeq.$gdmrnf
    In the instance declaration for ‘NFData Foo’
}}}

The easiest way make code work again with `deepseq-1.4.0.0` which was relying on the pre-1.4 default method implementation of `rnf` is to explicitly define `rnf` like so

{{{#!hs
instance NFData Foo where rnf x = seq x ()
}}}

instead of relying on the default method implementation.

For more details (and how to use the new facilities) see Haddock documentation of hackage:deepseq