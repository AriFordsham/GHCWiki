# GHC 8.0.x Migration Guide


This guide summarises the changes you may need to make to your code to migrate from GHC 7.10 to GHC 8.0

---

## Compiler changes

### `-fwarn-pointless-pragmas`


This flag has been removed and replaced by two flags `-Wmissed-specialisations` and `-Wall-missed-specialisations`.

### Old GADT record syntax


The old syntax for record constructors for a GADT has been removed

```
-- Old SyntaxdataG2 a ::*whereG2A{ g2a :: a, g2b ::Int}::G2 a

-- New SyntaxdataG2 a ::*whereG2A::{ g2a :: a, g2b ::Int}->G2 a

```


This flag was widely regarded as a misfeature, in prior versions it issued a deprecation warning, it it now not supported at all.

### Old QuasiQuote syntax


The old syntax which allowed quotes to be prefixed by `$` has been removed. 

```
-- Old Syntaxfoo=[$x|...]-- New Syntaxfoo=[x|...]
```

### `-fwarn-unused-matches`


If your code uses type families, you might experience new warnings when `-fwarn-unused-matches` is enabled (which is implied by `-Wall`). For example, this code:

```
typefamilyConst a b whereConst a b = a
```


emits the following warning when compiled with GHC 8.0:

```wiki
warning: Defined but not used: type variable ‘b’
```


since `b` is used once on the left-hand side of a type family equation but not used on the right-hand side. A backwards-compatible way to suppress this warning is to add an underscore to the beginning of the type variable, i.e., `Const a _b = a`.

### Kind-level definitions shuffled around


If you're using various bits of magic from within GHC and importing from `GHC.Prim` (for example, for `Constraint`), you'll find that some definitions have moved around. There is a simple fix: import from `GHC.Exts` instead. That module re-exports all of `GHC.Prim` and a few other internal modules. This change is also backward-compatible.

## Pattern Synonym Signatures

1. The ordering of the constraints has been changed so that required constraints appear before provided constraints. 

1. A single set of constraints corresponds to a set of required rather than provided constraints. 


For example:

```
--beforepatternP1:: prov => req => ty

patternP2:: prov => ty

patternP3::()=> req => ty

patternP4:: ty

-- after patternP1:: req => prov => ty

patternP2::()=> prov => ty

patternP3:: req => ty

patternP4:: ty

```

---

## Library changes

### `base-4.9.0.0`

#### Normalise `Applicative`/`Monad` instance definitions

`base-4.9.0.0` continues to generalise functions from `Monad` to `Applicative`. However, in order to avoid performance regressions due to sub-optimally defined `Applicative`/`Monad` instances, it's highly advised to follow the
[ AMP+MRP refactoring guidelines ](migration/7.10#) that were already provided in the [GHC 7.10.x Migration Guide](migration/7.10).


A new warning that needs to be enabled via `-Wnoncanonical-monad-instances` is available to help detect code which may be at risk.

#### New `Generic` metadata representation


GHC 8.0 changes the way GHC generics encodes metadata. Previously, an empty data type would be generated for every datatype, constructor, and record selector associated with a `Generic` instance. For example:

```
dataExample a =Example a derivingGeneric
```


would have generated the following code prior to GHC 8.0:

```
instanceGeneric(Example a)wheretypeRep(Example a)=D1D1Example(C1C1_0Example(S1NoSelector(Rec0 a)))...dataD1ExampledataC1_0ExampleinstanceDatatypeD1Examplewhere...instanceConstructorC1_0Examplewhere...
```


GHC 8.0, on the other hand, does not generate empty data types. The `M1` data type in `GHC.Generics` has been modified so that it is parameterized by a new `Meta` type:

```
dataMeta=MetaDataSymbolSymbolSymbolBool|MetaConsSymbolFixityIBool|MetaSel(MaybeSymbol)SourceUnpackednessSourceStrictnessDecidedStrictnessnewtypeM1(i ::*)(c ::Meta)(f ::*->*)(p ::*)=M1{ unM1 :: f p }typeD1=M1DtypeC1=M1CtypeS1=M1S
```


There is now only one instance for `Datatype`, `Constructor`, and `Selector`. (For more information on how this works, see [ this](https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/GenericDeriving#Type-levelmetadataencoding).)

```
instanceDatatype('MetaData n m p nt)where...instanceConstructor('MetaCons n f r)where...instanceSelector('MetaSel mn su ss ds)where...
```


One major consequence of the additions to `MetaSel` is that the `NoSelector` datatype is insufficient to express all of the strictness properties of a record selector, so `NoSelector` was removed. If your generics-related code only mentions the `Datatype`, `Constructor`, and `Selector` typeclasses, it will not need to change. If your code does something more ambitious like checking for the presence of `NoSelector`, it will need to be updated to use `MetaSel` instead. For example, the above `Example` would have the following code generated:

```
instanceGeneric(Example a)wheretypeRep(Example a)=D1('MetaData"Example""Module""package"'False)(C1('MetaCons"Example"'PrefixI'False)(S1('MetaSel'Nothing'NoSourceUnpackedness'NoSourceStrictness'DecidedLazy)(Rec0 a)))
```


Notice that since `Example` has no record selector, it generated `('MetaSel 'Nothing ...)` instead of `('MetaSel ('Just "recordName") ...)`.

#### …

TODO


...

### `template-haskell-2.11.0.0`

- Three `Info` constructors (`ClassOpI`, `DataConI`, and `VarI`) no longer have a `Fixity` field. Instead, all `Fixity` information for a given `Name` is now determined through the `reifyFixity` function, which returns `Just` the fixity if there is an explicit fixity declaration for that `Name`, and `Nothing` otherwise.

- the `DataD`, `NewtypeD`, `DataInstD`, and `NewtypeInstD` constructors have a new field `Maybe Kind` ([\#10828](https://gitlab.haskell.org//ghc/ghc/issues/10828)), and take a `CxtQ` instead of a `[Name]` for the derived classes ([\#10819](https://gitlab.haskell.org//ghc/ghc/issues/10819)). If you don't know what to do, use `Nothing` for the kind signature, and `cxt []` for the derived classes.

  ```wiki
      - dataD :: CxtQ -> Name -> [TyVarBndr]               -> [ConQ] -> [Name] -> DecQ
      + dataD :: CxtQ -> Name -> [TyVarBndr] -> Maybe Kind -> [ConQ] -> CxtQ   -> DecQ

      - newtypeD :: CxtQ -> Name -> [TyVarBndr]               -> ConQ -> [Name] -> DecQ
      + newtypeD :: CxtQ -> Name -> [TyVarBndr] -> Maybe Kind -> ConQ -> CxtQ   -> DecQ

      - dataInstD :: CxtQ -> Name -> [TypeQ]               -> [ConQ] -> [Name] -> DecQ
      + dataInstD :: CxtQ -> Name -> [TypeQ] -> Maybe Kind -> [ConQ] -> CxtQ   -> DecQ

      - newtypeInstD :: CxtQ -> Name -> [TypeQ]               -> ConQ -> [Name] -> DecQ
      + newtypeInstD :: CxtQ -> Name -> [TypeQ] -> Maybe Kind -> ConQ -> CxtQ   -> DecQ
  ```

- The `Strict` datatype has been overhauled. The functional equivalent of `Strict` in `template-haskell-2.11.0.0` is `Bang`:

```
dataBang=BangSourceUnpackednessSourceStrictnessdataSourceUnpackedness=NoSourceUnpackedness-- ^ @C                  a@|SourceNoUnpack-- ^ @C {-# NOUNPACK #-} a@|SourceUnpack-- ^ @C {-# UNPACK #-}   a@dataSourceStrictness=NoSourceStrictness-- ^ @C  a@|SourceLazy-- ^ @C ~a@|SourceStrict-- ^ @C !a@typeBangType=(Bang,Type)typeVarBangType=(Name,Bang,Type)
```

> >
> > Note that the notions of unpackedness and strictness, which were previously combined in `Strict`, have now been decoupled. Also note the emphasis on *source*, as `Bang` represents what the user writes in source code. A field's *source* strictness may be quite different from what GHC actually *decides* to use as a field's strictness.

> >
> > For example, if `-XStrict` is enabled, GHC will decided that any field not marked with a laziness annotation (`~`) will become strict. So if you compile the following datatype with `-XStrict` enabled:

```
dataExample a =Example a
```

> >
> > GHC will decide that `Example`'s field is strict. However, if you reify `Example`, its `Bang` value will be `Bang NoSourceUnpackedness NoSourceStrictness` because the user did not put an explicit strictness annotation (`!`) in the source code. To figure out what GHC decided, use the `reifyConStrictness` function:

```
reifyConStrictness::Name->Q[DecidedStrictness]dataDecidedStrictness=DecidedLazy|DecidedStrict|DecidedUnpack
```

---

## Tool changes

### `hsc2hs` defines an `#alignment` macro

`hsc2hs` now supports the `#alignment` macro, which can be used to calculate the alignment of a struct in bytes. It is common for `.hsc` files to implement `#alignment` manually via a `#let` directive:

```
#let alignment t ="%lu",(unsigned long)offsetof(struct {char x__; t (y__);}, y__)
```


This command was incorporated into `hsc2hs` with the release of GHC 8.0. As a result, if you have the above directive in your code, it will now emit a warning when compiled with GHC 8.0:

```wiki
Module.hsc:24:0: warning: "hsc_alignment" redefined [enabled by default]
In file included from dist/build/Module_hsc_make.c:1:0:
/path/to/ghc/lib/template-hsc.h:88:0: note: this is the location of the previous definition
 #define hsc_alignment(t...) \
 ^
```


To make your code free of warnings on GHC 8.0 and earlier versions, surround the directive with a pragma checking for the right GHC version:

```
#if __GLASGOW_HASKELL__ <800#let alignment t ="%lu",(unsigned long)offsetof(struct {char x__; t (y__);}, y__)#endif
```