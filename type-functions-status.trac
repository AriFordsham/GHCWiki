[wiki:TypeFunctions]/Status

= Type Functions: Implementation Status =

'''Debugging of type family patch:'''
 0. #1651; fixed the panic, remains the bogus missing instance error
 0. Check that the restrictions on equality constraints in instance and class contexts are enforced.  We should have tests for that in the testsuite.  Document the exact restrictions on the Haskell wiki tutorial page. '''[Tom is working at this.]'''
 0. To fix `Simple8`:
   * Fix tcLookupFamInst to gracefully handle this case.  (This requires some care to not violate assumptions made by other  clients of this function, as it is also used for data families,  but I see no fundamental problem.)
* Issue a warning if there are two identical instances (as per  Roman's suggestion).
 0. `boxySplitTyConApp` and friends must be able to deal with `orig_ty`s that have outermost type family applications; i.e., they need to try to normalise and possibly have to defer.  They also need to defer on skolems.  Consequently, they also need to return a coercion.  This , in particular, affects the treatment of literal lists, parallel arrays, and tuples in`TcExpr.tcExpr` is fishy.
 0. Can't we now allow non-left-linear declarations; e.g., `instance type F a a = ..`?
 0. Fix export list problem (ie, export of data constructors introduced by orphan data instances):
   * Change `HscTypes.IfaceExport` to use `Name` instead of `OccName`.
   * Then, there is also no need for the grouping of the identifiers by module anymore (but sort it to avoid spurious iface changes dur to re-ordering when re-compiling).
   * We still need to have the name parent map, though.
   * See email for example.
 0. Allow data family GADT instances.
 0. Fix core-lint breakage in cholewo-eval.
 0. The tests `tcfail068` and `rw` used to raise more type errors right away.  Now, we see less recovery.
 0. To move GADT type checking from refinements to using equalities, proceed as follows (as suggested by SPJ):
    * In `TcPat.tcConPat`:
      * set `eq_spec' = []`, to get an empty refinement
      * add the equalities from `eq_spec` to `theta'` (to propagate them instead of the refinement)
    * Test whether this works (it basically disables the refinement mechanism without deleting it)
    * In `TcUnify`, make all occurs checks more elaborate.  They should only '''defer''' if the checked variable occurs as part of an argument to a type family application; in other cases, still fail right away.
    * `TcGadt.tcUnifyTys` can now probably be replaced again by the non-side-effecting unifier that was in `types/Unify.hs` (recover from previous repo states).
 0. Emit a warning if there are two ''identical'' type instances.

'''Current:'''
 * Add some trac wiki documentation of how inference with type families works.

== Parsing and Renaming ==

Todo (low-level): None.

Todo (high-level):
 1. Defaults for associated type synonyms.  (Having both a kind signature and vanilla synonym is problematic as in `RnNames.getLocalDeclBinders` its hard to see that not both of them are defining declarations, which leads to a multiple declarations error.  Defaults are quite different from vanilla synonyms anyway, as they usually have tyvars on their rhs that do not occur on the lhs.)

Done:
 * Parsing and renaming of kind signatures (toplevel and in classes).
 * Parsing and renaming of indexed type declarations (toplevel and in classes).
 * Using new syntax with `family` and `instance` on top level.
 * Added `-findexed-types` switch.
 * Allowing `type` tag in export lists to list associated types in the sub-binder list of an import/export item for a class.
 * Import/export lists: ATs can be listed as subnames of classes and the data constructors of instances of a data family are subnames of that family.
 * Parsing and renaming of equational constraints in contexts.

== Type Checking ==

Todo (low-level):
 * Allow data family GADT instances.
 * Deriving `Typeable` for data families.
 * If an associated synonym has a default definition, use that in the instances.  In contrast to methods, this cannot be overridden by a specialised definition.  (Confluence requires that any specialised version is extensionally the same as the default.)

Todo (high-level): 
 1. Type checking of type families; routines in `TcUnify` that still need to be extended:
   * `boxySplitTyConApp`: The second argument (`BoxyRhoType`) can be a synonym family application.  Then, we must produce a wanted coercion and return a `HsWrapper` value that applies that coercion.
   * `boxySplitAppTy`: Basically, the same deal as the previous.
 2. Type checking in the presence of associated synonym defaults.  (Default AT synonyms are only allowed for ATs defined in the same class.)
 3. Type check functional dependencies as type functions.

Done: 
 * Kind and type checking of kind signatures.
 * Kind and type checking of instance declarations of indexed types, including the generation of representation tycons.
 * Wrapper generation and type checking of pattern matching for indexed data and newtypes.
 * Consistency checking for family instances.
 * Enforce syntactic constraints on type instances needed to ensure the termination of constraint entailment checking.

== Desugaring ==

Todo (low-level): None.

Todo (high-level): None.

Done:
 * Representation of family kind signatures as `TyCon.TyCon`s.
 * Extension of `Class.Class` by associated `TyCon`s.
 * Extension of `TyCon.TyCon` with a reference to the parent `TyCon` for data instances.
 * Extension of `DataCon.DataCon` with instance types for constructors belonging to data instances.
 * Extension of `TyCon.TyCon` such that the parent of a data instance is paired with a coercion identifying family instance and representation type.
 * For indexed data types, the datacon wrapper uses data instance coercion and pattern matching casts the scrutinee via an `ExprCoFn` in a `CoPat`.
 * Import and exporting.
 * Generation and plumbing through of rough matches.
 * Equational constraints in contexts.

== *OLD* Regression tests of type family patches ==

'''[This is outdated pre-merge info just kept around for a while.]'''

Current `validate` result:
{{{
Unexpected passes:
   Class1(normal)
   GADT2(normal)

Unexpected failures:
   Refl2(normal)
   Simple5a(normal)
   rw(normal)
   tcfail065(normal)
   tcfail068(normal)
   tcfail071(normal)
   tcfail076(normal)
   tcfail102(normal)
   tcfail103(normal)
   tcfail153(normal)
   tcfail179(normal)
}}}

 * Class1: VALID.  (Only marked to fail in head to keep validate happy.)
 * GADT2: VALID.  (Only marked to fail in head to keep validate happy.)
 * Relf2: VALID. Type family BUG.
 * Simple5a: VALID.  Error message changed.
 * ~~break001~~: INVALID.  GHC panic instead of printing error message about ambiguous variable.
 * ~~break006~~: INVALID.  Seems to be the same problem as break001.
 * ~~print019~~: INVALID.  Seems to be the same problem as break001.
 * rw: VALID. Changed error message.  Reports one error less.  Other one is pruned, but still raised if the first one is removed.
 * ~~tc210~~: INVALID (matching `forall a.a -> Int` against `Int -> Int fails).
 * ~~tc211~~: INVALID (tests impredicative types).
 * ~~tcfail046~~: VALID.  Changed error message, BUT the new error message has one more type synonym unfolding, which should be avoided.
 * tcfail065: VALID.  Cosmetic difference, as tidy names are assigned in different order.
 * tcfail068: VALID.  Reports two errors less (probably due to different recovery points).  Yes, I checked that its not that it admits incorrect programs, but just due to different order of checking/pruning of errors.
 * tcfail071: VALID.  Now reports one instead of two errors as deferred unification is checked only after the contexts of mutually recursive groups have been unified.  (The latter is what this test case is really about, and it still works fine for that.)
 * tcfail076: VALID.  Same as tcfail065.
 * tcfail102: VALID.
 * tcfail103: VALID.  Error message is actually better!
 * ~~tcfail128~~: VALID. Same as tcfail046.
 * ~~tcfail145~~: VALID. Error message got worse.
 * tcfail153: VALID.  Error message is different, but equally correct and accurate.  The type mismatch manifests itself at two different subexpressions.  Due to a different traversal order, we now report the error at the other subexpression.
 * tcfail179: VALID.  If anything, the error message improved.
 * while: VALID. Works if definition of `succeed` gets a type signature `Monad m => a -> m a`.  The error seems to be due to the new GADT rules about annotations, but the error message is a bit strange; ie, need to be improved.

Regression tests that are not part of the fast run:
 * cholewo-eval: core-lint breakage
