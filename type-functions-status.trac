= Type Functions: Implementation Status =

Back to TypeFunctions.

'''Current:''' 
 * In the exiting test for datacon validity, `checlValidDataCon`, we need to add a new test that checks for a data instance datacon that its tycon has the `FamilyTyCon` flag set and that it refers to the correct family tycon.
 * Handle `newtype instance`.

== Parsing and Renaming ==

Todo (low-level):
 * Probably remove the `iso` flag.

Todo (high-level):
 1. Make the kind specification optional in family declarations.  (How to do the representation in the data/newtype case is not entirely clear, as we use the presence of the kind signature at the moment to identify family declarations.)
 2. Parse and rename equality constraints in signatures.
 3. Defaults for associated type synonyms.  (Having both a kind signature and vanilla synonym is problematic as in `RnNames.getLocalDeclBinders` its hard to see that not both of them are defining declarations, which leads to a multiple declarations error.  Defaults are quite different from vanilla synonyms anyway, as they usually have tyvars on their rhs that do not occur on the lhs.)

Done:
 * Parsing and renaming of kind signatures (toplevel and in classes).
 * Parsing and renaming of indexed types declarations (toplevel and in classes).
 * Using new syntax with `family` and `instance` on top level.

== Type Checking ==

Todo (low-level):
 * In an AT definition, no argument variable may be repeated.
 * Check that the arguments of AT instances coincide with the respective instance arguments of their class.
 * Check that each class instance has a definition for every AT and conversely that that all defined associated types are, in fact, part of the class. (Do this in the type checker - GHC does the corresponding checks for methods in the type checker, too.)
 * Families declared as an AT, may not receive toplevel type instances.
 * For each case scrutinising an associated data type, check that all constructors have been defined in a single instance.  (Maybe we can just extend the existing check that ensures that case expressions don't mix constructors of different data types.)
 * RHS of a `type instance` must be a tau type.
 * Check that patterns of type indexes don't contain type functions.
 * Construct `InstInfo` for type equation in `tcIdxTyInstDecl1`.
 * If an associated synonym has a default definition, use that in the instances.  In contrast to methods, this cannot be overridden by a specialised definition.  (Confluence requires that any specialised version is extensionally the same as the default.)

Todo (high-level):
 1. Type checking of type functions (and hence, associated type synonyms); forget about `iso` for the moment.
 2. Type checking in the presence of associated synonym defaults.  (Default AT synonyms are only allowed for ATs defined in the same class.)
 3. Type check functional dependencies as type functions.

Done: 
 * Kind and type checking of kind signatures.
 * Kind and type checking of instance declarations of indexed types.
 * Wrapper generation and type checking of pattern matching for indexed data types (no newtypes yet.)

== Desugaring ==

Todo (low-level):
 * Handle new type instances.
 * When a family type is exported/imported, all its instances need to be implicitly imported/exported, just as with classes.
 * Derivings on an associated data type ''declaration'' need to be inherited by all definitions of that data type in instances.

Todo (high-level):
  1. Extend interface files to include euqality axioms:
   * How do we exactly want to represent type equations in interface files?
     * SPJ pointed out that instances are maintained in `InstEnv.InstEnv` with different values for the home packages and others. Type instances may have to be maintained in a similar way, as they are also incrementally collected during compiling a program.  (We probably include them in the same structure, as they will also be of type `InstInfo`.)
     * `IfaceInst` contains the instance declaration information for interfaces.
   * Export and import lists: The name lists that may appear at class imports and exports can now also contain type names, which is tricky as data type names can carry a list of data constructors.
 3. Desugar type functions and equality constraints.

Done:
 * Representation of family kind signatures as `TyCon.TyCon`s.
 * Extension of `Class.Class` by associated `TyCon`s.
 * Extension of `TyCon.TyCon` with a reference to the parent `TyCon` for data instances.
 * Extension of `DataCon.DataCon` with instance types for constructors belonging to data instances.
 * Extension of `TyCon.TyCon` such that the parent of a data instance is paired with a coercion identifying family instance and representation type.
 * For indexed data types, the datacon wrapper uses data instance coercion and pattern matching casts the scrutinee via an `ExprCoFn` in a `CoPat`.


== Testsuite ==

Todo:
 * Convert AT.hs to tests in the testsuite.