

= Status of DPH Benchmarks =

'''Last updated''': 2nd December 2010.

This page gives an overview of how well the benchmarks in the [http://darcs.haskell.org/packages/dph/dph-examples dph-examples/] directory of package dph are currently working.

The benchmarks are run each night by [http://darcs.haskell.org/packages/dph/dph-buildbot DPH BuildBot]. The results are posted to cvs-ghc and uploaded to [http://log.ouroborus.net/limitingfactor/dph/]. Check there for the latest numbers.

[[br]]
= Summary =
 * Evens: gets slower as the number of threads increases, probably because it's using a filtering operation.
 * !QuickHull: vectorised.par.N1 version is 6x slower than the immutable Data.Vector version in absolute terms. This may be related to the problem with Evens.
 * !QuickSort: vectorised.seq version doesn't compile due to a blow-up in !SpecConstr.
 * !BarnesHut: has a core-lint error due to a bug in the rule matcher. If you turn off -dcore-lint it segfaults when run. Before recent GHC changes it compiled (with core-lint error), but vectorised.par Barnes-Hut algorithm was 50x slower than the version using immutable Data.Vector.

= !ToDo =
 * Benchmarks are currently being run with -fasm, and not via the LLVM backend. This will affect comparisons with C, but not with Data.Vector as it uses the same backend.

[[br]]
----
----
= Flat Parallelism =
Flat parallel programs are ones in which parallel computations do not invoke further parallel computations. For Repa, this means that the value of each element in a given array can be computed independently of the others. These should run as fast as equivalent programs using immutable Data.Vector. We'd also hope to get close to the performance of C programs using equivalent algorithms, though this is a harder comparison due to differences in the back-end code generator.

[[br]]
  [http://code.haskell.org/repa/repa-head/repa-examples/MMult/ MMult]::
   Matrix-Matrix multiplication. Size=1024x1024.

  || '''name''' || '''runtime''' || '''speedup''' || '''efficiency''' || '''notes'''
  || repa.mmult.c.seq ||  3.792s || 1 || 1 || A ||
  || repa.mmult.par.N1 || 8.484s || 0.45 || 0.45 || ||
  || repa.mmult.par.N4 || 2.147s || 1.77 || 0.44 || ||
  || repa.mmult.par.N8 || 1.097s || 3.46 || 0.43 || ||

  A: Straightforward C program using triple nested loops. A cache-friendly block-based version would be faster.

  '''Status:''' Ok, but about 20% slower than in 6.13.[[br]]
  '''ToDo:''' Run with LLVM and without bounds checking.

[[br]]
  [http://code.haskell.org/repa/repa-head/repa-examples/Laplace/ Laplace] '''(SLOWLORIS)'''::
   Solves the Laplace equation in the 2D plane. Size=400x400.

  || '''name''' || '''runtime''' || '''speedup''' || '''efficiency''' || '''notes''' ||
  || repa.laplace.c.seq ||  1.299s || 1 || 1 || A ||
  || repa.laplace.par.N1 || 9.405s || 0.14 || 0.14 || ||
  || repa.laplace.par.N4 || 2.521s || 0.51 || 0.13 || ||
  || repa.laplace.par.N8 || 2.124s || 0.61 || 0.08 || ||
  A: Straightforward C program using triple nested loops. A cache-friendly block-based version would be faster.

  '''Status:''' Too slow. We should check this again with LLVM.[[br]]
  '''ToDo:''' Run with LLVM and without bounds checking. Run with more threads to see if we can get back to the C version's run time.


[[br]]
  [http://code.haskell.org/repa/repa-head/repa-examples/Blur/ Blur]::
  Applies a Gaussian blur filter to a 2D image. Size=512x512.

  '''ToDo:''' Runs ok, but need to add other versions for comparison.


[[br]]
  [http://code.haskell.org/repa/repa-head/repa-examples/EdgeDetect/ EdgeDetect]::
  Performs Canny edge detection to a 2D image. Size=512x512.

  '''ToDo:''' Runs ok, but need to add other versions for comparison.

[[br]]
  [http://code.haskell.org/repa/repa-head/repa-examples/FFT/ FFT]::
  Performs high-pass filtering using 2D and 3D FFTs. These are naive benchmarks used for regression testing only. They divide right down to (rank generalise) two-point vectors and construct the result using copying append. Using an inplace algorithm (like with FFTW) would be significantly faster.

  '''ToDo:''' Runs ok, but need to add other versions for comparison.


[[br]]
= Statically Nested Parallelism =
Statically nested parallelism is where the parallelism has a fixed, finite depth. For example ``mapP f (filterP g xs)``. Statically nested programs are easier to vectorise than dynamically nested programs. At present, single threaded statically nested programs should run as fast as equivalent Data.Vector programs. Parallel versions should display a good speedup.

 [http://darcs.haskell.org/packages/dph/dph-examples/imaginary/SumSquares/ SumSquares]::
  Computes the sum of the squares from 1 to N using `Int`.  N = 100M.

  || '''name''' || '''runtime''' || '''speedup''' || '''efficiency''' || '''notes'''
  || dph.sumsq.vector.seq.N4 ||  404ms || 1 || 1 || ||
  || dph.sumsq.vectorised.seq.N4 || 434ms || 0.93 ||  || ||
  || dph.sumsq.vectorised.par.N1 || 443ms || 0.91 || 0.91 || ||
  || dph.sumsq.vectorised.par.N2 || 222ms || 1.82 || 0.91 || ||
  || dph.sumsq.vectorised.par.N4 || 111ms || 3.63 || 0.91 || ||

  '''Status''': fine[[br]]
  '''Todo''': Add a sequential C version.

[[br]]
 [http://darcs.haskell.org/packages/dph/dph-examples/imaginary/DotProduct DotProduct]::
  Computes the dot product of two vectors of `Double`s. N=10M.

  || '''name''' || '''runtime''' || '''speedup''' || '''efficiency''' || '''notes''' ||
  || dph.dotp.vector.seq.N4 ||  68ms || 1 || 1 || ||
  || dph.dotp.vectorised.seq.N4 || 58ms || 1.17 || || A ||
  || dph.dotp.vectorised.par.N1 || 55ms || 1.24 || 1.24 || ||
  || dph.dotp.vectorised.par.N2 || 33ms || 2.06 || 1.03 || ||
  || dph.dotp.vectorised.par.N4 || 25ms || 2.72 || 0.68 || ||
 
  A: The sequential vectorised version is faster than with Data.Vector. Why was this?

  '''Status''': fine[[br]]
  '''Todo''': Add a sequential C version.

[[br]]
  [http://darcs.haskell.org/libraries/dph/dph-examples/imaginary/Evens/ Evens] '''(SLOWDOWN)'''::
   Takes the even valued `Int`s from a vector. N=10M.

  || '''name''' || '''runtime''' || '''speedup''' || '''efficiency''' || '''notes''' ||
  || dph.evens.vectorised.seq.N4 || 1.075s || 1 || 1 || ||
  || dph.evens.vectorised.par.N1 || 736ms ||  1.46 || 1.46 || ||
  || dph.evens.vectorised.par.N2 || 768ms ||  1.40 || 0.70 || ||
  || dph.evens.vectorised.par.N4 || 859ms ||  1.25 || 0.31 || ||

  '''Status''': Benchmark runs slower when number of threads increases. This benchmark invokes {{{packByTag}}} due to the filtering operation. This is probably affecting Quickhull as it also uses filtering. [[br]] 
  '''Todo''': Fix slowdown. Add a sequential C version and Data.Vector versions.

 [[br]]
 [http://darcs.haskell.org/packages/dph/examples/smvm/ SMVM]::
 Multiplies a dense vector with a sparse matrix represented in the ''compressed sparse row format (CSR).''  

  '''Todo''': Add this to the nightly run.

[[br]]
= Dynamically Nested Parallelism =
Dynamically nested programs have a recursive structure where each level of the recursion invokes more parallel computations. This is common for benchmarks that use divide-and-conquer style algorithms.

 [http://darcs.haskell.org/packages/dph/examples/primes/ Primes]::
  The Sieve of Eratosthenes using parallel writes into a sieve structure represented as an array of `Bool`s.  

  '''Todo''': We currently don't have a proper parallel implementation of this benchmark, as we are missing a parallel version of default backpermute.  The problem is that we need to make the representation of parallel arrays of `Bool` dependent on whether the hardware supports atomic writes of bytes. Investigate whether any of the architectures relevant for DPH actually do have trouble with atomic writes of bytes (aka `Word8`).

[[br]]
 [http://darcs.haskell.org/libraries/dph/dph-examples/spectral/QuickSort/ QuickSort] '''(BROKEN)'''::
  Sort a vector of doubles by recursively splitting it and sorting the two halves. This is a naive benchmark used for regression testing only. We divide right down to two-point vectors and construct the result using copying append. A production algorithm would switch to an in-place sort once the size of the vector reaches a few thousand elements. N=100k.

  || '''name''' || '''runtime''' || '''speedup''' || '''efficiency''' || '''notes''' ||
  || dph.quicksort.vectorised.par.N1 || 428ms ||  1 || 1 || ||
  || dph.quicksort.vectorised.par.N2 || 400ms ||  1.07 || 0.54 || ||
  || dph.quicksort.vectorised.par.N4 || 392ms ||  1.09 || 0.27 || ||

  '''Status''': Sequential vectorised version does not compile due to a blowup in !SpecConstr.

[[br]]
 [http://darcs.haskell.org/libraries/dph/dph-examples/spectral/QuickHull/ Quickhull] '''(SLOWLORIS)'''::
  Given a set of points in the plane, compute the sequence of points that encloses all points in the set. This benchmark is interesting as it is the simplest code that exploits the ability to implement divide-and-conquer algorithms with nested data parallelism. N=1M.


  || '''name''' || '''runtime''' || '''speedup''' || '''efficiency''' || '''notes''' ||
  || dph.quickhull.vector-immutable.seq.N4 || 0.166s || 1 || 1 || ||
  || dph.quickhull.vectorised.seq.N4 || 0.677s ||  0.24 ||  || 4x slower ||
  || dph.quickhull.vectorised.par.N1 || 1.059s ||  0.15 || 0.15 || 6x slower||
  || dph.quickhull.vectorised.par.N2 || 0.809s ||  0.21 || 0.11 || ||
  || dph.quickhull.vectorised.par.N4 || 0.686s ||  0.24 || 0.06 || ||
  || dph.quickhull.vector-mutable.seq.N4 || 0.086s ||  1.93 || || A ||
  || dph.quickhull.vector-forkIO.par.N4 || 0.064s ||  2.59 || 0.65 || B ||
  || dph.quickhull.c.seq || 0.044s || 3.77 || || C ||

 A: Uses mutable Data.Vectors for intermediate buffers.[[br]]
 B: Uses mutable Data.Vectors, forkIO and atomicModifyIORef. Concurrent threads fill a shared output vector. Code is uglier than the C version.[[br]]
 C: Sequential C version with pre-allocated mutable intermediate buffers.[[br]]

 '''Status''': Benchmark scales but single threaded vectorised.par version is 6x slower than slower than version using immutable Data.Vectors. !QuickHull is based around filtering operations, so the fact that Evens is also slow is probably related.


[[br]]
= Dynamically Nested Parallelism with Algebraic Data Types =
These programs also use user defined algebraic data types. Vectorization of these programs is still a work in progress.

 [http://darcs.haskell.org/libraries/dph/dph-examples/real/NBody/ BarnesHut] '''(BROKEN)'''::
  This benchmark implements the Barnes-Hut algorithm to solve the ''n''-body problem in two dimensions. There is a naive O(n^2^) version in the same package.

  '''Status''': Core-lint error due to bug in GHC's rule matcher. If we compile without -dcore-lint it segfaults when run.

[[br]]
----
----
= Key =
dph.<''benchmark''>.<''version''>.<''parallelism''>.[''threads''][[br]]
repa.<''benchmark''>.[''version''].[''threads''][[br]]

''version''
 * ''vectorised'' means it's been through the DPH vectorising transform. 
 * ''vector'' is a hand written version using immutable Data.Vectors
 * ''vector-mutable'' is a hand written version using mutable Data.Vectors.
 * ''vector-immutable'' means the same as ''vector'' and is used when there is also an mutable version.

''parallelism''
 * Whether a benchmark is natively parallel or sequential. 
 * Parallel versions are also run single threaded (with -N1) and sequential versions are also run with (-N4) so we get the parallel GC.
 * Parallel versions with -N1 will tend to be slower than natively sequential versions due to overheads for supporting parallelism.

''threads''
 * Value passed to Haskell Runtime with -N threads flag.
 * Number of Haskell Execution Contexts (HECs) used when running the benchmark. 
 * Can be less than the number of hardware threads / cores in the physical machine.

'''speedup'''
 * Runtime of reference / runtime of benchmark.
 * Measures how much faster a benchmark is relative to the reference.

(relative) '''efficiency'''
 * Speedup / number of threads.
 * Indicates the communication overhead involved with running something in parallel.
 * Can be > 1 if the parallel version running with a single thread is faster than the sequential reference version.

'''Status:'''
 * '''BROKEN''': Benchmark doesn't compile, or crashes when run.
 * '''SLOWDOWN''': Benchmark gets slower as number of threads increases. 
 * '''SLOWLORIS''': Benchmark scales as the number of threads increases, but the absolute performance is not acceptable compared with equivalent versions using immutable Data.Vectors. We do not have a setup in which the parallel version runs faster than the sequential reference version. Cute, but too slow to be useful.

[[br]]
= Benchmark machine  =
 * 2x 3.0GHz Quad-Core Intel Xeon 5400
 * 12MB (2x6MB) on-die L2 cache per processor
 * independent 1.6GHz frontside bus per processor
 * 800MHz DDR2 FB-DIMM
 * 256-bit-wide memory architecture
 * Mac OS X Server 10.5.6
