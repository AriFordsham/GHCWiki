= The VECTORISE pragma =

The vectoriser needs to know about all types and functions whose vectorised variants are directly implemented by the DPH library (instead of generated by the vectoriser), and it needs to know what the vectorised versions are.  That is the purpose of the `VECTORISE` pragma (which comes in in number of flavours).


== The basic VECTORISE pragma for values ==

Given a function `f`, the vectoriser generates a vectorised version `f_v`, which comprises the original, scalar version of the function and a second version lifted into array space.  The lifted version operates on arrays of inputs and produces arrays of results in one parallel computation.  The original function name is, then, rebound to use the scalar version referred to by `f_v`.  This differs from the original in that it uses vectorised versions for any embedded parallel array computations.

However, if a function `f` is accompanied by a pragma of the form
{{{
{-# VECTORISE f = e #-}
}}}
then the vectoriser defines `f_v = e` and refrains from rebinding `f`.  This implies that for `f :: t`, `e`'s type is the `t` vectorised (in particular), `e`'s type uses the array closure type `(:->)` instead of the vanilla function space `(->)`.


== The NOVECTORISE pragma ==

If a function `f` is accompanied by a pragma
{{{
{-# NOVECTORISE f #-}
}}}
then it is ignored by the vectoriser â€” i.e., no function `f_v` is generated and `f` is left untouched.

'''Caveat:''' If `f`'s definition contains bindings that are being floated to the toplevel, those bindings will still be vectorised.

== VECTORISE SCALAR ==