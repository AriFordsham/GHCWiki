== Type Vectorisation ==

The transformation of types includes both closure conversion and the pairing of scalar with lifted computations.

=== Unboxed types ===

Unboxed types and functions defined in `GHC.Prim` need to be treated specially during vectorisation.  This is as we cannot have `PA` instances for unboxed types and the transformation needs to know which functions from `GHC.Prim` can be safely parallelised (e.g., its fine to run many `+#` in parallel, whereas this is not really advisable for calls to side-effecting RTS functions).  Indeed, we might regard unboxed types and functions from `GHC.Prim` as the place where we make the transition from implementing vectorisation decisions in package ndp to hard-coding them into the compiler.  It is probably a good idea to eventually move as much as possible of the hardcoded information into `primops.txt.pp`, but for the moment, we simply hardcode everything in the modules in `vectorise/`.

To treat unboxed type properly, we cannot simply use the type constructor `PArr` wherever we need a flattened array; instead, we define a type translation
{{{
Int#^    = UArr Int
Float#^  = UArr Float
Double#^ = UArr Double
<and so on for other unboxed types>
t^       = PArr t
}}}

=== Transformation rules ===

TODO:
 * Be careful that `t1* ->> t2*` includes `PArr t1` and `PArr t2*`; so, we can only use that if we have `PA` instances for these types.

The type transformation rules achieve two goals: (1) they replace original type constructors and variables by their vectorised variants, where those are available, and (2) they alter the representation of functions:
{{{
T*            = T_V  , if T_V exists
              = T    , otherwise
a*            = a_v
(t1 -> t2)*   = t1* ->> t2*
(t1 t2)*      = t1* t2*
(forall a.t)* = forall a_v.t*
}}}
The transformation of function types includes both the change from `(->)` to `(:->)` as well as 

{{{
T*            = T_V , if T_V exists
              = T    , otherwise
a*            = a_v
(t1 -> t2)*   = (  t1*  -> t2*,   , if kindOf t1 == #
                 [:t1*  -> t2*:])   or kindOf t2 == #
              = (  t1* :-> t2*,   , otherwise
                 [:t1* :-> t2*:])
(t1 t2)*      = t1* t2*
(forall a.t)* = forall a_v.t*
}}}